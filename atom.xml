<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烏巢</title>
  <icon>https://hejueyun.github.io/icon.png</icon>
  <subtitle>A Self-taught Idiot 🖊</subtitle>
  <link href="https://hejueyun.github.io/atom.xml" rel="self"/>
  
  <link href="https://hejueyun.github.io/"/>
  <updated>2022-02-18T21:30:49.927Z</updated>
  <id>https://hejueyun.github.io/</id>
  
  <author>
    <name>何决云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机数理逻辑-一阶逻辑(4)</title>
    <link href="https://hejueyun.github.io/posts/bb11e25b/"/>
    <id>https://hejueyun.github.io/posts/bb11e25b/</id>
    <published>2022-02-18T15:27:40.000Z</published>
    <updated>2022-02-18T21:30:49.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Terms-项"><a href="#Terms-项" class="headerlink" title="Terms 项"></a>Terms 项</h3><ul><li>Variables. <ul><li>Any variable is a term.</li></ul></li><li>Functions. <ul><li>Any expression $f(t_1,…,t_n)$ of n arguments (where each argument $t_i$ is a term and f is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.</li></ul></li></ul><p>Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms</p><h3 id="prenex-conjunctive-normal-form-PCNF-前束范式"><a href="#prenex-conjunctive-normal-form-PCNF-前束范式" class="headerlink" title="prenex conjunctive normal form(PCNF) 前束范式"></a>prenex conjunctive normal form(PCNF) 前束范式</h3><ul><li>A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:<ul><li>$Q_1x_1…Q_nx_nM$</li></ul></li><li>where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1⋯Q_nx_n$ is the prefix and $M$ is the matrix</li></ul><blockquote><p>如果一个公示可以被写为量词在前，随后是被称为母体的无量词部分，则称其为前束范式的，所有经典逻辑公式都逻辑等价于某个前束范式公式</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Terms-项&quot;&gt;&lt;a href=&quot;#Terms-项&quot; class=&quot;headerlink&quot; title=&quot;Terms 项&quot;&gt;&lt;/a&gt;Terms 项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Variables. &lt;ul&gt;
&lt;li&gt;Any variable is a term.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions. &lt;ul&gt;
&lt;li&gt;Any expression $f(t_1,…,t_n)$ of n arguments (where each argument $t_i$ is a term and f is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms&lt;/p&gt;
&lt;h3 id=&quot;prenex-conjunctive-normal-form-PCNF-前束范式&quot;&gt;&lt;a href=&quot;#prenex-conjunctive-normal-form-PCNF-前束范式&quot; class=&quot;headerlink&quot; title=&quot;prenex conjunctive normal form(PCNF) 前束范式&quot;&gt;&lt;/a&gt;prenex conjunctive normal form(PCNF) 前束范式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:&lt;ul&gt;
&lt;li&gt;$Q_1x_1…Q_nx_nM$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1⋯Q_nx_n$ is the prefix and $M$ is the matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个公示可以被写为量词在前，随后是被称为母体的无量词部分，则称其为前束范式的，所有经典逻辑公式都逻辑等价于某个前束范式公式&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-一阶逻辑(3)</title>
    <link href="https://hejueyun.github.io/posts/f450749c/"/>
    <id>https://hejueyun.github.io/posts/f450749c/</id>
    <published>2022-02-18T15:11:01.000Z</published>
    <updated>2022-02-18T15:50:42.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deductive-system"><a href="#Deductive-system" class="headerlink" title="Deductive system"></a>Deductive system</h2><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><ul><li>We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference <strong>for the universal quantifier</strong>全称量词.</li></ul><center><img loading="lazy" src="/posts/f450749c/1.gif" width="550"></center><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><ul><li>The rules of inference are modus ponens and generalization</li></ul><center><img loading="lazy" src="/posts/f450749c/2.gif" width="550"></center><ul><li>The Deduction Rule：</li></ul><center><img loading="lazy" src="/posts/f450749c/3.gif" width="550"></center>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Deductive-system&quot;&gt;&lt;a href=&quot;#Deductive-system&quot; class=&quot;headerlink&quot; title=&quot;Deductive system&quot;&gt;&lt;/a&gt;Deductive system&lt;/h2&gt;&lt;h3 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference &lt;strong&gt;for the universal quantifier&lt;/strong&gt;全称量词.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/1.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;H&quot;&gt;&lt;a href=&quot;#H&quot; class=&quot;headerlink&quot; title=&quot;H&quot;&gt;&lt;/a&gt;H&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The rules of inference are modus ponens and generalization&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/2.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;The Deduction Rule：&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/3.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>SMT Solvers</title>
    <link href="https://hejueyun.github.io/posts/5447ed65/"/>
    <id>https://hejueyun.github.io/posts/5447ed65/</id>
    <published>2022-02-16T00:11:05.000Z</published>
    <updated>2022-02-17T23:40:44.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论"><a href="#SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论" class="headerlink" title="SAT vs SMT 布尔可满足性问题 vs  可满足性模理论"></a>SAT vs SMT 布尔可满足性问题 vs  可满足性模理论</h2><ul><li>SMT将SAT推广到涉及 实数 、 整数 和&#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串</li><li>由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)</li></ul><center><img loading="lazy" src="/posts/5447ed65/1.png" width="550"></center><p>SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：</p><ul><li>在命题逻辑公式里面混入了一些一阶逻辑表达式</li><li>具有任意的布尔结构</li></ul><blockquote><p>SAT solvers are automatic and efficient</p><p>However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. <strong>A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines</strong></p></blockquote><h2 id="Solver-vs-Checker"><a href="#Solver-vs-Checker" class="headerlink" title="Solver vs Checker"></a>Solver vs Checker</h2><ul><li>In model checking, you have a model and a specification (or property), and you check if the model meets the specification.</li><li>In SAT solving, you have a formula and you try to find a satisfying assignment to it.</li></ul><hr><ul><li>To perform model checking a reachability analysis is needed and to do this the program transitions are often executed symbolically</li><li>The solution to the resulting satisfaction problem is created by a solver</li></ul><h2 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h2><h2 id="arithmetic-overflow-算术溢出"><a href="#arithmetic-overflow-算术溢出" class="headerlink" title="arithmetic overflow 算术溢出"></a>arithmetic overflow 算术溢出</h2><ul><li>当计算产生出来的结果是非常大的，大于寄存器或存储器所能存储或表示的能力限制</li><li>任何数除以零的计算（Divided by zero）“不是”算术溢出的一种。在数学上只能明显算是不明确的定义（Undefined）；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值</li></ul><h2 id="arithmetic-underflow算术下溢"><a href="#arithmetic-underflow算术下溢" class="headerlink" title="arithmetic underflow算术下溢"></a>arithmetic underflow算术下溢</h2><ul><li>算术下溢也称为浮点数下溢，是指计算机浮点数计算的结果小于可以表示的最小数</li><li>例如，浮点数指数范围为-128至127，一个绝对值小于2−127的浮点数就会造成下溢（假设-128的阶码用于表示负无穷）</li></ul><h2 id="equality-with-uninterpreted-functions-EUF"><a href="#equality-with-uninterpreted-functions-EUF" class="headerlink" title="equality with uninterpreted functions(EUF)"></a>equality with uninterpreted functions(EUF)</h2><ul><li>An uninterpreted function or function symbol is one that has no other property than its name and n-ary form. Function symbols are used, together with constants and variables, to form terms.</li><li>The theory of uninterpreted functions is also sometimes called the <strong>free theory</strong>, because it is freely generated, and thus a free object, or the empty theory, being the theory having an empty set of sentences (in analogy to an initial algebra). <ul><li>Theories with a non-empty set of equations are known as <strong>equational theories</strong></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/43908872/smt-sat-solver-vs-model-checker">SMT&#x2F;SAT Solver vs Model Checker - Stack Overflow</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论&quot;&gt;&lt;a href=&quot;#SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论&quot; class=&quot;headerlink&quot; title=&quot;SAT vs SMT 布尔可满足性问题 vs  可满足性模理论&quot;&gt;&lt;/a&gt;SAT vs SMT 布尔可满足性问题 vs  可满足性模理论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SMT将SAT推广到涉及 实数 、 整数 和&amp;#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串&lt;/li&gt;
&lt;li&gt;由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/5447ed65/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在命题逻辑公式里面混入了一些一阶逻辑表达式&lt;/li&gt;
&lt;li&gt;具有任意的布尔结构&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SAT solvers are automatic and efficient&lt;/p&gt;
&lt;p&gt;However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. &lt;strong&gt;A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Solver-vs-Checker&quot;&gt;&lt;a href=&quot;#Solver-vs-Checker&quot; class=&quot;headerlink&quot; title=&quot;Solver vs Checker&quot;&gt;&lt;/a&gt;Solver vs Checker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;In model checking, you have a model and a specification (or property), and you check if the model meets the specification.&lt;/li&gt;
&lt;li&gt;In SAT solving, you have a formula and you try to find a satisfying assignment to it.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;To perform model checking a reachability analysis is needed and to do this the program transitions are often executed symbolically&lt;/li&gt;
&lt;li&gt;The solution to the resulting satisfaction problem is created by a solver&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-一阶逻辑-语法与语义</title>
    <link href="https://hejueyun.github.io/posts/ed4b45dd/"/>
    <id>https://hejueyun.github.io/posts/ed4b45dd/</id>
    <published>2022-02-15T23:57:35.000Z</published>
    <updated>2022-02-18T15:59:08.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>命题逻辑对于算术等数学理论的形式化来说，表现力并不充分。一个算术表达式，如$x+2&gt;y-1$，既不是真的，也不是假的。</p><ol><li>它的真假取决于变量x和y的值</li><li>我们需要将运算符+和-的含义形式化，作为将一对数字映射为一个数字的函数</li><li>像&gt;这样的关系运算符必须被形式化为将一对数字映射为真值</li></ol><h2 id="命题逻辑vs一阶逻辑"><a href="#命题逻辑vs一阶逻辑" class="headerlink" title="命题逻辑vs一阶逻辑"></a>命题逻辑vs一阶逻辑</h2><ol><li><p>命题逻辑（Propositional Logic） </p><ol><li>形如 ¬P，P∧Q，P∨Q，P → Q ，P↔Q的语句，值为True或者False</li><li>推理规则较简单，往往通过（1.真值表  2.为数不多的推理规则，例如Modus ponesn等几个）</li><li>缺点：不能或者很难表示复杂的语句，不能记录推理过程中的变化</li></ol></li><li><p>一阶逻辑（First Order Logic），简称FOL</p><ol><li>包含的东西有常量（Constant symbol），谓词符号（Predicate symbol），函数符号（Function symbol），变量（Variable），连词（ ∧∨→↔），量词（Quantifiers, ∃∀）</li></ol></li><li><p>命题逻辑(很少部分人叫它作零阶逻辑). 在命题逻辑里, 每一个字母就代表一个命题, 所以命题逻辑只能表达句子之间的关系, 比如“p&amp;q”, “if p then q”等等的真值如何从p和q的真值中计算出来.</p></li><li><p>一阶逻辑则引入了两个量词, 即universal quantifier(倒A)和existential quantifier(倒E), 并且加入了一阶谓词和individual variables和individual constants. 这些导致一阶逻辑可以量化individuals in the domain.</p><ol><li>比如经典的三段论就可以被一阶逻辑表达 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For all x, Hx-&gt;Mx</span><br><span class="line"></span><br><span class="line">Hs</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">Ms</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory"><a href="#vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory" class="headerlink" title="vs Propositional Logic vs Set Theory vs Elementary Number Theory"></a>vs Propositional Logic vs Set Theory vs Elementary Number Theory</h3><p><strong>Propositional Logic</strong></p><ul><li><strong>Equality: no</strong></li><li>Predicate symbols: A1, A2, . . .</li><li><strong>Constant symbols: none</strong></li><li><strong>Function symbols: none</strong></li></ul><p><strong>Set Theory</strong></p><ul><li>Equality: yes</li><li>Predicate symbols: ∈</li><li>Constant symbols: ∅</li><li>Function symbols: none</li></ul><p><strong>Elementary Number Theory</strong>初等数论</p><ul><li>Equality: yes</li><li>Predicate symbols: &lt;</li><li>Constant symbols: 0</li><li>Function symbols: S (successor), +, ×, exp</li></ul><h2 id="集合论vs一阶逻辑"><a href="#集合论vs一阶逻辑" class="headerlink" title="集合论vs一阶逻辑"></a>集合论vs一阶逻辑</h2><ul><li>集合论作为公理系统，一阶逻辑作为<strong>推理系统</strong>，共同为数学打下基石</li><li>谈论某一理论时，都需要有<strong>上层语言</strong>（meta-language）作为基础。对于最上层的语言研究一般归于哲学的范畴<ul><li>基于上层语言，我们可以定义<strong>一阶语言</strong>（一阶逻辑的语言），语言中字母表、项、公式的不同可以产生不同的“子语言”。如：初等算术语言，群论语言，<strong>集合论语言</strong></li><li>定义一阶语言的模型，模型对语言做出解释（可以看成是<strong>语义</strong>部分）。譬如对于初等算术语言，有初等算术的标准模型</li><li>一阶语言的推理系统给出了一阶逻辑的语法。不同的推理系统如自然推理系统和 PK 推理系统可以证明是等价的。同时注意到，推理系统可以独立于模型（<strong>语义</strong>）而存在。而推理系统的 soundness 和 completeness 保证了语义与语法的一致性</li></ul></li><li>同阶下，一阶语言的集合论是一阶逻辑的一部分（一阶语言+公式集），但一阶逻辑又不能表达所有的集合论（高阶）</li></ul><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p><strong>Logical Symbols</strong></p><ul><li>Parentheses: (, )</li><li>Propositional connectives: ¬, ∨, ∧, →, ↔</li><li>Variables: v1, v2, . . .</li><li>Quantifiers: ∀, ∃<ul><li>Quantifiers allow a purely syntactical expression of the statement that the relation represented by a predicate is true for some or all elements of the domain</li><li>量词允许以纯语法的方式来表达谓词所代表的关系对域中的某些或所有元素来说是真的</li></ul></li></ul><p><strong>Parameters</strong></p><ul><li>Equality symbol (optional): &#x3D;</li><li>Predicate谓词 symbols: e.g. p(x), x &gt; y</li><li>Constant symbols: e.g. 0, John, π</li><li>Function symbols: e.g. f(x), x + y, x +[2] y</li></ul><h3 id="Predicate-谓词"><a href="#Predicate-谓词" class="headerlink" title="Predicate 谓词"></a>Predicate 谓词</h3><ul><li>Predicates are used to represent <strong>functions</strong> from a domain to truth values<ul><li><strong>谓词</strong>被用来表示从域到真值的<strong>函数</strong></li><li>$p^n$ is called an n-ary predicate</li></ul></li></ul><h3 id="Quantifier-量词"><a href="#Quantifier-量词" class="headerlink" title="Quantifier 量词"></a>Quantifier 量词</h3><ul><li>∀ is the universal quantifier and is read <strong>for all</strong>.</li><li>∃ is the existential quantifier and is read <strong>there exists</strong></li><li>A universal or existential formula ∀xA or ∃xA is a <strong>quantified formula</strong></li><li>In many presentations of first-order logic, ∀ is defined in the logic and ∃ is considered to be an abbreviation of ¬ ∀¬</li></ul><h3 id="断言符号？"><a href="#断言符号？" class="headerlink" title="断言符号？"></a>断言符号？</h3><p>断言是容许一个、甚至多个对象，所以对于自然数 $n,j$ 我们约定 $A_{j}^{n}(x_1,x_2,…,x_n)$ 为一阶逻辑的<strong>合法词汇</strong>，它在直观上表示一个有 ${\displaystyle{} n}$ 个”对象”的断言，我们称它为 ${\displaystyle{} n}$ 元断言符号。下标的自然数 ${\displaystyle{} j}$ 只是拿来和其他同为 ${\displaystyle{} n}$ 元的断言符号作区别</p><h3 id="arity-元数"><a href="#arity-元数" class="headerlink" title="arity 元数"></a>arity 元数</h3><blockquote><p>函数或运算的元数是指所需的参数或算子的数量。关系的元数则是指其对应之笛卡儿积的维度</p></blockquote><ul><li>一元unary函数、二元…</li><li>Equality is a special predicate symbol of arity 2.</li><li>Constant symbols can also be thought of as functions whose arity is 0.</li></ul><h2 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h2><ul><li>本质上是n元关系</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/3.gif" width="550"></center><h3 id="Atomic-Formulas-原子公式"><a href="#Atomic-Formulas-原子公式" class="headerlink" title="Atomic Formulas 原子公式"></a>Atomic Formulas 原子公式</h3><ul><li>An atomic formula is an expression of the form: $P(t_1, . . . , t_n)$ here P is a predicate symbol of arity n and $t_1,. . . ,t_n$ are terms.</li><li>If the language includes the equality symbol, we consider the equality symbol to be a special predicate of arity 2</li></ul><h3 id="Well-formed-Formulas-合式公式"><a href="#Well-formed-Formulas-合式公式" class="headerlink" title="Well-formed Formulas 合式公式"></a>Well-formed Formulas 合式公式</h3><ul><li>The set of well-formed formulas is the set of expressions generated from the <strong>atomic</strong> formulas by the operations E¬, E→, and $Q_{i}i$ &#x3D; 1, 2, . . .</li></ul><ol><li>原子公式为公式。(美观起见，在原子公式外面包一层括弧也是公式)</li><li>若 ${\displaystyle {\mathcal {A}}}$ 为公式，则 (${\displaystyle (\neg {\mathcal {A}})}$ 为公式。</li><li>若 ${\displaystyle {\mathcal {A}}}$ 与 ${\displaystyle {\mathcal {B}}}$ 为公式，则 ${\displaystyle ({\mathcal {A}}\Rightarrow {\mathcal {B}})}$ 为公式。</li><li>若 ${\displaystyle {\mathcal {A}}}$ 为公式， ${\displaystyle x}$ 为任意变量，则 ${\displaystyle (\forall x{\mathcal {A}})}$ 为公式。 (美观起见 ${\displaystyle (\forall x){\mathcal {A}}:&#x3D;\forall x{\mathcal {A}}}$ ，也就是里面的量词有无外包括弧都是公式)<br>合式公式只能透过以上四点，于有限步骤内置构出来</li></ol><h3 id="quantified-formula-量化公式"><a href="#quantified-formula-量化公式" class="headerlink" title="quantified formula 量化公式"></a>quantified formula 量化公式</h3><ul><li>A universal or existential formula ∀xA or ∃xA is a quantified formula. </li><li>x is the quantified variable and its scope is the formula A. </li><li>It is not required that x actually appear in the scope of its quantification.</li></ul><hr><ul><li>If a formula has no free variables, it is <strong>closed</strong>. If ${x_1,…,x_n}$ are all the free variables of A, the universal closure of A is $∀x_1 …∀x_n$ A and the existential closure is $∃x_1…∃x_n$ A.</li></ul><p><strong>Example</strong></p><ol><li>p(x,y) has two free variables x and y, ∃yp(x,y) has one free variable x and ∀x∃yp(x,y) is closed. The universal closure of p(x,y) is ∀x∀yp(x,y) and its existential closure is ∃x∃yp(x,y).</li><li>In $∀xp(x)∧q(x)$, the occurrence of x in $p(x)$ is bound and <strong>the occurrence in $q(x)$ is free</strong>. The universal closure is $∀x(∀xp(x)∧q(x))$. <ol><li>Obviously, it would have been better to write the formula as $∀xp(x)∧q(y)$ with y as the free variable; its universal closure is ∀y(∀xp(x)∧q(y)) 如何理解？</li></ol></li></ol><h4 id="Free-and-Bound-Variables-自由变量和约束变量"><a href="#Free-and-Bound-Variables-自由变量和约束变量" class="headerlink" title="Free and Bound Variables 自由变量和约束变量"></a>Free and Bound Variables 自由变量和约束变量</h4><p>量词所施用的<strong>公式</strong>被称为**量词的范围(scope)**。若变量 ${\displaystyle x}$ 某次出现在 ${\displaystyle \forall x}$ 的范围内，称这样出现的 ${\displaystyle x}$ 为不自由&#x2F;被约束的 ${\displaystyle x}$ (not free&#x2F;bounded)；反过来说，不出现在 ${\displaystyle \forall x}$ 的范围内的某个 ${\displaystyle x}$ 被称为自由的 ${\displaystyle x}$，（<code>∃</code>同理）</p><center><img loading="lazy" src="/posts/ed4b45dd/2.png" width="550"></center><ul><li>（封闭公式、句子）If no variable occurs free in a $wff x$, then $x$ is a sentence</li></ul><hr><ul><li>If α is an <strong>atomic formula</strong>, then <ul><li>x occurs free in α iff x occurs in α.</li><li>x occurs free in (¬α) iff x occurs free in α.</li><li>x occurs free in (α → β) iff x occurs free in α or in β.</li><li>x occurs free in ∀ $v_i$ α iff x occurs free in α and $x\neq{v_i}$</li></ul></li></ul><h3 id="ground-formula-基态公式"><a href="#ground-formula-基态公式" class="headerlink" title="ground formula 基态公式"></a>ground formula 基态公式</h3><ul><li>A <strong>ground term</strong> is a term which <strong>does not contain any variables</strong>.</li><li>A <strong>ground atomic formula</strong> is an atomic formula, all of whose terms are ground.</li><li>A <strong>ground literal</strong> is a ground atomic formula or the negation of one.</li><li>A <strong>ground formula</strong> is a <strong>quantifier-free</strong> formula, all of whose <strong>atomic formula are ground</strong>.</li><li>A is a ground instance of a quantifier-free formula A′ iff it can be obtained from A′ by substituting ground terms for the (free) variables in A′</li></ul><blockquote><p>The terms a, f(a,b), g(b,f(a,b)) are ground. p(f(a,b),a) is a ground atomic formula and ¬ p(f(a,b),a) is a ground literal. p(f(x,y),a) is not a ground atomic formula because of the variables x,y</p></blockquote><h2 id="Semantic-Interpretation"><a href="#Semantic-Interpretation" class="headerlink" title="Semantic: Interpretation"></a>Semantic: Interpretation</h2><ul><li>In propositional logic, the truth of a formula was determined by a truth assignment over the propositional symbols.</li><li>In first-order logic, we use a <strong>model</strong> (also called a <strong>structure</strong>) to determine the truth of a formula</li></ul><hr><ul><li>In propositional logic, an interpretation is a mapping from atomic propositions to truth values. </li><li>In first-order logic, the analogous concept is a mapping from atomic formulas to truth values.<ul><li>However, atomic formulas contain variables and constants that must be assigned elements of some domain; once that is done, the <strong>predicates</strong> are interpreted as <strong>relations</strong> over the domain.（比如大于小于关系）</li></ul></li></ul><center><img loading="lazy" src="/posts/ed4b45dd/4.png" width="550"></center><h3 id="assignment"><a href="#assignment" class="headerlink" title="assignment"></a>assignment</h3><center><img loading="lazy" src="/posts/ed4b45dd/5.jpg" width="550"></center><h3 id="Closed-Formula-闭公式"><a href="#Closed-Formula-闭公式" class="headerlink" title="Closed Formula 闭公式"></a>Closed Formula 闭公式</h3><p>Validity and Satisfiability</p><ul><li>Let A be a closed formula of first-order logic<ul><li>A is true in I or I is a <strong>model</strong> for A iff $v_I(A)&#x3D;T$ . Notation: I⊧A.</li><li>A is valid if for all interpretations I, I⊧A. Notation: ⊨A</li><li>A is satisfiable if for some interpretation I, I⊧A.</li><li>A is unsatisfiable if it is not satisfiable.</li><li>A is falsifiable if it is not valid</li></ul></li></ul><p>$∀x∀y(p(x,y)→p(y,x))$</p><ul><li>The formula is satisfiable in an interpretation where p is assigned a symmetric relation like &#x3D;. It is not valid because the formula is falsified in an interpretation that assigns to p a non-symmetric relation like &lt;</li></ul><h3 id="An-Interpretation-for-a-Set-of-Formulas"><a href="#An-Interpretation-for-a-Set-of-Formulas" class="headerlink" title="An Interpretation for a Set of Formulas"></a>An Interpretation for a Set of Formulas</h3><blockquote><p>In propositional logic, the concept of interpretation and the definition of properties such as satisfiability can be extended to sets of formulas. The same holds for first-order logic</p></blockquote><ul><li>Let U&#x3D;{A 1,…} be a set of formulas where {p 1,…,p m } are all the predicates appearing in all A i ∈S and {a 1,…,a k } are all the constants appearing in all A i ∈S. An interpretation $I_v$ for S is as triple:<ul><li>${D,{R_1,…R_n},{d_1,…d_n}}$</li></ul></li><li>where D is a non-empty set called the domain, R i is an $n_i$-ary relation on D that is assigned to the $n_i$-ary predicate p i and d i ∈D is an element of D that is assigned to the constant a i</li></ul><h2 id="Logical-Equivalence"><a href="#Logical-Equivalence" class="headerlink" title="Logical Equivalence"></a>Logical Equivalence</h2><ul><li>Let U&#x3D;{A 1,A 2} be a pair of <strong>closed formulas</strong>. A 1 is logically equivalent to A 2 iff $v_{I_{U}}(A_1)&#x3D;v_{I_{U}}(A_2)$ for all interpretations . Notation: $A_1≡A_2$</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/6.jpg" width="550"></center><p>公式</p><center><img loading="lazy" src="/posts/ed4b45dd/7.jpg" width="550"></center><center><img loading="lazy" src="/posts/ed4b45dd/8.jpg" width="550"></center><h2 id="语义表"><a href="#语义表" class="headerlink" title="语义表"></a>语义表</h2><blockquote><p>语义表的方法对于显示一个公式是不可满足的来说是合理和完整的，但是它不是一个可满足性的决定程序，因为表的分支可能是无限的。当一个tableau被构造出来时，一个普遍量词后面跟着一个存在量词可能会导致一个无限的分支：存在公式被用一个新的常数实例化，然后普遍公式的实例化会导致一个新的存在量词公式的出现，如此无限地下去。有一些公式只在无限域中是可满足的。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/40419871/answer/127792613">命题逻辑和一阶逻辑分别是什么？ - 嘉嘉杨的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/22915503/answer/151477106">一阶逻辑和高阶逻辑的区别，能不能具象一点说明？ - ZS Chen的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/28776730/answer/702538400">集合论和一阶逻辑的关系是什么？ - Zangwei Zheng的回答 - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;命题逻辑对于算术等数学理论的形式化来说，表现力并不充分。一个算术表达式，如$x+2&amp;gt;y-1$，既不是真的，也不是假的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的真假取决于变量x和y的值&lt;/li&gt;
&lt;li&gt;我们需要将运算符+和-的含义形式化，作为将一对数字映射为一个数字的函数&lt;/li&gt;
&lt;li&gt;像&amp;gt;这样的关系运算符必须被形式化为将一对数字映射为真值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;命题逻辑vs一阶逻辑&quot;&gt;&lt;a href=&quot;#命题逻辑vs一阶逻辑&quot; class=&quot;headerlink&quot; title=&quot;命题逻辑vs一阶逻辑&quot;&gt;&lt;/a&gt;命题逻辑vs一阶逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命题逻辑（Propositional Logic） &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形如 ¬P，P∧Q，P∨Q，P → Q ，P↔Q的语句，值为True或者False&lt;/li&gt;
&lt;li&gt;推理规则较简单，往往通过（1.真值表  2.为数不多的推理规则，例如Modus ponesn等几个）&lt;/li&gt;
&lt;li&gt;缺点：不能或者很难表示复杂的语句，不能记录推理过程中的变化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一阶逻辑（First Order Logic），简称FOL&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含的东西有常量（Constant symbol），谓词符号（Predicate symbol），函数符号（Function symbol），变量（Variable），连词（ ∧∨→↔），量词（Quantifiers, ∃∀）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命题逻辑(很少部分人叫它作零阶逻辑). 在命题逻辑里, 每一个字母就代表一个命题, 所以命题逻辑只能表达句子之间的关系, 比如“p&amp;amp;q”, “if p then q”等等的真值如何从p和q的真值中计算出来.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一阶逻辑则引入了两个量词, 即universal quantifier(倒A)和existential quantifier(倒E), 并且加入了一阶谓词和individual variables和individual constants. 这些导致一阶逻辑可以量化individuals in the domain.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比如经典的三段论就可以被一阶逻辑表达 &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For all x, Hx-&amp;gt;Mx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ms&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory&quot;&gt;&lt;a href=&quot;#vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory&quot; class=&quot;headerlink&quot; title=&quot;vs Propositional Logic vs Set Theory vs Elementary Number Theory&quot;&gt;&lt;/a&gt;vs Propositional Logic vs Set Theory vs Elementary Number Theory&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Propositional Logic&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Equality: no&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Predicate symbols: A1, A2, . . .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constant symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Set Theory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Equality: yes&lt;/li&gt;
&lt;li&gt;Predicate symbols: ∈&lt;/li&gt;
&lt;li&gt;Constant symbols: ∅&lt;/li&gt;
&lt;li&gt;Function symbols: none&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-命题逻辑-SAT</title>
    <link href="https://hejueyun.github.io/posts/f363d9fd/"/>
    <id>https://hejueyun.github.io/posts/f363d9fd/</id>
    <published>2022-02-15T17:31:21.000Z</published>
    <updated>2022-02-18T15:53:43.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SAT-布尔可满足性问题"><a href="#SAT-布尔可满足性问题" class="headerlink" title="SAT 布尔可满足性问题"></a>SAT 布尔可满足性问题</h2><blockquote><p>可满足性（英语：Satisfiability）是用来解决给定的真值方程式，是否存在一组变量赋值，使问题为可满足。布尔可满足性问题（Boolean satisfiability problem；SAT ）属于<strong>决定性问题</strong>，也是第一个被证明属于<strong>NP完全</strong>的问题</p><p>决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题</p></blockquote><h2 id="Properties-of-Clausal-Form"><a href="#Properties-of-Clausal-Form" class="headerlink" title="Properties of Clausal Form"></a>Properties of Clausal Form</h2><blockquote><p>A computer program that searches for a model for a propositional formula is called a SAT Solver. </p></blockquote><blockquote><p>Let S, S′ be sets of clauses. </p><ul><li>S≈S′ denotes that S is satisfiable if and only if S′ is satisfiable. </li><li>It is important to understand that S≈S′ does not imply that S≡S′ (S is <strong>logically equivalent</strong> to S′)</li></ul></blockquote><center><img loading="lazy" src="/posts/f363d9fd/1.jpg" width="550"></center><h3 id="Pure-Literals"><a href="#Pure-Literals" class="headerlink" title="Pure Literals"></a>Pure Literals</h3><blockquote><p>Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S</p><p>Let S be a set of clauses and let l be a pure literal in S. Let S′ be obtained from S by deleting every clause containing l. Then S≈S′</p><ul><li>也就是删除纯文字不影响及健全性的传递</li></ul></blockquote><h3 id="Unit-Clauses"><a href="#Unit-Clauses" class="headerlink" title="Unit Clauses"></a>Unit Clauses</h3><blockquote><p>Let {l}∈S be a unit clause and let S′ be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then S≈S′.</p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/2.jpg" width="550"></center><h3 id="Empte-Clauses"><a href="#Empte-Clauses" class="headerlink" title="Empte Clauses"></a>Empte Clauses</h3><ul><li>□ is unsatisfiable<ul><li>根据Unit Clauses的定理显然</li></ul></li></ul><h3 id="Renaming"><a href="#Renaming" class="headerlink" title="Renaming"></a>Renaming</h3><blockquote><p>Let $S$ be a set of clauses and $U$ a set of atomic propositions. $R_U(S)$, the renaming of S by U, is obtained from S by replacing each literal l on an atomic proposition in U by $l^c$ </p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/3.jpg" width="550"></center><h2 id="Davis-Putnam-Algorithm-戴维斯–普特南算法"><a href="#Davis-Putnam-Algorithm-戴维斯–普特南算法" class="headerlink" title="Davis-Putnam Algorithm 戴维斯–普特南算法"></a>Davis-Putnam Algorithm 戴维斯–普特南算法</h2><blockquote><p>The Davis-Putnam (DP) algorithm was one of the first algorithms proposed for deciding satisfiability</p><p>戴维斯-普特南（DP）算法是最早提出的用于<strong>决定可满足性</strong>的算法之一</p></blockquote><ul><li><p>Input: A formula A in clausal form.</p></li><li><p>Output: Report that A is satisfiable or unsatisfiable.</p></li><li><p>Perform the following rules <strong>repeatedly</strong>, but the third rule is used only if the first two do not apply</p><ul><li>Unit-literal rule <blockquote><p>If there is a unit clause {l}, delete <strong>all clauses</strong> containing l and delete <strong>all occurrences</strong> of $l^c$ from <strong>all other clauses</strong></p></blockquote></li><li>Pure-literal rule<blockquote><p>If there is a pure literal l, delete all clauses containing l</p></blockquote></li><li>Eliminate a variable by resolution:<blockquote><p>Choose an atom p and perform all possible resolutions on clauses that clash on $p$ and $\bar{p}$. Add these <strong>resolvents</strong>解析器 to the set of clauses and then delete all clauses containing $p$ or $\bar{p}$</p></blockquote></li></ul></li><li><p>Terminate the algorithm under the following conditions:</p><ul><li>If empty clause <code>□</code> is produced, report that the formula is unsatisfiable.</li><li>If no more rules are applicable适用, report that the formula is satisfiable.</li></ul></li></ul><p><strong>Example</strong></p><ul><li>${p, \bar{p}q, \bar{q}r, \bar{r}st}$<blockquote><p>Performing the unit-literal rule on p leads to the creation of a new unit clause q upon which the rule can be applied again. This leads to a new unit clause r and applying the rule results in the singleton set of clauses {st}. Since no more rules are applicable, the set of clauses is satisfiable.</p></blockquote></li></ul><hr><blockquote><p>Repeatedly applying the unit-literal rule until it is no longer applicable is called <strong>unit propagation</strong> or <strong>Boolean constraint propagation（BCP）</strong>. 单位传播或布尔约束传播</p></blockquote><h2 id="Davis-Putnam-Logemann-Loveland-DPLL"><a href="#Davis-Putnam-Logemann-Loveland-DPLL" class="headerlink" title="Davis-Putnam-Logemann-Loveland(DPLL)"></a>Davis-Putnam-Logemann-Loveland(DPLL)</h2><p>解决 CNF-SAT 问题</p><blockquote><p>一个朴素的回溯算法会检查所有可能的赋值，直到找到一个解；而 DPLL 算法 则会利用 BCP 来删掉一些不可能满足公式的赋值，缩小搜索树。当遇到冲突时，它会回溯到上一个并非由 BCP 作出的决定，选择另一种可能的值</p><hr><p>Creating all possible resolvents on an atom is very inefficient. The DPLL algorithm improves on the DP algorithm by replacing the variable elimination step with a search for a model of the formula</p><p>The DPLL algorithm recursively <strong>extends a partial interpretation</strong> by <strong>adding an assignment to some atom</strong> that has not yet been assigned a truth value. The current set of clauses is evaluated using the new partial interpretation and simplified by <strong>unit propagation</strong>. If the set of clauses contains a conflict clause, there is no need to continue extending this partial interpretation and the search <strong>backtracks</strong>递归回溯 to try another one</p></blockquote><p>The DPLL algorithm can be summarized in the following pseudocode, where $Φ$ is the <strong>CNF</strong> formula: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Algorithm DPLL</span><br><span class="line">    Input: A set of clauses Φ.</span><br><span class="line">    Output: A truth value indicating whether Φ is satisfiable.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function DPLL(Φ)</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a unit clause &#123;l&#125; <span class="keyword">in</span> Φ do</span><br><span class="line">        Φ ← unit-propagate(l, Φ);</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a literal l that occurs pure <span class="keyword">in</span> Φ do</span><br><span class="line">        Φ ← pure-literal-assign(l, Φ);</span><br><span class="line">    <span class="keyword">if</span> Φ <span class="keyword">is</span> empty then</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">if</span> Φ contains an empty clause then</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    l ← choose-literal(Φ);</span><br><span class="line">    <span class="keyword">return</span> DPLL(Φ ∧ &#123;l&#125;) <span class="keyword">or</span> DPLL(Φ ∧ &#123;<span class="keyword">not</span>(l)&#125;);</span><br></pre></td></tr></table></figure><ul><li>“←” denotes assignment. For instance, “largest ← item” means that the value of largest changes to the value of item.</li><li>When the formula contains an empty clause, the clause is vacuously false because a disjunction requires at least one member that is true for the overall set to be true</li></ul><hr><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/f363d9fd/4.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/6.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/5.jpg" width="650"></center><p><strong>简化版表达</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DPLL:</span><br><span class="line">  Run BCP on the formula.</span><br><span class="line">  If the formula evaluates to <span class="literal">True</span>, <span class="keyword">return</span> <span class="literal">True</span>.</span><br><span class="line">  If the formula evaluates to <span class="literal">False</span>, <span class="keyword">return</span> <span class="literal">False</span>.</span><br><span class="line">  If the formula <span class="keyword">is</span> still Undecided:</span><br><span class="line">    Choose the <span class="built_in">next</span> unassigned variable.</span><br><span class="line">    Return (DPLL <span class="keyword">with</span> that variable <span class="literal">True</span>) || (DPLL <span class="keyword">with</span> that variable <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">DPLL:</span><br><span class="line">  在公式上执行 BCP。</span><br><span class="line">  如果公式的值一定为真，返回真。</span><br><span class="line">  如果公式的值一定为假，返回假。</span><br><span class="line">  如果公式的值仍不确定:</span><br><span class="line">    选择下一个未决定的字面量</span><br><span class="line">    猜测该字面量为真，然后执行 DPLL</span><br><span class="line">    如果 DPLL 的结果为真，返回真</span><br><span class="line">    否则猜测该字面量为假，然后执行 DPLL 并返回结果</span><br></pre></td></tr></table></figure><ul><li>某种程度上看，DDLP &#x3D; Unit Propagation + Decision</li></ul><h2 id="Conflict-Driven-Clause-Learning-CDCL"><a href="#Conflict-Driven-Clause-Learning-CDCL" class="headerlink" title="Conflict Driven Clause Learning(CDCL)"></a>Conflict Driven Clause Learning(CDCL)</h2><blockquote><p>DPLL 有三个缺点。首先，它的决策是朴素（naive）的。其次，它遇到冲突的时候，只知道当前的部分赋值会导致冲突，除此之外学不到任何东西。第三，它每次只会回溯一层，因此会把大量时间浪费在一片必定会失败的搜索空间中</p></blockquote><p><strong>冲突驱动子句学习</strong>的改进：</p><ul><li>冲突来源的子句学习（clause learning from conflicts）</li><li>非时序回溯（non-chronological<code>[ ˌ krɔnə&#39;lɔdʒikəl ]</code> backtracking）</li></ul><center><img loading="lazy" src="/posts/f363d9fd/7.jpg" width="650"></center><ul><li>当CDCL学习一个子句时，它会回溯到该子句的断言层。你可以认为这意味着它回溯到影响所学子句中某一字面量的最新猜测。由于这个子句有$x_1$和$x_5$，而x1是该子句中最新被猜到的一个，所以我们回溯到我们将$x_1$设置为True的时候</li></ul><center><img loading="lazy" src="/posts/f363d9fd/8.jpg" width="650"></center><h3 id="蕴含图"><a href="#蕴含图" class="headerlink" title="蕴含图"></a>蕴含图</h3><ul><li>当 CDCL 遇到冲突时，它会查看已作出的推测，以及从 BCP 得到且最终导致冲突的那些赋值。我们把这些推测和由它们推出的结论画成一个图（graph），称为蕴涵图（implication graph）</li></ul><blockquote><p>蕴含图是一个有向无环图。它的每个顶点代表对一个变量的赋值，此外还有一个代表冲突的特殊顶点。图中的边则表示赋值或冲突的理由；具体来说，如果我们有一个单位子句，并由此推出子句中唯一的那个未知变量的值，就可以从子句中每一个已知的变量对应的顶点连一条边到这个新推导出的变量对应的顶点；推出冲突的情形也类似</p></blockquote><ul><li>一旦 CDCL 学到了一个子句，它就能够回溯超过一层，并把 BCP 立即应用到学到的新子句上。这种利用学到的子句回溯多层的能力就是我们前面说的非时间顺序回溯（non-chronological backtracking）</li></ul><center><img loading="lazy" src="/posts/f363d9fd/9.jpg" width="650"></center><p><strong>clause learning step</strong>:</p><ol><li>c4 is the clause directly responsible for the current conflict. Our partial learned clause is ¬x1 ∨ ¬x6 ∨ ¬x7. </li><li>c3 is the clause responsible for the most recent BCP prior to the conflict, x7 &#x3D; T. Resolving c3 and c4 gives us the partial clause of ¬x1 ∨ ¬x5 ∨ ¬x6. </li><li>c2 is the clause responsible for the next most recent BCP, x6 &#x3D; T. Resolving c2 with our current partial clause gives us ¬x1 ∨ ¬x5.<ol><li>This is our complete learned clause, because there is only one literal at decision level two within it.</li><li>Since x1 has the highest decision level in our new learned clause, we backtrack to that level where we will be able to apply our newly learned clause, c9 &#x3D; ¬x1 ∨ ¬x5</li></ol></li></ol><h3 id="A-note-about-Decision-Heuristics"><a href="#A-note-about-Decision-Heuristics" class="headerlink" title="A note about Decision Heuristics"></a>A note about Decision Heuristics</h3><blockquote><p>The version of CDCL we implemented in this article does not have any smart <strong>decision heuristics</strong>启发式决策. Better decision heuristics is often the source of breakthroughs SAT Solver performance increases and are very important to modern SAT solvers today. We only examined clause learning and non-chronological backtracking as improvements over DPLL to keep the scope of this project small.</p><p>我们在这篇文章中实现的CDCL版本没有任何智能决策启发式方法。更好的决策启发式往往是SAT求解器性能提高的突破口，对今天的现代SAT求解器非常重要。我们只研究了子句学习和非同步回溯作为对DPLL的改进，以保持这个项目的范围很小。</p></blockquote><h3 id="pseudocode"><a href="#pseudocode" class="headerlink" title="pseudocode"></a>pseudocode</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CDCL</span>(<span class="params">ϕ</span>):</span>     // ϕ <span class="keyword">is</span> a CNF formula</span><br><span class="line">   τ←∅</span><br><span class="line">   <span class="keyword">while</span> true:</span><br><span class="line">      τ←unit-propagate(ϕ,τ) // Unit propagation</span><br><span class="line">      <span class="keyword">if</span> τ falsifies a clause:</span><br><span class="line">         <span class="keyword">if</span> at decision level <span class="number">0</span>: <span class="keyword">return</span> unsat</span><br><span class="line">         C←analyze-conflict(ϕ,τ) // Build the learned clause</span><br><span class="line">         ϕ←ϕ∧C // Add it to the formula</span><br><span class="line">         backjump to an earlier decision level according to C</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">all</span> variables have values: <span class="keyword">return</span> sat</span><br><span class="line">         start a new decision level</span><br><span class="line">         choose a literal l such that τ(l) <span class="keyword">is</span> undefined</span><br><span class="line">         τ←τ∪&#123;l&#125; // <span class="string">&quot;Decide&quot;</span> that l <span class="keyword">is</span> true</span><br></pre></td></tr></table></figure><h2 id="Complexity-复杂度"><a href="#Complexity-复杂度" class="headerlink" title="Complexity 复杂度"></a>Complexity 复杂度</h2><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><ul><li>多项式时间复杂性类（Polynomial<code>[ˌpɔli&#39;nəumjəl]</code> time）</li><li>所有P问题都能被经典计算机（非量子计算机）轻松解决</li><li>如果一个问题是P问题，那么它必须满足在多项式时间nc内验证一个算法问题的实例是否<code>有解</code>，<ul><li>n是输入长度</li><li>c是个常数</li></ul></li><li>典型问题：<ul><li>这个数是否是个质数？</li><li>两点之间的最短路径是什么？</li></ul></li></ul><h3 id="np"><a href="#np" class="headerlink" title="np"></a>np</h3><ul><li>非定常多项式时间复杂性类（Nondeterministic Polynomial time）</li><li>能在多项式时间验证答案<code>正确与否</code>的问题</li><li>算起来不一定快，但对于任何答案我们都可以快速的<strong>验证</strong>这个答案对不对</li></ul><blockquote><p>The method of <strong>truth tables</strong> is a <strong>deterministic</strong> algorithm for deciding both satisfiability and validity in propositional logic. The algorithm is <strong>exponential</strong>, because the size of a formula is polynomial in $n$, the number of variables, while the truth table has $2^n$ rows.</p><p>The method of <strong>semantic tableaux</strong> is a <strong>nondeterministic</strong> algorithm for both satisfiability and validity, because at any stage of the construction, we can choose a leaf to expand and choose a formula in the label of the leaf to which a rule will be applied. Nevertheless, it can be shown that there are families of formulas for which the method of semantic tableaux is <strong>exponential, as are the David-Putnam procedure and resolution</strong></p><p>The problems of deciding <strong>satisfiability</strong> and <strong>validity</strong> in propositional logic are almost certainly intractable: the former is in <strong>np</strong> and the latter in <strong>co-np</strong></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cse442-17f.github.io/Conflict-Driven-Clause-Learning/">Conflict Driven Clause Learning</a></li><li><a href="https://zhuanlan.zhihu.com/p/92659252">【试译】冲突驱动子句学习(Conflict Driven Clause Learning) - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SAT-布尔可满足性问题&quot;&gt;&lt;a href=&quot;#SAT-布尔可满足性问题&quot; class=&quot;headerlink&quot; title=&quot;SAT 布尔可满足性问题&quot;&gt;&lt;/a&gt;SAT 布尔可满足性问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可满足性（英语：Satisfiability）是用来解决给定的真值方程式，是否存在一组变量赋值，使问题为可满足。布尔可满足性问题（Boolean satisfiability problem；SAT ）属于&lt;strong&gt;决定性问题&lt;/strong&gt;，也是第一个被证明属于&lt;strong&gt;NP完全&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Properties-of-Clausal-Form&quot;&gt;&lt;a href=&quot;#Properties-of-Clausal-Form&quot; class=&quot;headerlink&quot; title=&quot;Properties of Clausal Form&quot;&gt;&lt;/a&gt;Properties of Clausal Form&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A computer program that searches for a model for a propositional formula is called a SAT Solver. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Let S, S′ be sets of clauses. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S≈S′ denotes that S is satisfiable if and only if S′ is satisfiable. &lt;/li&gt;
&lt;li&gt;It is important to understand that S≈S′ does not imply that S≡S′ (S is &lt;strong&gt;logically equivalent&lt;/strong&gt; to S′)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f363d9fd/1.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;


&lt;h3 id=&quot;Pure-Literals&quot;&gt;&lt;a href=&quot;#Pure-Literals&quot; class=&quot;headerlink&quot; title=&quot;Pure Literals&quot;&gt;&lt;/a&gt;Pure Literals&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S&lt;/p&gt;
&lt;p&gt;Let S be a set of clauses and let l be a pure literal in S. Let S′ be obtained from S by deleting every clause containing l. Then S≈S′&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也就是删除纯文字不影响及健全性的传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Unit-Clauses&quot;&gt;&lt;a href=&quot;#Unit-Clauses&quot; class=&quot;headerlink&quot; title=&quot;Unit Clauses&quot;&gt;&lt;/a&gt;Unit Clauses&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let {l}∈S be a unit clause and let S′ be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then S≈S′.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-一阶逻辑-序</title>
    <link href="https://hejueyun.github.io/posts/c666161e/"/>
    <id>https://hejueyun.github.io/posts/c666161e/</id>
    <published>2022-02-13T21:39:34.000Z</published>
    <updated>2022-02-15T17:55:12.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Orderings-序"><a href="#Orderings-序" class="headerlink" title="Orderings 序"></a>Orderings 序</h2><p><strong>序是一个关系</strong></p><blockquote><p>A (<strong>strict</strong>) ordering on a set X is a transitive and irreflexive <strong>binary relation</strong> on X, here denoted by <code>≻</code>  （只有严格有序集是要求非自反，即无相等元素的？毕竟相等的话就是multi-set了，并且这个符号也不是$\geq$）</p><ul><li>The pair<code> (X, ≻)</code> is then called <strong>a (strictly) ordered set</strong>有序集 (感觉有点类似群，只不过群是在集合的基础上定义加乘法，而有序集是在集合的基础上定义了序)</li></ul><p>An element x of X is <strong>minimal</strong> wrt.(with regard to) ≻, if there is no y in X such that <code>x ≻ y</code></p><ul><li>A <strong>minimal</strong> element x in X is called the <strong>smallest</strong> (or strictly minimal) element, if for all y ∈ X different from x, y ≻ x.</li><li>Maximal and largest (or strictly maximal) elements are defined analogously(类似的)</li></ul><hr><ul><li>$≺$ for the inverse relation $≻^{−1}$</li><li>x ⪰ y iff either x ≻ y or x &#x3D; y</li></ul></blockquote><ul><li>In a total ordering if an element is minimal then it is the smallest element.</li><li>In any ordering, the smallest element is unique, if exists</li></ul><h3 id="Strict-partial-order-严格偏序"><a href="#Strict-partial-order-严格偏序" class="headerlink" title="Strict partial order 严格偏序"></a>Strict partial order 严格偏序</h3><ol><li>Irreflexivity: </li><li>Transitivity</li><li>Asymmetry</li></ol><h4 id="Total-order-全序关系"><a href="#Total-order-全序关系" class="headerlink" title="Total order 全序关系"></a>Total order 全序关系</h4><ul><li>也称linear order线性关系</li></ul><center><img loading="lazy" src="/posts/c666161e/2.jpg" width="550"></center><ul><li>A <strong>strict</strong> total order 则会将reflexive变为irreflexive.</li></ul><h3 id="Well-founded-relation-良基关系"><a href="#Well-founded-relation-良基关系" class="headerlink" title="Well-founded relation  良基关系"></a>Well-founded relation  良基关系</h3><blockquote><p>A (strict) ordering ≻ over X is called well-founded (or Noetherian or terminating), if there is no infinite decreasing chain x0 ≻ x1 ≻ x2 ≻ . . . of elements xi ∈ X.</p><p><strong><code>(X, ≻)</code> is well-founded iff every non-empty subset Y of X has a minimal element</strong>.</p></blockquote><ul><li>在数学中，类 X 上的一个二元关系 R 被称为是良基的，当且仅当所有 X 的非空子集都有一个 R-极小（注意前提是<strong>有限</strong>有序集）</li></ul><h3 id="Noetherian-Induction-归纳"><a href="#Noetherian-Induction-归纳" class="headerlink" title="Noetherian Induction 归纳"></a>Noetherian Induction 归纳</h3><p>Let (X, ≻) be a well-founded ordering, let Q be a property of elements of X.</p><ul><li><strong>If</strong><ul><li>for all x ∈ X the following implication is satisfied<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if Q(y) holds, for all y ∈ X such that x ≻ y,</span><br><span class="line">then Q(x) holds.</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>Then</strong><ul><li>the property Q(x) holds for all x ∈ X</li><li><em>相当于satisfy证valid？</em></li></ul></li></ul><p>Proof：By contradiction反证法</p><blockquote><p>By contradiction.</p><p>Thus, suppose for all x ∈ X the implication above is satisfied, but Q(x) does not hold for all x ∈ X.</p><p>Let A &#x3D; {x ∈ X | Q(x) is false}. Suppose A ̸&#x3D; ∅.</p><p>Since (X, ≻) is well-founded, A has a minimal element x1. Hence for all y ∈ X with x1 ≻ y the property Q(y) holds.</p><p>On the other hand, the implication which is presupposed for this theorem holds in particular also for x1, hence Q(x1) must be true so that x1 cannot belong to A. Contradiction.</p></blockquote><h3 id="Multi-Set-Orderings"><a href="#Multi-Set-Orderings" class="headerlink" title="Multi-Set Orderings"></a>Multi-Set Orderings</h3><p>Let (X, ≻) be an ordering. The multi-set extension $≻_{mul}$ of ≻ to (<strong>finite</strong>) multi-sets over X is defined by</p><ul><li>$S1 ≻_{mul} S2$ ⇐⇒ S1 ̸&#x3D; S2 and ∀x ∈ S2\S1. ∃y ∈ S1\S2. y ≻ x</li></ul><ol><li>Remove common occurrences of elements from S1 and S2. Assume this gives S′&#x3D; S′</li></ol><p>2.Then check that for every element x in S′there is an element y ∈ S′ that is greater than x. Then S1 $≻_mul$ S2.</p><center><img loading="lazy" src="/posts/c666161e/1.jpg" width="550"></center><hr><p>Ordering with one minimal element, but without the smallest element:</p><ul><li>${(0,y)\in {\Bbb{R}}^2: 0&lt;y&lt;1} \cup{} {(1,y)\in {\Bbb{R}}^2: 0\leq y&lt;1}$<ul><li>$(1,0)$ is the one and only one minimal element but not a smallest element</li><li>because it is not related to the elements with $x&#x3D;0$</li></ul></li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h2 id="Lexicographic-Combination"><a href="#Lexicographic-Combination" class="headerlink" title="Lexicographic Combination"></a>Lexicographic Combination</h2><p>Let (X1, $≻<em>1$), (X2, $≻_2$) be two <strong>orderings</strong>. Lexicographic combination of (X1, ≻1), (X2, ≻2) is an ordering: $≻</em>{lex}&#x3D; ($≻_1$, $≻_2$)lex$ on X1 × X2 such that</p><ul><li>(x1, x2) ≻lex (y1, y2) iff <ul><li>x1 $≻_1$ y1</li><li><strong>or else</strong> x1 &#x3D; y1 and x2 $≻_2$ y2</li></ul></li></ul><h3 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h3><p>Let (X1, $≻_1$), (X2, $≻_2$)) be two orderings. Then</p><ol><li>$≻_lex$ is an ordering.</li><li>if both $≻_1$ and $≻_2$ <strong>well-founded</strong> then $≻_lex$ well-founded.</li><li>if both $≻<em>1$ and $≻_2$ <strong>total</strong> then $≻</em>{lex}$ total.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Orderings-序&quot;&gt;&lt;a href=&quot;#Orderings-序&quot; class=&quot;headerlink&quot; title=&quot;Orderings 序&quot;&gt;&lt;/a&gt;Orderings 序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;序是一个关系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A (&lt;strong&gt;strict&lt;/strong&gt;) ordering on a set X is a transitive and irreflexive &lt;strong&gt;binary relation&lt;/strong&gt; on X, here denoted by &lt;code&gt;≻&lt;/code&gt;  （只有严格有序集是要求非自反，即无相等元素的？毕竟相等的话就是multi-set了，并且这个符号也不是$\geq$）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The pair&lt;code&gt; (X, ≻)&lt;/code&gt; is then called &lt;strong&gt;a (strictly) ordered set&lt;/strong&gt;有序集 (感觉有点类似群，只不过群是在集合的基础上定义加乘法，而有序集是在集合的基础上定义了序)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An element x of X is &lt;strong&gt;minimal&lt;/strong&gt; wrt.(with regard to) ≻, if there is no y in X such that &lt;code&gt;x ≻ y&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;minimal&lt;/strong&gt; element x in X is called the &lt;strong&gt;smallest&lt;/strong&gt; (or strictly minimal) element, if for all y ∈ X different from x, y ≻ x.&lt;/li&gt;
&lt;li&gt;Maximal and largest (or strictly maximal) elements are defined analogously(类似的)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;$≺$ for the inverse relation $≻^{−1}$&lt;/li&gt;
&lt;li&gt;x ⪰ y iff either x ≻ y or x &amp;#x3D; y&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In a total ordering if an element is minimal then it is the smallest element.&lt;/li&gt;
&lt;li&gt;In any ordering, the smallest element is unique, if exists&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Strict-partial-order-严格偏序&quot;&gt;&lt;a href=&quot;#Strict-partial-order-严格偏序&quot; class=&quot;headerlink&quot; title=&quot;Strict partial order 严格偏序&quot;&gt;&lt;/a&gt;Strict partial order 严格偏序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Irreflexivity: &lt;/li&gt;
&lt;li&gt;Transitivity&lt;/li&gt;
&lt;li&gt;Asymmetry&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Total-order-全序关系&quot;&gt;&lt;a href=&quot;#Total-order-全序关系&quot; class=&quot;headerlink&quot; title=&quot;Total order 全序关系&quot;&gt;&lt;/a&gt;Total order 全序关系&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;也称linear order线性关系&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c666161e/2.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;strict&lt;/strong&gt; total order 则会将reflexive变为irreflexive.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-集合论</title>
    <link href="https://hejueyun.github.io/posts/301925f/"/>
    <id>https://hejueyun.github.io/posts/301925f/</id>
    <published>2022-02-10T23:11:11.000Z</published>
    <updated>2022-02-16T12:11:27.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets 集合"></a>Sets 集合</h2><ul><li>A set is composed of elements . a ∈ S denotes that a is an element of set S</li><li>The set with no elements is the empty set , denoted ∅.</li></ul><h3 id="Multi-Sets-多重集"><a href="#Multi-Sets-多重集" class="headerlink" title="Multi-Sets 多重集"></a>Multi-Sets 多重集</h3><ul><li>sets which allow repetition</li><li>$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S<ul><li>S &#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then <code>S(a) = 3, S(b) = 2, S(c) = 0</code></li><li>denoted: $S: A\rightarrow{Z^{+}}$，A is the underlying set of the multiset</li></ul></li><li>multi-set S over X is called <strong>finite</strong>, if <code>&#123; x ∈ X | S(x) &gt; 0&#125;| &lt; ∞</code>.</li></ul><center><img loading="lazy" src="/posts/301925f/5.png" width="550px"></center><h2 id="Set-Operators-集合操作符"><a href="#Set-Operators-集合操作符" class="headerlink" title="Set Operators 集合操作符"></a>Set Operators 集合操作符</h2><ul><li>Let S and T be sets. S is a subset of T , denoted S ⊆ T , iff every element of S is an element of T , that is, x ∈ S → x ∈ T . S is a proper subset of T , denoted S ⊂ T , iff S ⊆ T and S ≠ T</li><li><strong>Union</strong>联合<ul><li>S <code>∪</code> T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).</li></ul></li><li><strong>Intersection</strong>交集<ul><li>S <code>∩</code> T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S ∩ T &#x3D;∅ then S and T are disjoint .</li></ul></li><li><strong>Difference</strong>差集<ul><li>S <code>−</code> T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$</li></ul></li><li><strong>complement</strong> 补集<ul><li>Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S − T</li></ul></li><li><strong>Cartesian product</strong>笛卡尔积<ul><li>Let S and T be sets. S <code>×</code> T , their Cartesian product , is the set of all pairs ( s , t ) such that s ∈ S and t ∈ T</li></ul></li></ul><center><img loading="lazy" src="/posts/301925f/4.gif" width="550px"></center><h2 id="Sequences-序列"><a href="#Sequences-序列" class="headerlink" title="Sequences 序列"></a>Sequences 序列</h2><p>Let $S$ be a set.</p><ul><li>A finite sequence $f$ on $S$ is a function from {0,…, n −1} to $$ . The length of the sequence is n .</li><li>An infinite sequence $f$ on $S$ is a mapping from $N$ to $S$</li></ul><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h3><ul><li>A finite sequence of length n is an n-tuple</li></ul><h2 id="Relations-and-Functions-关系与函数"><a href="#Relations-and-Functions-关系与函数" class="headerlink" title="Relations and Functions 关系与函数"></a>Relations and Functions 关系与函数</h2><blockquote><p>a relation is a subset of a Cartesian product of sets and a function is a relation with a special property</p><p>关系是集合的笛卡尔积的一个子集，函数是具有特殊属性的关系。</p></blockquote><h3 id="n-ary-relation-n元关系"><a href="#n-ary-relation-n元关系" class="headerlink" title="n-ary relation n元关系"></a>n-ary relation n元关系</h3><center><img loading="lazy" src="/posts/301925f/6.png" width="550px"></center><h3 id="Properties-of-Relations-关系的属性"><a href="#Properties-of-Relations-关系的属性" class="headerlink" title="Properties of Relations 关系的属性"></a>Properties of Relations 关系的属性</h3><p>Let R be a binary relation on $S^2$ . (Notation: R(x,y) &lt;&#x3D;&gt;  yRx)</p><ul><li>R is reflexive自反 iff R ( x , x ) for all x ∈ S .</li><li>R is symmetric对称 iff R ( $x_1 , x_2$ ) implies R ( $x_1 , x_2$ ).</li><li>Antisymmetric 反对称<ul><li>若对所有的 a 和 b 属于 X，下述语句保持有效，则集合 X 上的二元关系 R 是反对称的：“若 a 关系到 b 且 b 关系到 a，则 a &#x3D; b。” <blockquote><p>注意，<strong>反对称关系不是对称关系（aRb 得到 bRa）的反义</strong>。有些关系既是对称的又是反对称的，比如”等于”（证明：a&#x3D;b推出b&#x3D;a；a&#x3D;b且b&#x3D;a推出a&#x3D;b）；有些关系既不是对称的也不是反对称的，比如”爱上……”（证明：a爱b不能推出b爱a；a爱b且b爱a不能推出a和b是同一个人）</p></blockquote></li></ul></li><li>R is transitive传递 iff R ($x_1 , x_2$ ) and R ( $x_2 , x_3$ ) imply R ( $x_1 , x_3$ ).</li></ul><p>$R^{∗}$ , the <strong>reflexive transitive closure</strong>自反传递闭包 of $R$ , is defined as follows:</p><ul><li>If R ( $x_1 , x_2$ ) then $R^{∗}$ ( $x_1 , x_2$ ).<ul><li>$R\subseteq{R^{*}}$</li></ul></li><li>$R^{∗}$ ( x i , x i ) for all $x_i$ ∈ S .<ul><li>$R^{*}$ is symmetric</li></ul></li><li>$R^{∗}$ ( $x_1 , x_2$ ) and $R^{∗}$ ( $x_2 , x_3$ ) imply $R^{∗}$ ( $x_1 , x_3$ )<ul><li>$R^{*}$ is transitive</li></ul></li></ul><hr><p>Definition. A <strong>transition relation <code>⇒</code></strong> on set S is</p><ul><li><strong>terminating</strong>终止 if there is no infinite s1 ⇒ s2 ⇒ . . . ⇒ sn ⇒ . . ..</li><li><strong>compatible</strong> with an ordering ≻ on S if ⇒⊆≻.<blockquote><p>A transition relation ⇒ is terminating if and only if there is a well-founded ordering ≻ compatible with ⇒</p></blockquote></li></ul><hr><p>symmetric and reflexive but not transitive:</p><ul><li>$R&#x3D;{(a,a),(a,b),(b,a),(b,b),(c,c),(b,c),(c,b)}$<ul><li>满足aRa</li><li>满足aRb→bRa</li><li>不满足aRb,bRc-&gt;cRa</li></ul></li></ul><h3 id="Relation-of-multi-sets"><a href="#Relation-of-multi-sets" class="headerlink" title="Relation of multi-sets"></a>Relation of multi-sets</h3><p>A and B are multisets in a given universe U, with multiplicity functions $m_a$ and $m_b$</p><ul><li>A is included in B, denoted A ⊆ B, if ${\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.} {\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.}$<br>其余关系定义参考：</li><li>(S1 ∪ S2)(x) &#x3D; S1(x) + S2(x)</li><li>(S1 ∩ S2)(x) &#x3D; min{S1(x), S2(x)}</li><li>(S1\S2)(x) &#x3D; S1(x) − S2(x)</li></ul><h3 id="Functions-函数"><a href="#Functions-函数" class="headerlink" title="Functions 函数"></a>Functions 函数</h3><center><img loading="lazy" src="/posts/301925f/1.jpg" width="550px"></center><ul><li>$x_n$相当于y值</li><li>domain：陪域 range: 值域</li><li>total: 全函数 partial: 部分函数</li></ul><center><img loading="lazy" src="/posts/301925f/3.jpg" width="550px"></center><ul><li>injective单射：指将不同的变量映射到不同的值的函数。</li><li>surjective满射：指陪域等于值域的函数。即：对陪域中任意元素，都存在至少一个定义域中的元素与之对应。</li><li>bijective双射（也称一一对应或一一映射 one-to-one and onto）：既是单射又是满射的函数</li></ul><center><img loading="lazy" src="/posts/301925f/2.png" width="550px"></center><h2 id="Cardinality-势"><a href="#Cardinality-势" class="headerlink" title="Cardinality 势"></a>Cardinality 势</h2><ul><li>The cardinality<code>/ˈkɑː.dɪnˈæl.ə.ti/</code> of a set is the <strong>number</strong> of elements in the set</li><li>如果存在着从集合A到集合B的双射，那么集合A与集合B等势，记为A~B</li></ul><h3 id="powerset-幂集"><a href="#powerset-幂集" class="headerlink" title="powerset 幂集"></a>powerset 幂集</h3><ul><li>The powerset of a set S , denoted $2^S$ , is the set of all subsets of S <ul><li>由该集合全部子集为元素构成的集合</li></ul></li><li>Let S be a finite set of cardinality n ; then the cardinality of its powerset is $2^n$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Sets-集合&quot;&gt;&lt;a href=&quot;#Sets-集合&quot; class=&quot;headerlink&quot; title=&quot;Sets 集合&quot;&gt;&lt;/a&gt;Sets 集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A set is composed of elements . a ∈ S denotes that a is an element of set S&lt;/li&gt;
&lt;li&gt;The set with no elements is the empty set , denoted ∅.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Multi-Sets-多重集&quot;&gt;&lt;a href=&quot;#Multi-Sets-多重集&quot; class=&quot;headerlink&quot; title=&quot;Multi-Sets 多重集&quot;&gt;&lt;/a&gt;Multi-Sets 多重集&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;sets which allow repetition&lt;/li&gt;
&lt;li&gt;$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S&lt;ul&gt;
&lt;li&gt;S &amp;#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then &lt;code&gt;S(a) = 3, S(b) = 2, S(c) = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;denoted: $S: A\rightarrow{Z^{+}}$，A is the underlying set of the multiset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;multi-set S over X is called &lt;strong&gt;finite&lt;/strong&gt;, if &lt;code&gt;&amp;#123; x ∈ X | S(x) &amp;gt; 0&amp;#125;| &amp;lt; ∞&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/5.png&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Set-Operators-集合操作符&quot;&gt;&lt;a href=&quot;#Set-Operators-集合操作符&quot; class=&quot;headerlink&quot; title=&quot;Set Operators 集合操作符&quot;&gt;&lt;/a&gt;Set Operators 集合操作符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S is a subset of T , denoted S ⊆ T , iff every element of S is an element of T , that is, x ∈ S → x ∈ T . S is a proper subset of T , denoted S ⊂ T , iff S ⊆ T and S ≠ T&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union&lt;/strong&gt;联合&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;∪&lt;/code&gt; T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intersection&lt;/strong&gt;交集&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;∩&lt;/code&gt; T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S ∩ T &amp;#x3D;∅ then S and T are disjoint .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difference&lt;/strong&gt;差集&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;−&lt;/code&gt; T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;complement&lt;/strong&gt; 补集&lt;ul&gt;
&lt;li&gt;Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S − T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cartesian product&lt;/strong&gt;笛卡尔积&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S &lt;code&gt;×&lt;/code&gt; T , their Cartesian product , is the set of all pairs ( s , t ) such that s ∈ S and t ∈ T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/4.gif&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Sequences-序列&quot;&gt;&lt;a href=&quot;#Sequences-序列&quot; class=&quot;headerlink&quot; title=&quot;Sequences 序列&quot;&gt;&lt;/a&gt;Sequences 序列&lt;/h2&gt;&lt;p&gt;Let $S$ be a set.&lt;/p&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-命题逻辑-归结</title>
    <link href="https://hejueyun.github.io/posts/f59d8546/"/>
    <id>https://hejueyun.github.io/posts/f59d8546/</id>
    <published>2022-02-09T23:09:30.000Z</published>
    <updated>2022-02-15T23:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The method of resolution is an efficient method for <strong>searching for a proof</strong>.</p></blockquote><h2 id="Reasoning-Methods"><a href="#Reasoning-Methods" class="headerlink" title="Reasoning Methods"></a>Reasoning Methods</h2><ul><li>Resolution</li><li>DPLL&#x2F;CDCL</li><li>Tableaux</li></ul><p>A refutational reasoning反驳性推理 method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either “satisfiable”, “unsatisfiable” or “don’t know”</p><h3 id="soundness"><a href="#soundness" class="headerlink" title="soundness"></a>soundness</h3><p>Consider <strong>a set of formulas</strong> Φ (usually called a <strong>fragment</strong>).<br>A reasoning method <strong>RM</strong> is sound for Φ if for any set S ⊆ Φ:</p><ul><li>if RM(S) is “satisfiable” then there is an interpretation satisfying all formulas in S</li><li>if RM(S) is “unsatisfiable” then there is no interpretation satisfying all formulas in S.</li><li>A trivial琐碎 RM which on all inputs returns “don’t know” is a sound reasoning method</li></ul><h3 id="Completeness"><a href="#Completeness" class="headerlink" title="Completeness"></a>Completeness</h3><p>A reasoning method RM is <strong>(refutationally) complete</strong> for Φ if for any set<br>S ⊆ Φ:</p><ul><li>if S is unsatisfiable then RM(S) is terminating and returns “unsatisfiable”</li></ul><h3 id="Trivialism-琐碎论"><a href="#Trivialism-琐碎论" class="headerlink" title="Trivialism 琐碎论"></a>Trivialism 琐碎论</h3><ul><li>琐碎论是一承认所有语句（也称为命题）为真并且所有“P与非P”形式的矛盾句都为真的逻辑理论</li><li>P当且仅当P为真</li></ul><h2 id="Clause-子句"><a href="#Clause-子句" class="headerlink" title="Clause 子句"></a>Clause 子句</h2><p>Clause: a disjunction析取 $L_1 ∨ . . . ∨ L_n$, n ≥ 0 of literals.</p><ul><li>A clause can be seen as a mulit-set of literals ${L_1, . . . , L_n}$</li><li><strong>Empty clause</strong>, denoted by <code>⊥: n = 0 </code>(also denoted as <code>□</code>, the empty clause is false in every interpretation)</li><li><strong>Unit clause</strong>单位子句: n &#x3D; 1<ul><li>A clause is unit under a partial assignment when that assignment makes every literal in the clause unsatisfied but leaves a single literal undecided</li><li>如果一个子句中，除了一个未决定的字面量，所有字面量都已经确定为假，我们就称这个子句为“单位子句”</li></ul></li><li><strong>Trivial Clauses</strong><ul><li>clause if trivial if it contains a pair of clashing冲突的 literals. </li><li>Since a trivial clause is valid ($p∨¬ p ≡ T$), <strong>it can be removed from a set of clauses without changing the truth value of the formula</strong>.</li></ul></li><li>A formula is considered to be an implicit conjunction of its clauses</li><li>The formula that is the empty set of clauses is denoted by ∅.</li></ul><center><img loading="lazy" src="/posts/f59d8546/1.png" width="550"></center><ul><li><p>也就是公式形式vs集合形式</p></li><li><p>Clausal form of a formula A: a set of clauses which is satisfiable if and only if A is satisfiable.</p></li><li><p>Clausal form of a set S of formulas: a set of clauses which is satisfiable if and only if so is S.</p></li></ul><h3 id="Definitional-Clausal-Form-Transformation"><a href="#Definitional-Clausal-Form-Transformation" class="headerlink" title="Definitional Clausal Form Transformation"></a>Definitional Clausal Form Transformation</h3><center><img loading="lazy" src="/posts/f59d8546/5.png" width="550"></center><ol><li>Take all subformulas that are not literals</li><li>Introduce names for these formulas. Note we do not introduce names for literals.</li><li>Introduce definitions.</li><li>Convert resulting formulas into CNF using the standard transformation</li></ol><h2 id="Conjunctive-Normal-Form-合取范式"><a href="#Conjunctive-Normal-Form-合取范式" class="headerlink" title="Conjunctive Normal Form 合取范式"></a>Conjunctive Normal Form 合取范式</h2><blockquote><p>写成合取范式的公式由一些子句（clause）相<strong>与（AND, $\lor$()）</strong>而成；子句则是由字面量（literal）相<strong>或（OR, $\land{}$)</strong> 而成；每个字面量就是一个变量，或者由变量 <strong>取非($\lnot{}$)</strong> 得到</p><ul><li>由于这样的公式只是一些子句“与”起来，为使<strong>公式</strong>满足，每个<strong>子句</strong>也都必须得到满足；</li><li>由于每个子句只是一些字面量“或”起来，只要满足了一个<strong>字面量</strong>就满足了整个<strong>子句</strong></li></ul></blockquote><p>A formula is in conjunctive normal form (CNF) iff it is a conjunction of disjunctions of <strong>字面量literals</strong></p><ul><li>在布尔逻辑中，如果一个公式是<strong>子句clause</strong>的合取(conjucntion)</li></ul><center><img loading="lazy" src="/posts/f59d8546/2.png" width="550"></center><ul><li>Every formula in propositional logic can be transformed into an equivalent formula in CNF</li></ul><center><img loading="lazy" src="/posts/f59d8546/3.png" width="550"></center><ul><li>A formula is in 3CNF iff it is in CNF and each disjunction has exactly three literals.</li></ul><p>推导例子</p><center><img loading="lazy" src="/posts/f59d8546/4.png" width="550"></center><ul><li>cnf cannot avoid exponential blowup<ul><li>Approach: relax requirement of equivalence preserving to equisatisfiability preserving</li><li>也就是重命名（比如n&#x3D;$p_1\leftrightarrow{p_2}$）</li></ul></li></ul><h2 id="Resolution-Rule-归结原理"><a href="#Resolution-Rule-归结原理" class="headerlink" title="Resolution Rule 归结原理"></a>Resolution Rule 归结原理</h2><p>Propositional Resolution inference system BR, consists of the following inference rules</p><center><img loading="lazy" src="/posts/f59d8546/6.png" width="550"></center><p>example</p><center><img loading="lazy" src="/posts/f59d8546/7.png" width="550"></center><h3 id="Tree-vs-Linear"><a href="#Tree-vs-Linear" class="headerlink" title="Tree vs Linear"></a>Tree vs Linear</h3><center><img loading="lazy" src="/posts/f59d8546/9.png" width="550"></center><h2 id="inference-推理"><a href="#inference-推理" class="headerlink" title="inference 推理"></a>inference 推理</h2><center><img loading="lazy" src="/posts/f59d8546/8.png" width="550"></center><ul><li>premises前提: known or assumed to be true</li><li>conclusion结论</li><li>An inference rule <code>R</code> is a set of inferences.</li><li>An inference system, (or a calculus演算) <code>I</code> is a set of inference rules.</li></ul><h3 id="sound"><a href="#sound" class="headerlink" title="sound"></a>sound</h3><ul><li>An inference system is sound if all its inference rules are sound</li><li>If an inference system $I$ is sound then for any set of formulas S:<ul><li>$S ⊢_I ⊥$ implies $S ⊨ ⊥$</li></ul></li></ul><h3 id="completeness"><a href="#completeness" class="headerlink" title="completeness"></a>completeness</h3><ul><li>An inference system $I$ is refutationally complete if for any set of formulas S we have<ul><li>$S ⊨ ⊥$ implies $S ⊢_I ⊥$</li></ul></li></ul><h2 id="Simplification-rules-化简规则"><a href="#Simplification-rules-化简规则" class="headerlink" title="Simplification rules 化简规则"></a>Simplification rules 化简规则</h2><blockquote><p>to remove clauses in the saturation process without affecting neither soundness nor completeness</p></blockquote><h3 id="derived-and-saturated"><a href="#derived-and-saturated" class="headerlink" title="derived and saturated"></a>derived and saturated</h3><ul><li>⊥ is <strong>derived</strong> &#x3D;&#x3D; $⊥ ∈ S_n$ for some n</li><li>no new clauses can be derived from S and ⊥ ̸∈ S, then S is <strong>saturated</strong>; in this case S is satisfiable</li></ul><h3 id="Rule-Tautology-elimination-TE"><a href="#Rule-Tautology-elimination-TE" class="headerlink" title="Rule: Tautology elimination (TE)"></a>Rule: Tautology elimination (TE)</h3><ul><li><code>S ⇒ S \ &#123;C&#125;</code> <ul><li>where C is a tautology (⊨ C)</li></ul></li></ul><h3 id="Rule-Subsumption-Elimination-SE"><a href="#Rule-Subsumption-Elimination-SE" class="headerlink" title="Rule: Subsumption Elimination (SE)"></a>Rule: Subsumption Elimination (SE)</h3><ul><li><p>A clause C <strong>subsumes</strong>归入 a clause D if C ⊂ D</p></li><li><p><code>S ⇒ S \ &#123;D&#125;</code></p><ul><li>where there is C ∈ S such that C ⊂ D</li></ul></li></ul><center><img loading="lazy" src="/posts/f59d8546/10.png" width="550"></center><ul><li>We say a clause C to is in a <strong>set-reduced</strong> form if every literal occurs no more than once in C. A clause C in a set-reduced from can be seen as <strong>a set of literals</strong> (rather than <strong>a multi-set</strong>).</li><li>BR with eager (BF) and (SE) is a <strong>decision procedure</strong> for propositional logic</li></ul><h2 id="Inference-vs-Deductive-vs-Resolutuion-推论vs演绎vs归结"><a href="#Inference-vs-Deductive-vs-Resolutuion-推论vs演绎vs归结" class="headerlink" title="Inference vs Deductive vs Resolutuion 推论vs演绎vs归结"></a>Inference vs Deductive vs Resolutuion 推论vs演绎vs归结</h2><ul><li>We use reasons or reasoning to form inferences which are basically conclusions drawn from propositions or assumptions that are supposed to be true.<ul><li><strong>推论</strong>是从假定为真实的命题(<strong>前提</strong>)得出的<strong>结论</strong></li></ul></li><li>Deduction is a general-to-specific form of reasoning that goes from known truths to specific instances. It starts with a hypothesis and examines the possibilities within that hypothesis to reach a conclusion. Example, in chemistry deducing a chemical equation basis two or more agents.<ul><li><strong>演绎</strong>是一种从一般到具体的推理形式，从已知真理到具体实例</li><li>它从一个假设开始，研究该假设中的各种可能性以得出结论</li></ul></li><li>resolution is <strong>a rule of inference</strong> leading to a <strong>refutation complete theorem-proving technique</strong> for sentences in propositional logic and first-order logic<ul><li><strong>归结</strong>是一种反向证明的方法，是对于命题逻辑和一阶逻辑中的句子的<strong>推理规则</strong></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The method of resolution is an efficient method for &lt;strong&gt;searching for a proof&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Reasoning-Methods&quot;&gt;&lt;a href=&quot;#Reasoning-Methods&quot; class=&quot;headerlink&quot; title=&quot;Reasoning Methods&quot;&gt;&lt;/a&gt;Reasoning Methods&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Resolution&lt;/li&gt;
&lt;li&gt;DPLL&amp;#x2F;CDCL&lt;/li&gt;
&lt;li&gt;Tableaux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A refutational reasoning反驳性推理 method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either “satisfiable”, “unsatisfiable” or “don’t know”&lt;/p&gt;
&lt;h3 id=&quot;soundness&quot;&gt;&lt;a href=&quot;#soundness&quot; class=&quot;headerlink&quot; title=&quot;soundness&quot;&gt;&lt;/a&gt;soundness&lt;/h3&gt;&lt;p&gt;Consider &lt;strong&gt;a set of formulas&lt;/strong&gt; Φ (usually called a &lt;strong&gt;fragment&lt;/strong&gt;).&lt;br&gt;A reasoning method &lt;strong&gt;RM&lt;/strong&gt; is sound for Φ if for any set S ⊆ Φ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if RM(S) is “satisfiable” then there is an interpretation satisfying all formulas in S&lt;/li&gt;
&lt;li&gt;if RM(S) is “unsatisfiable” then there is no interpretation satisfying all formulas in S.&lt;/li&gt;
&lt;li&gt;A trivial琐碎 RM which on all inputs returns “don’t know” is a sound reasoning method&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Completeness&quot;&gt;&lt;a href=&quot;#Completeness&quot; class=&quot;headerlink&quot; title=&quot;Completeness&quot;&gt;&lt;/a&gt;Completeness&lt;/h3&gt;&lt;p&gt;A reasoning method RM is &lt;strong&gt;(refutationally) complete&lt;/strong&gt; for Φ if for any set&lt;br&gt;S ⊆ Φ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if S is unsatisfiable then RM(S) is terminating and returns “unsatisfiable”&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-命题逻辑-演绎</title>
    <link href="https://hejueyun.github.io/posts/ec86b407/"/>
    <id>https://hejueyun.github.io/posts/ec86b407/</id>
    <published>2022-02-07T16:16:19.000Z</published>
    <updated>2022-02-15T23:48:47.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="形式语言"><a href="#形式语言" class="headerlink" title="形式语言"></a>形式语言</h2><blockquote><p>语言按照语法分类大致可分为自然语言与形式语言两种。</p></blockquote><blockquote><p>自然语言（Natural Language）就是人类讲的语言，比如汉语、英语等。此类语言不是人为设计的语言，而是自然进化而成的。</p><p>形式语言（Formal Language）是为了满足特定的应用而人为设计的语言。例如数学使用的数字与运算符号、化学使用的分子式。编程语言同样也是一种形式语言，是专门用来表达计算过程的形式语言。</p><p>形式语言有严格的语法（Syntax）规则。语法规则是由符号（Token）与结构（Structure）的规则组成。</p><p>Token 相当于自然语言中的单词与标点、数学式中的数字与运算符。例如 6 &#x3D; 3 + 3$，之所以无法构成一个等式，是因为 $ 符号并不属于合法的 Token 符号。</p><p>结构则是指 Token 的排列方式， 如 3 &#x3D; + 3 虽然加号与等号均为核发的 Token 运算符，但是存在一定的结构错误。</p><p>关于 Token 的规则称为词法（Lexical）规则。而关于结构的规则称为语法（Semantic）规则。</p><p>当阅读一个自然语言句子或是形式语言句子时，首先要明白词法规则（Token），然后需要弄清楚句子的语法结构（如学习阅读外语句子时）。分析句子结构的过程就是解析（Parse）的过程</p></blockquote><p>例如</p><ul><li>正则表达式</li><li>自动机</li></ul><h2 id="Deductive-Proof"><a href="#Deductive-Proof" class="headerlink" title="Deductive Proof"></a>Deductive Proof</h2><p>The deductive systems studiedwere developed in an attempt to formalize mathematical reasoning.</p><ul><li>所研究的演绎系统是为了使数学推理正规化而开发的。</li></ul><p>引入演绎证明方法的意义</p><ul><li>The set of axioms may be infinite</li><li>Very few logics have decision procedures like propositional logic</li><li>A decision procedure may not give insight into the relationship between the axioms and the theorem</li><li>A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas). Clearly, the millions of mathematical theorems in existence could not have been inferred directly from axioms<ul><li>A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas)</li></ul></li></ul><p>type</p><ul><li>The second one <strong>$H$</strong> will be familiar because it is a formalization of step-by-step proofs in mathematics: It contains a set of <strong>three</strong> axioms and <strong>one</strong> rule of inference; proofs are constructed as a sequence of formulas, each of which is either an axiom (or a formula that has been previously proved) or a derivation of a formula from previous formulas in the sequence using the rule of inference.</li><li>The system <strong>$G$</strong> will be less familiar because it has one axiom and many rules of inference, but we present it first because it is almost trivial to prove the soundness and completeness of $G$ from its relationship with semantic tableaux</li></ul><h3 id="deductive-system-演绎系统"><a href="#deductive-system-演绎系统" class="headerlink" title="deductive system 演绎系统"></a>deductive system 演绎系统</h3><ul><li>A deductive system is <strong>a set of formulas called axioms</strong> and <strong>a set of rules of inference</strong>.<ul><li><strong>公理axioms</strong>是用来推导其他命题的起点。和<strong>定理Theorem</strong>不同，一个公理（除非有冗余的）不能被其他公理推导出来，否则它就不是起点本身</li><li>A proof in a deductive system is a sequence of formulas $S&#x3D;{A_1,…,A_n}$ such that each formula A i is either an axiom or it can be inferred from <strong>previous formulas</strong> of the sequence $A_{j_1},…A_{j_n}$, where $j_1&lt;⋯&lt;j_k &lt;i$, using a rule of inference. For $A_n$ , the last formula in the sequence, we say that $A_n$ is a <strong>theorem</strong>定理, the sequence S is a proof of $A_n$ , and $A_n$ is <strong>provable</strong>, denoted $⊢A_n$ . If ⊢A, then A <strong>may be used like an axiom</strong> in a <strong>subsequent proof</strong>.<blockquote><p>In proof theory, the turnstile is used to denote “provability” or “derivability”. For example, if T is a formal theory and S is a particular sentence in the language of the theory then T⊢S means that S is provable from T</p></blockquote></li></ul></li><li>if T, then S</li></ul><blockquote><p>一个 <strong>矢列</strong> 是一个二元组 (Γ,∆)，记为 Γ ⊢ ∆，这里 Γ,∆ 为命题的 有穷集合（可为空），称 Γ 为前件，∆ 为后件.命题逻辑的自然推理系统 G′ 由以下公理和规则组成，Γ,∆,Λ,Θ 表示任何命题有穷集合，A,B 表示任何命题，<strong>Γ,A,∆为集合 Γ ∪ {A} ∪ ∆ 的简写</strong>.</p><ul><li>规则的上矢列S1,S2 被称为前提，下矢列S 被称为结论.G′ 中规则被称为推<br>理规则，规则中被作用的命题被称为主命题，而不变的命题被称为辅命题.</li><li>每个公理和规则是模式（schema），它们可有无穷多个实例.</li></ul></blockquote><center><img loading="lazy" src="/posts/ec86b407/2.png" width="550px"></center><p>sequent序贯</p><ul><li>If U and V are (possibly empty) sets of formulas, then U⇒V is a sequent</li></ul><h3 id="演绎vs归纳"><a href="#演绎vs归纳" class="headerlink" title="演绎vs归纳"></a>演绎vs归纳</h3><ul><li>参考：<a href="https://zhuanlan.zhihu.com/p/98979189">初等几何笔记：希尔伯特的公理体系—第 1 章 破晓：在欧几里得之前 - 遇见数学的文章 - 知乎</a></li></ul><h2 id="Gentzen-System"><a href="#Gentzen-System" class="headerlink" title="Gentzen System"></a>Gentzen System</h2><p><strong>相继式演算</strong>（<strong>Sequent calculus</strong>，又译矢列演算、矢列式演算、序贯演算）</p><ul><li><strong>An axiom of $G$ is a set of literals U containing a complementary pair</strong>. Rule of inference are used to infer a set of formulas U from one or two other sets of formulas U 1 and U 2; there are two types of rules</li><li>Let ${α_1,α_2}\subseteq{U_1}$ and let $U_1’&#x3D;U_1-{α_1,α_2}$. Then $U&#x3D;U_1’\cup{α}$  can be inferred</li><li>Let ${β_1}⊆U_1$, ${β_2}⊆U_2$ and let $U_1’&#x3D;U_1-{β_1}$, $U_2’&#x3D;U_2-{β_2}$. Then $U&#x3D;U_1’\cup{U_2’}\cup$ can be inferred.</li></ul><center><img loading="lazy" src="/posts/ec86b407/3.gif" width="550px"></center><ul><li><p>The set or sets of formulas $U_1,U_2$ are the premises前提 and set of formulas U that is inferred is the conclusion结论</p></li><li><p>A set of formulas $U$ that is an axiom or a conclusion is said <strong>to be proved</strong>, denoted <code>⊢U</code></p><ul><li>这个符号因为名叫turnstile闸机</li></ul></li><li><p>$⊢A$</p><ul><li>I know A is true</li><li>A is a theorem in the system</li></ul></li><li><p>$P⊢Q$</p><ul><li>From P, I know that Q</li><li>Q is derivable from P in the system 衍生</li><li>P is provable from Q 证明</li></ul></li><li><p>The following notation is used for <strong>rules of inference</strong>:</p></li></ul><center><img loading="lazy" src="/posts/ec86b407/1.gif" width="550px"></center><ul><li>Prove ⊢(p∨q)→(q∨p) in G</li></ul><center><img loading="lazy" src="/posts/ec86b407/4.gif" width="550px"></center><h3 id="vs-Semantic-Tableaux"><a href="#vs-Semantic-Tableaux" class="headerlink" title="vs Semantic Tableaux"></a>vs Semantic Tableaux</h3><ul><li>上下翻转</li></ul><center><img loading="lazy" src="/posts/ec86b407/5.gif" width="550px"></center><ul><li>Let A be a formula in propositional logic. Then ⊢A in $G$  if and only if there is a closed semantic tableau for ¬ A.<ul><li>当且仅当语义树叶子结点全部时互补文字集时，公式才可证</li></ul></li></ul><h3 id="⊨-vs-⊢-（蕴含-vs-可证）"><a href="#⊨-vs-⊢-（蕴含-vs-可证）" class="headerlink" title="⊨ vs ⊢ （蕴含 vs 可证）"></a>⊨ vs ⊢ （蕴含 vs 可证）</h3><p>⊨A if and only if ⊢A in $G$.</p><ul><li>A为真当且仅当A可证<blockquote><p>A is valid iff ¬ A is unsatisfiable iff there is a closed semantic tableau for ¬ A iff there is a proof of A in $G$</p></blockquote></li></ul><center><img loading="lazy" src="/posts/ec86b407/6.jpg" width="550px"></center><p><em>想像文氏图有助于理解，下图为蕴含</em></p><center><img loading="lazy" src="/posts/ec86b407/9.png" width="550px"></center><ul><li>Soundness：若 Γ ⊢ ∆ 在 G′ 中可证，则 Γ ⊢ ∆ 有效</li><li>completeness：若 Γ ⊢ ∆ 有效，则 Γ ⊢ ∆ 在 G′ 中可证.这就是 G′ 的完全性</li></ul><h3 id="⊨-vs-⊢-vs-→"><a href="#⊨-vs-⊢-vs-→" class="headerlink" title="⊨ vs ⊢ vs →"></a>⊨ vs ⊢ vs →</h3><ul><li>$a⊢b&#x3D; ⊢a\rightarrow{b}$</li><li>$a⊢b&#x3D; ⊨a\rightarrow{b}$</li></ul><blockquote><p>注意<code>⊧</code>不是<strong>该语言</strong>中的符号，而是在上层语言 (meta-language) 中.在上层语言中，人们也需要用联结词如 iff，not，and，or，imply 等</p><p>上层语言是一种用于描述另一种语言的语言</p></blockquote><h2 id="Hilbert-System"><a href="#Hilbert-System" class="headerlink" title="Hilbert System"></a>Hilbert System</h2><blockquote><p>In Gentzen systems there is one axiom and many rules of inference, while in a Hilbert system there are several axioms but only one rule of inference. </p><p>在Gentzen系统中，有一个公理和许多推理规则，而在Hilbert系统中，有几个公理但只有一个推理规则</p></blockquote><ul><li>axioms：</li></ul><center><img loading="lazy" src="/posts/ec86b407/8.gif" width="550px"></center><ul><li>rule of inference： <strong>modus ponens</strong>辩证法<ul><li>the formula B can be inferred from A and A→B</li></ul></li></ul><center><img loading="lazy" src="/posts/ec86b407/7.gif" width="550px"></center><ul><li>实际上就是**Binary Resolution(BR)**归结的特例</li></ul><center><img loading="lazy" src="/posts/ec86b407/10.jpg" width="450px"></center><h2 id="相继式演绎-vs-希尔伯特演绎"><a href="#相继式演绎-vs-希尔伯特演绎" class="headerlink" title="相继式演绎 vs 希尔伯特演绎"></a>相继式演绎 vs 希尔伯特演绎</h2><blockquote><p>Both the deductive systems  and  are sound and complete. Completeness of  follows directly from the completeness of the method of semantic tableaux as a decision procedure for satisfiability and validity in propositional logic. However, the method of semantic tableaux is not very efficient.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://yaojianqun.com/index.php/2021/04/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/">形式语言 - 留白</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;形式语言&quot;&gt;&lt;a href=&quot;#形式语言&quot; class=&quot;headerlink&quot; title=&quot;形式语言&quot;&gt;&lt;/a&gt;形式语言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;语言按照语法分类大致可分为自然语言与形式语言两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自然语言（Natural Language）就是人类讲的语言，比如汉语、英语等。此类语言不是人为设计的语言，而是自然进化而成的。&lt;/p&gt;
&lt;p&gt;形式语言（Formal Language）是为了满足特定的应用而人为设计的语言。例如数学使用的数字与运算符号、化学使用的分子式。编程语言同样也是一种形式语言，是专门用来表达计算过程的形式语言。&lt;/p&gt;
&lt;p&gt;形式语言有严格的语法（Syntax）规则。语法规则是由符号（Token）与结构（Structure）的规则组成。&lt;/p&gt;
&lt;p&gt;Token 相当于自然语言中的单词与标点、数学式中的数字与运算符。例如 6 &amp;#x3D; 3 + 3$，之所以无法构成一个等式，是因为 $ 符号并不属于合法的 Token 符号。&lt;/p&gt;
&lt;p&gt;结构则是指 Token 的排列方式， 如 3 &amp;#x3D; + 3 虽然加号与等号均为核发的 Token 运算符，但是存在一定的结构错误。&lt;/p&gt;
&lt;p&gt;关于 Token 的规则称为词法（Lexical）规则。而关于结构的规则称为语法（Semantic）规则。&lt;/p&gt;
&lt;p&gt;当阅读一个自然语言句子或是形式语言句子时，首先要明白词法规则（Token），然后需要弄清楚句子的语法结构（如学习阅读外语句子时）。分析句子结构的过程就是解析（Parse）的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;自动机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Deductive-Proof&quot;&gt;&lt;a href=&quot;#Deductive-Proof&quot; class=&quot;headerlink&quot; title=&quot;Deductive Proof&quot;&gt;&lt;/a&gt;Deductive Proof&lt;/h2&gt;&lt;p&gt;The deductive systems studiedwere developed in an attempt to formalize mathematical reasoning.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所研究的演绎系统是为了使数学推理正规化而开发的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引入演绎证明方法的意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The set of axioms may be infinite&lt;/li&gt;
&lt;li&gt;Very few logics have decision procedures like propositional logic&lt;/li&gt;
&lt;li&gt;A decision procedure may not give insight into the relationship between the axioms and the theorem&lt;/li&gt;
&lt;li&gt;A decision procedure produces a ‘yes&amp;#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas). Clearly, the millions of mathematical theorems in existence could not have been inferred directly from axioms&lt;ul&gt;
&lt;li&gt;A decision procedure produces a ‘yes&amp;#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>计算机数理逻辑-命题逻辑-语法与语义</title>
    <link href="https://hejueyun.github.io/posts/cacbbbdb/"/>
    <id>https://hejueyun.github.io/posts/cacbbbdb/</id>
    <published>2022-02-05T23:01:28.000Z</published>
    <updated>2022-02-18T15:11:41.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Logic formalizes valid methods of reasoning</p><ul><li><p>逻辑将有效的推理方法正规化</p></li><li><p>比如syllogism&#x2F;ˈsɪləˌdʒɪz(ə)m&#x2F;三段论</p></li><li><p><strong>atomic<code>/əˈtɒm.ɪk/</code> proposition</strong></p><ul><li>statements that have no internal structure</li><li>原子命题是没有内部结构的语句</li><li><code>cannot be further decomposed</code> and <code>can be assigned a truth value of true or false</code></li><li>often shortened to <strong>atoms</strong></li></ul></li><li><p><strong>syntax</strong></p><ul><li>define the legal structure of formulas in propositional logic</li></ul></li><li><p><strong>semantics</strong></p><ul><li>the meaning of formulas<ul><li>T or F</li><li>Another notation is <code>⊤</code> for true and <code>⊥</code> for false</li></ul></li></ul></li><li><p><strong>Proof</strong></p><ul><li>A proof is a deduction of a formula from a set of formulas called <strong>axioms</strong> using rules of inference.</li><li>证明是<strong>利用推理规则</strong>从一组称为<strong>公理</strong>的公式中推导出一个<strong>公式</strong></li></ul></li></ul><blockquote><p>Propositional logic is central to the design of computer hardware because hardware is usually designed with components having two voltage levels that are arbitrarily assigned the symbols 0 and 1. Circuits<code>/ˈsərkət/</code> are described by idealized elements called logic gates</p><p>命题逻辑是计算机硬件设计的核心，因为硬件的设计通常有两个电压电平，被任意分配为符号0和1。电路由称为逻辑门的理想化元素描述</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/15.png" wid="550px"></center><h2 id="Propositional-Formulas命题公式"><a href="#Propositional-Formulas命题公式" class="headerlink" title="Propositional Formulas命题公式"></a>Propositional Formulas命题公式</h2><ul><li><strong>expression</strong> 表达式<ul><li>denoted the computation of a value from other values</li><li>表示从其他数值中计算出一个数值</li><li><strong>In propositional logic, the term formula is used instead</strong></li></ul></li><li>atomic propositions <ul><li>An unbounded set of symbols P</li></ul></li><li>Boolean operators</li></ul><h3 id="subformulas"><a href="#subformulas" class="headerlink" title="subformulas"></a>subformulas</h3><center><img loading="lazy" src="/posts/cacbbbdb/22.jpg" wid="550px"></center><h3 id="Formulas-as-Trees"><a href="#Formulas-as-Trees" class="headerlink" title="Formulas as Trees"></a>Formulas as Trees</h3><center><img loading="lazy" src="/posts/cacbbbdb/1.gif" wid="550px"></center><ul><li>unary<code>/ˈjuːnəri/</code> operator 单目运算符 vs binary operators 双目运算符</li><li>implication 实质条件 <strong>实质</strong>蕴涵 <ul><li>理解为assignment</li><li>若A，则B (要么A为假 要么B为真（或二者同时成立）)</li><li>A $\rightarrow$ B &#x3D;&#x3D; $¬A∨B$ 相当于只是一个简写denote</li><li>区别于<strong>语义</strong>蕴含<code>⊨</code></li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/21.png" wid="550px"></center><ul><li>nor和nand就是在or和and之后再取一次反</li></ul><p>命题逻辑中的公式可以是一棵递归定义的树（defined recursively）</p><ul><li>一个公式是由一个原子命题标记（labeled）的叶子。</li><li>一个公式是一个由¬标记的节点，它的一个子节点是一个公式</li><li>一个公式是一个由二元运算符之一标记的节点，同时两个子节点自身也是公式</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/2.gif" wid="550px"></center><h3 id="Formulas-as-Strings"><a href="#Formulas-as-Strings" class="headerlink" title="Formulas as Strings"></a>Formulas as Strings</h3><p>命题逻辑中的公式也可以是字符串</p><ul><li>The string associated with a formula is obtained by an <strong>inorder traversal</strong><code>/trəˈvərs(ə)l/</code><br> of the tree</li><li>一个公式的字符串表示是通过对树的<strong>中序遍历</strong>得到的<ul><li>先左子树，后根结点，最后右子树</li></ul></li><li>ambiguity <code>/æmbɪˈɡjuːɪti/</code> 模糊性</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/16.png" wid="550px"></center><h3 id="Resolving-Ambiguity-in-the-String-Representation"><a href="#Resolving-Ambiguity-in-the-String-Representation" class="headerlink" title="Resolving Ambiguity in the String Representation"></a>Resolving Ambiguity in the String Representation</h3><p><strong>parentheses</strong><code>/pəˈrenθəsiːz/</code> 圆括号</p><ul><li>The simplest way to avoid ambiguity is to use parenthesesto maintain the structure of the tree when the string is constructed.</li><li>避免歧义的最简单方法是在构建字符串时使用<strong>圆括号</strong>来保持树的结构</li><li>缺点：verbose冗长 and hard to read and write</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/3.gif" wid="550px"></center><p><strong>Precedence<code>/ˈpresɪdəns/</code></strong> 优先级</p><ul><li>define precedence and associativity conventions among the operators as is done in arithmetic, so that we immediately recognize <code>a∗b∗c+d∗e</code> as <code>(((a∗b)∗c)+(d∗e))</code><ul><li>解决模棱两可的公式的第二种方法是在运算符之间定义优先级和关联性约定，就像在算术中所做的那样，这样我们就可以立即将<code>a∗b∗c+d∗e</code>识别为<code>(((a∗b)∗c)+(d∗e))</code></li></ul></li><li>Parentheses are used only if needed to indicate an order different from that imposed by the rules for precedence and associativity<ul><li>只有在需要表示与优先权和关联性规则所规定的顺序不同时，才使用括号</li></ul></li><li>precedence from high to low</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/4.gif" wid="550px"></center><p><strong>Polish Notation</strong> 波兰式（前缀表示法）和 <strong>reverse Polish notation</strong> 逆波兰式（后缀表示法）</p><blockquote><p>波兰表达式和逆波兰表达式有个好处，就算将圆括号去掉也没有歧义</p><p>逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入 栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值</p></blockquote><ul><li>用于简化命题逻辑</li><li><strong>先序遍历</strong> preorder<ul><li>表达式<code>a*(b+c)-e/f</code><ul><li>中序遍历，就是日常用的表达式写法。对于加法和减法需要加括号。</li><li>用前序遍历，对应前缀表达式：<code>-*a+bc/ef</code></li><li>用后序遍历，对应后缀表达式：<code>abc+*ef/-</code></li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/5.svg" wid="550px"></center><h3 id="Structural-induction-结构归纳法"><a href="#Structural-induction-结构归纳法" class="headerlink" title="Structural induction 结构归纳法"></a>Structural induction 结构归纳法</h3><blockquote><p>Structural induction is used to prove that a property holds for all formulas. This form of induction is similar to the familiar numerical induction that is used to prove that a property holds for all natural numbers</p><p>结构归纳法被用来证明一个属性对所有公式都成立。这种形式的归纳法类似于我们熟悉的数字归纳法，后者是用来证明一个属性对所有自然数都成立的</p></blockquote><p>To show that a property holds for all formulas $A\in{F}$ :</p><ol><li>Prove that the property holds all atoms $p$.</li><li>Assume that the property holds for a formula $A$ and prove that the property holds for $¬A$.</li><li>Assume that the property holds for formulas $A_1$ and $A_2$ and prove that the property holds for $A_1 op A_2$, for each of the binary operators.</li></ol><blockquote><p> so a proof that a property holds for all formulas can be done using structural induction with the base case and only two <strong>inductive</strong> steps. 一个初始例子和两个归纳步骤</p></blockquote><h2 id="Interpretations-解释"><a href="#Interpretations-解释" class="headerlink" title="Interpretations 解释"></a>Interpretations 解释</h2><p>一个<strong>函数</strong></p><ul><li>An interpretation for A is a total function $I_A:P_A \rightarrow{ { T,F } }$ that <strong>assigns</strong> one of the truth values T or F to every atom in $P_A$, $P_A$ 是 $A$ 的原子命题子集，$A$ 是公式集合 $F$ 中的一个</li><li>An interpretation is a mapping of atomic propositions to the values {T,F}. <ul><li>换句话说解释$I_A$就是“计算并返回A的真值”的函数</li></ul></li></ul><p>true value</p><blockquote><p>a truth value, sometimes called a logical value, is a value indicating the relation of a proposition to truth</p><p>真理值，有时也被称为逻辑值，是一个表明命题与真理关系的数值。</p></blockquote><ul><li>真值表Truth Tables<ul><li>拆分为subformula</li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/8.gif" wid="550px"></center><hr><center><img loading="lazy" src="/posts/cacbbbdb/6.gif" wid="550px"></center><p>设 A 为命题，v 为赋值.</p><ol><li>v 满足 A，记为 v ⊧ A，指 ˆv(A) &#x3D; T；</li><li>A 为永真式 (tautology)，记为 ⊧ A，指对任何 v 有 ˆv(A) &#x3D; T；</li><li>A 可满足指有 v 使 v ⊧ A；</li><li>设 Γ 为命题集，A 为 Γ 的语义结论，记为 Γ ⊧ A，指对所有 v，若对任何 B ∈ Γ 有 ˆv(B) &#x3D; T 则 ˆv(A) &#x3D; T.</li></ol><center><img loading="lazy" src="/posts/cacbbbdb/17.png" wid="550px"></center><h3 id="partial-interpretation"><a href="#partial-interpretation" class="headerlink" title="partial interpretation"></a>partial interpretation</h3><ul><li>A partial interpretation for A is a partial function $I_A:P_A\rightarrow{}{T,F}$ that assigns one of the truth values T or F to some of the atoms in $P_A$</li></ul><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>If a formula is true under an interpretation, then that interpretation is called a model of that formula<ul><li>如果一个公式在某个解释下是真的，那么这个解释就被称为该公式的模型</li></ul></li></ul><h3 id="The-Relationship-Between-↔-and-≡"><a href="#The-Relationship-Between-↔-and-≡" class="headerlink" title="The Relationship Between ↔ and ≡"></a>The Relationship Between ↔ and ≡</h3><ul><li>Equivalence, <code>↔</code>, is a Boolean operator in propositional logic and can appear in formulas of the logic</li><li>Logical equivalence, <code>≡</code>, is <strong>not a Boolean operator</strong>; instead, is a notation for a <strong>property</strong> of pairs of formulas in propositional logic. </li><li>$A_1$≡$A_2$ iff $A_1$↔$A_$2 is true in every interpretation.</li></ul><h3 id="Substitution"><a href="#Substitution" class="headerlink" title="Substitution"></a>Substitution</h3><p>A is a <strong>subformula</strong> of B if A is a subtree of B. </p><ul><li>If A is not the same as B, it is a <strong>proper subformula</strong> of B.</li></ul><p>B{A←A′}, the substitution of A′ for A in B(在B中用A’代替A), is the formula obtained by replacing all occurrences of the subtree for A in B by A′</p><ul><li>Let A be a subformula of B and let A′ be a formula such that A≡A′. Then B≡B{A←A′}</li></ul><h3 id="law-常用公式与定律"><a href="#law-常用公式与定律" class="headerlink" title="law 常用公式与定律"></a>law 常用公式与定律</h3><ul><li><p>⇔&#x2F;↔ 等价符号</p><ul><li>相当于if and only if</li><li>A ↔ B ≡ (A → B) ∧ (B → A)</li></ul></li><li><p>Idempotent<code>/ˌīdemˈpōt(ə)nt/</code> Law幂等律</p><ul><li>A⇔A∨A</li><li>A⇔A∧A</li></ul></li><li><p>commutative law交换律</p><ul><li>The binary Boolean operators are commutative, <strong>except for implication</strong>.</li><li>A∨B⇔B∨A</li><li>A∧B⇔B∧A</li><li>A↑B⇔B↑A</li></ul></li><li><p>associative law结合律</p><ul><li>(A∨B)∨C⇔A∨(B∨C)</li><li>(A∧B)∧C⇔A∧(B∧C)</li></ul></li><li><p>Distributive law分配律</p><ul><li>A∨(B∧C)⇔(A∨B)∧(A∨C)</li><li>A∧(B∨C)⇔(A∧B)∨(A∧C)</li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/23.jpg" wid="550px"></center><h2 id="Satisfiability-Validity-and-Consequence"><a href="#Satisfiability-Validity-and-Consequence" class="headerlink" title="Satisfiability, Validity and Consequence"></a>Satisfiability, Validity and Consequence</h2><ul><li>A is satisfiable可满足的 iff $v_I(A)&#x3D;T$ for some interpretation . <ul><li>A satisfying interpretation is a model for A.</li></ul></li><li>A is valid有效的, denoted <code>⊨</code>A, iff $v_I(A)&#x3D;T$ for <strong>all</strong> interpretations .<ul><li>A valid propositional formula is also called a tautology永真式（重言式）.</li></ul></li><li>A is unsatisfiable不可满足的 iff it is not satisfiable, that is, if $v_I(A)&#x3D;F$ for all interpretations</li><li>A is falsifiable可证伪的, denoted $\models$ 加上一个左斜杠<code>/</code>, iff it is not valid, that is, if $v_I(A)&#x3D;F$ for some interpretation</li></ul><p>T&#x3D;True F&#x3D;False</p><center><img loading="lazy" src="/posts/cacbbbdb/7.gif" wid="550px"></center><ul><li>A is valid if and only if ¬ A is unsatisfiable. A is satisfiable if and only if ¬ A is falsifiable.</li></ul><hr><p>符号之间的联系</p><ul><li><p>A formula A is valid if and only if ¬A is unsatisfiable.</p><ul><li>⊨ A iff ¬A ⊨ ⊥</li></ul></li><li><p>A formula A is satisfiable if and only if ¬A is not valid.</p></li><li><p>A formula A is valid if and only if A is equivalent to ⊤.</p></li><li><p>Formulas A and B are equivalent if and only if the formula A ↔ B is valid.</p></li><li><p>Propositional satisfiability is NP-complete NP完全（计算复杂度相关）.</p></li><li><p>Propositional validity is coNP-complete.</p></li></ul><h3 id="decision-procedure决定程序"><a href="#decision-procedure决定程序" class="headerlink" title="decision procedure决定程序"></a>decision procedure决定程序</h3><ul><li>Let $U\subseteq{F}$ be a set of formulas. An algorithm is a decision procedure for $U$ if given an arbitrary formula $A\in{F}$ , it terminates and returns the answer yes if $A\in{U}$ and the answer no if $A\notin{U}$ .</li><li>If $U$ is the set of satisfiable formulas, a decision procedure for  is called a decision procedure for satisfiability, and similarly for validity <ul><li>如果U是可满足公式的集合，那么一个可满足性的决策程序被称为可满足性的决策程序，同样地，有效性的决策程序也是如此。</li></ul></li><li>A reasoning method RM is a decision procedure for Φ if RM is <strong>sound</strong>, <strong>refutationally complete</strong> and <strong>terminating</strong> for Φ.</li><li>The truth table method is a decision procedure for propositional logic</li></ul><h3 id="Logical-Consequence-蕴涵（结论）"><a href="#Logical-Consequence-蕴涵（结论）" class="headerlink" title="Logical Consequence 蕴涵（结论）"></a>Logical Consequence 蕴涵（结论）</h3><ul><li>Let U be a set of formulas and A a formula. A is a logical consequence of U, denoted U⊨A, iff every model of U is a model of A<ul><li>集合A蕴涵集合B，当且仅当在其中A中所有句子都为真的所有模型中，在B中的所有句子也是真的</li></ul></li><li>Let <code>A=(p∨r)∧(¬ q∨¬ r)</code>. Then A is a logical consequence of {p,¬ q}, denoted {p,¬ q}⊨A</li></ul><blockquote><p>To see whether a formula F2 is a logical consequence of a formula F1, write out their <strong>joint truth table</strong>. Find the rows in which F1 is true; those are essentially the models that satisfy F1. Check to see whether F2 is also true in all of those rows&#x2F;models; if it is, then every model that satisfies F1 automatically satisfies F2, and F2 is therefore a logical consequence of F1. </p><p>要看一个公式F2是否是公式F1的逻辑结果，请写出它们的联合真值表。找出F1为真的那几行；这些基本上是满足F1的模型。检查F2是否在所有这些行&#x2F;模型中也是真的；如果是，那么每个满足F1的模型都自动满足F2，因此F2是F1的逻辑结果</p></blockquote><blockquote><p>蕴含是讨论“命题和命题之间的真值传递关系的”</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/9.png" wid="550px"></center><ul><li>U⊨A iff ⊨ $⋀_iA_i→A$</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/19.png" wid="550px"></center><blockquote><p>注意<code>⊨</code>不是该语言中的符号，而是在上层语言 (meta-language) 中.在上层语言中，人们也需要用联结词如 iff，not，and，or，imply 等</p></blockquote><h3 id="Logical-Equivalence-逻辑等价性"><a href="#Logical-Equivalence-逻辑等价性" class="headerlink" title="Logical Equivalence 逻辑等价性"></a>Logical Equivalence 逻辑等价性</h3><center><img loading="lazy" src="/posts/cacbbbdb/19.png" wid="550px"></center><h2 id="Semantic-Tableauxta·blowz-语义表"><a href="#Semantic-Tableauxta·blowz-语义表" class="headerlink" title="Semantic Tableauxta·blowz 语义表"></a>Semantic Tableaux<code>ta·blowz</code> 语义表</h2><blockquote><p>While truth tables can be used as a decision procedure for the satisfiability or validity of formulas of propositional logic, semantic tableaux are usually much more efficient. In a semantic tableau, a tree is constructed during a search for a model of a formula; the construction is based upon the structure of the formula. A semantic tableau is closed if the formula is unsatisfiable and open if it is satisfiable.</p></blockquote><ul><li>单数形式tableau<code>(/tæˈbloʊ)</code></li><li>an efficient <strong>decision procedure</strong> for <strong>satisfiability</strong> (and by duality <strong>validity</strong>) in <strong>propositional logic</strong></li><li>An analytic tableau is a tree structure computed for a logical formula, having at each node a subformula of the original formula to be proved or refuted. Computation constructs this tree and uses it to prove or refute the whole formula<ul><li>一个分析表是为一个逻辑公式计算的树状结构，在每个节点上都有一个要证明或反驳的原公式的子公式。通过计算构建了这棵树，并使用它来证明或反驳整个公式。</li></ul></li></ul><p>Literal文字 （vs atoms）</p><ul><li>A literal is an <strong>atom</strong> or <strong>the negation of an atom</strong>. An atom is a <strong>positive literal</strong> and the negation of an atom is a <strong>negative literal</strong>. </li><li>For any atom p, {p,¬ p} is a complementary互补的 pair of literals.</li><li>A set of literals is satisfiable if and only if it does not contain a complementary pair of literals.<ul><li>对于A&#x3D;p∧(¬ q∨¬ p)，当且仅当集合{p,¬ p}和{p,¬ q}中至少有一个不包含互补的一对文字时，A是可满足的。显然，只有第二个集合不包含一对互补的文字</li></ul></li></ul><p>Decomposing Formulas into Sets of Literals</p><ul><li>$A&#x3D;p\land{(\lnot{q}\lor{\lnot{p}})}$ &#x3D;&gt; literal&#x3D;{p,¬ q}</li></ul><p>求解规则</p><ol><li>拆分</li></ol><center><img loading="lazy" src="/posts/cacbbbdb/10.png" wid="550px"></center><ol start="2"><li>A set of literals is satisfiable if and only if it does not contain a complementary pair of literals<ol><li>一个文字集是可满足的，当且仅当它不包含一对互补的文字的时候</li><li>在上面的例子中{p,¬ p}因此被排除</li></ol></li></ol><blockquote><p>（另一个例子）Both sets of literals {p,¬ p,¬ q} and {q,¬ p,¬ q} contain complementary pairs, so by Theorem 2.60, both set of literals are unsatisfiable. We conclude that it is impossible to find a model for B; in other words, B is unsatisfiable</p></blockquote><h3 id="Construction-of-Semantic-Tableaux"><a href="#Construction-of-Semantic-Tableaux" class="headerlink" title="Construction of Semantic Tableaux"></a>Construction of Semantic Tableaux</h3><blockquote><p>The initial formula labels the root of the tree; each node has one or two child nodes depending on how a formula labeling the node is decomposed. The leaves are labeled by the sets of literals. A leaf labeled by a set of literals containing a complementary pair of literals is marked ×, while a leaf labeled by a set not containing a complementary pair is marked ⊙</p><ul><li>初始公式标注为树的根部；</li><li>每个节点有一个或两个子节点，取决于标注节点的公式是如何分解的。</li><li>叶子是由文字集标记的。由包含互补对的文字集标注的叶子被标记为<code>×</code>（也就是closed），而由不包含互补对的文字集标注的叶子被标记为<code>⊙</code>(也就是open)</li></ul></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/11.gif" wid="550px"></center><ul><li>The tableau construction is not unique; here is another tableau for B</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/12.gif" wid="550px"></center><ul><li>α-formulas are conjunctive and are satisfiable only if both subformulas $α_1$ and $α_2$ are satisfied </li><li>β-formulas are disjunctive and are satisfied even if only one of the subformulas $β_1$ or $β_2$ is satisfiable</li></ul><blockquote><p>The formula p∧q is classified as an α-formula because it is true if and only if both p and q are true. The formula ¬ (p∧q) is classified as a β-formula. It is logically equivalent to ¬ p∨¬ q and is true if and only if either ¬ p is true or ¬ q is true.</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/13.gif" wid="550px"></center><p>构建语义表的算法</p><center><img loading="lazy" src="/posts/cacbbbdb/14.png" wid="550px"></center><ul><li>A <strong>completed tableau</strong> is closed if all its leaves are marked closed. Otherwise (if some leaf is marked open), it is open</li></ul><h2 id="Soundness-and-Completeness-可靠性和完备性"><a href="#Soundness-and-Completeness-可靠性和完备性" class="headerlink" title="Soundness and Completeness 可靠性和完备性"></a>Soundness and Completeness 可靠性和完备性</h2><ul><li>We need to prove that the algorithm for semantic tableaux is sound and complete as a decision procedure for satisfiability</li><li>** Soundness means that you cannot prove anything that’s wrong. Completeness means that you can prove anything that’s right**<blockquote><ul><li>Soundness is the property of only being able to prove “true” things.</li><li>Completeness is the property of being able to prove all true things.<br>So a given logical system is sound if and only if the inference rules of the system admit only valid formulas. Or another way, if we start with valid premises, the inference rules do not allow an invalid conclusion to be drawn.</li></ul><p>A system is complete if and only if all valid formula can be derived from the axioms and the inference rules. So there are no valid formula that we can’t prove</p></blockquote></li></ul><h3 id="Soundness"><a href="#Soundness" class="headerlink" title="Soundness"></a>Soundness</h3><p>The theorem to be proved is: if the tableau  for a formula A closes, then A is unsatisfiable.</p><ul><li>if $T_n$, the subtree rooted at node n of $T$, closes then the set of formulas U(n) labeling n is unsatisfiable</li></ul><h3 id="Completeness"><a href="#Completeness" class="headerlink" title="Completeness"></a>Completeness</h3><p>if A is unsatisfiable then every tableau for A closes</p><ul><li>let A&#x3D;p∨(q∧¬ q)</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/20.gif" wid="550px"></center><blockquote><p>The open branch of the tableau terminates in a leaf labeled with the singleton set of literals ${p}$. We can conclude that any model for A must define $I(p)&#x3D;T$. However, an interpretation for A must also define an assignment to q and the leaf gives us no guidance as to which value to choose for $I(q)$. But it is obvious that it doesn’t matter what value is assigned to q; in either case, the interpretation will be a model of A</p></blockquote><h2 id="formula-in-propositonal-logic"><a href="#formula-in-propositonal-logic" class="headerlink" title="formula in propositonal logic"></a>formula in propositonal logic</h2><p>一种说法</p><blockquote><p>In propositional logic there are no formulæ. There are only atomic and compound propositions.</p></blockquote><ul><li>The atomic propositions are the propositional variables, often written as A,B,C,etc</li><li>Compound propositions are formed using atomic propositions and logical connectives. These connectives include things like not, implies, and, or, etc.<blockquote><p>It is only in first order logic that we need the notion of formulæ. This is because in first order logic, we don’t only consider propositions but also ‘objects’ and predicates on ‘objects’. First Order logic includes a sub-language to express these ‘objects’ and operations on these ‘objects’.</p></blockquote></li></ul><p>符合教材的说法是</p><ul><li>公式可以正确的，也可以是<strong>错误的</strong>（在语法与语义上？）</li><li>但命题一定是一个格式正确的公式 ，在命题逻辑中，这意味着它既是由逻辑在句法上定义的，又具有用于其语义评估的真值表。<ul><li>语法定义了哪些符号串构成合法的公式（就语言而言是合法的程序）</li><li>而语义定义了合法公式的含义（合法程序的计算）<ul><li>语义表时检测公式是否为真的有效的决策程</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Logic formalizes valid methods of reasoning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逻辑将有效的推理方法正规化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比如syllogism&amp;#x2F;ˈsɪləˌdʒɪz(ə)m&amp;#x2F;三段论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;atomic&lt;code&gt;/əˈtɒm.ɪk/&lt;/code&gt; proposition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statements that have no internal structure&lt;/li&gt;
&lt;li&gt;原子命题是没有内部结构的语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cannot be further decomposed&lt;/code&gt; and &lt;code&gt;can be assigned a truth value of true or false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;often shortened to &lt;strong&gt;atoms&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;define the legal structure of formulas in propositional logic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;semantics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the meaning of formulas&lt;ul&gt;
&lt;li&gt;T or F&lt;/li&gt;
&lt;li&gt;Another notation is &lt;code&gt;⊤&lt;/code&gt; for true and &lt;code&gt;⊥&lt;/code&gt; for false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A proof is a deduction of a formula from a set of formulas called &lt;strong&gt;axioms&lt;/strong&gt; using rules of inference.&lt;/li&gt;
&lt;li&gt;证明是&lt;strong&gt;利用推理规则&lt;/strong&gt;从一组称为&lt;strong&gt;公理&lt;/strong&gt;的公式中推导出一个&lt;strong&gt;公式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Propositional logic is central to the design of computer hardware because hardware is usually designed with components having two voltage levels that are arbitrarily assigned the symbols 0 and 1. Circuits&lt;code&gt;/ˈsərkət/&lt;/code&gt; are described by idealized elements called logic gates&lt;/p&gt;
&lt;p&gt;命题逻辑是计算机硬件设计的核心，因为硬件的设计通常有两个电压电平，被任意分配为符号0和1。电路由称为逻辑门的理想化元素描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cacbbbdb/15.png&quot; wid=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Propositional-Formulas命题公式&quot;&gt;&lt;a href=&quot;#Propositional-Formulas命题公式&quot; class=&quot;headerlink&quot; title=&quot;Propositional Formulas命题公式&quot;&gt;&lt;/a&gt;Propositional Formulas命题公式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;expression&lt;/strong&gt; 表达式&lt;ul&gt;
&lt;li&gt;denoted the computation of a value from other values&lt;/li&gt;
&lt;li&gt;表示从其他数值中计算出一个数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In propositional logic, the term formula is used instead&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;atomic propositions &lt;ul&gt;
&lt;li&gt;An unbounded set of symbols P&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boolean operators&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;subformulas&quot;&gt;&lt;a href=&quot;#subformulas&quot; class=&quot;headerlink&quot; title=&quot;subformulas&quot;&gt;&lt;/a&gt;subformulas&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cacbbbdb/22.jpg&quot; wid=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;Formulas-as-Trees&quot;&gt;&lt;a href=&quot;#Formulas-as-Trees&quot; class=&quot;headerlink&quot; title=&quot;Formulas as Trees&quot;&gt;&lt;/a&gt;Formulas as Trees&lt;/h3&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>软件安全备忘录：Fundamentals</title>
    <link href="https://hejueyun.github.io/posts/a3244b40/"/>
    <id>https://hejueyun.github.io/posts/a3244b40/</id>
    <published>2022-01-31T20:12:07.000Z</published>
    <updated>2022-02-05T23:00:01.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Main-Goal"><a href="#Main-Goal" class="headerlink" title="Main Goal"></a>Main Goal</h2><p>Verified trustworthy software systems 经过验证的值得信赖的软件系统</p><ul><li>Reliability</li><li>Availability</li><li>Safty</li><li>Resilience 复原能力<ul><li>in timely response to events</li></ul></li></ul><h2 id="Standard-Notions-of-Security-安全的标准概念"><a href="#Standard-Notions-of-Security-安全的标准概念" class="headerlink" title="Standard Notions of Security 安全的标准概念"></a>Standard Notions of Security 安全的标准概念</h2><p>Safety vs Security</p><ul><li>Safety: <code>any input</code> &#x3D;&gt; <code>desired output</code></li><li>Secruity: <code>bad input</code> &#x3D;&gt; <code>bad output</code><ul><li>wrong input does not cause failure or crashes</li></ul></li></ul><p>most sofeware system do not have precise准确 explict明确 security objectives</p><h2 id="Software-Security-Problems"><a href="#Software-Security-Problems" class="headerlink" title="Software Security Problems"></a>Software Security Problems</h2><center><img loading="lazy" src="/posts/a3244b40/1.png" width="550"></center><p>Why are there security vulnerabilities?</p><ul><li>Limited number of <strong>courses</strong> in computer security<br>– Programming <strong>textbooks</strong> do not emphasize security<br>– Limited number of security <strong>audits</strong><br>– <strong>Programmers</strong> are focused on implementing features<br>– Security is <strong>expensive</strong> and takes <strong>time</strong></li></ul><p>cve</p><ul><li>Common Vulnerabilities and Exposures 公共漏洞和暴露 <blockquote><p>公共漏洞和暴露又称通用漏洞披露、常见漏洞与披露，是一个与信息安全有关的数据库，收集各种信息安全弱点及漏洞并给予编号以便于公众查阅。此数据库现由美国非营利组织MITRE所属的National Cybersecurity FFRDC所营运维护</p></blockquote></li></ul><h3 id="Critical-Software-Vulnerabilitie"><a href="#Critical-Software-Vulnerabilitie" class="headerlink" title="Critical Software Vulnerabilitie"></a>Critical Software Vulnerabilitie</h3><ul><li><strong>Null pointer dereference</strong><ul><li>dereference 解引用<ul><li>“*”（即星号），是一个单项操作符（即有一个操作数）</li><li>它对一个指针变量进行操作，并返回一个指针地址的值</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/a3244b40/2.png" width="550"></center><ul><li><strong>Double free</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/3.png" width="550"></center><ul><li><strong>Unchecked Return Value to NULL Pointer Dereference</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/4.png" width="550"></center><ul><li>Division by zero</li><li>Missing free</li><li>Use after free</li><li>APIs rule based checking</li><li><strong>Race Condition Vulnerability</strong> 竞争条件漏洞</li><li>Structured output generation vulnerabilitie<ul><li>SQL Injection</li></ul></li><li>XSS</li><li>XXE <ul><li>XML External Entity (XXE) </li><li>XXE occurs when XML input (incl. an external entity) is processed by a weakly configured XML parser</li><li>XXE might lead to the disclosure披露 of confidential data</li></ul></li></ul><center><img loading="lazy" src="/posts/a3244b40/5.png" width="550"></center><ul><li>DoS</li></ul><h2 id="testing-and-verification-techniques"><a href="#testing-and-verification-techniques" class="headerlink" title="testing and verification techniques"></a>testing and verification techniques</h2><h3 id="proof-by-induction-数学归纳法"><a href="#proof-by-induction-数学归纳法" class="headerlink" title="proof by induction 数学归纳法"></a>proof by induction 数学归纳法</h3><ul><li>base step</li><li>inductice step</li></ul><h3 id="Temporal-Logic-Model-Checking-时态逻辑模型检查"><a href="#Temporal-Logic-Model-Checking-时态逻辑模型检查" class="headerlink" title="Temporal Logic Model Checking 时态逻辑模型检查"></a>Temporal Logic Model Checking 时态逻辑模型检查</h3><p>2 branches of verification</p><ul><li>deductive 演绎式</li><li>Model checking<ul><li>可以automatic</li></ul></li></ul><p>Verification procedure is algorithmic rather than deductive in nature</p><ul><li>验证程序是算法性的，而不是演绎性的</li></ul><p><code>Model checking</code></p><ul><li>an automatic verification technique for <strong>finite state concurrent systems</strong>并发系统<ul><li>模型检查是一种<strong>有限状态并发系统</strong>的自动验证技术</li></ul></li><li>Advantages<ul><li><strong>No proofs</strong>(Algorithmic rather than Deductive)</li><li><strong>Fast</strong> (compared to other rigorous methods such as theorem proving) 与其他严格的方法相比，如定理证明</li><li>Diagnostic <strong>counterexamples</strong> 诊断性反例</li><li>No problem with <strong>partial specifications</strong> 部分规格</li><li>Logics can easily express many <strong>concurrency properties</strong> 逻辑学可以很容易地表达许多并发性属性</li></ul></li></ul><h4 id="LTL-Linear-Time-Logic"><a href="#LTL-Linear-Time-Logic" class="headerlink" title="LTL - Linear Time Logic"></a>LTL - Linear Time Logic</h4><ul><li>Atomic Propositions 原子命题</li><li>Temporal operators 时间运算符</li></ul><center><img loading="lazy" src="/posts/a3244b40/6.png" width="550"></center><center><img loading="lazy" src="/posts/a3244b40/7.png" width="550"></center><h4 id="Model-Checking-Problem"><a href="#Model-Checking-Problem" class="headerlink" title="Model Checking Problem"></a>Model Checking Problem</h4><ul><li><code>M</code><ul><li>Let M be a state-transition graph</li></ul></li><li><code>f</code><ul><li>Let ƒ be an assertion or specification in temporal logic</li></ul></li><li><code>s</code><ul><li>Find all states s of M such that M, s satisfies ƒ</li></ul></li></ul><p><strong>Complexity</strong></p><ul><li><strong>singly exponential</strong> in size of specification 与规格大小呈单指数关系</li><li><strong>linear</strong> in size of state-transition graph 与状态转换图的大小呈线性关系</li></ul><center><img loading="lazy" src="/posts/a3244b40/8.png" width="550"></center><h3 id="Bounded-Model-Checking-BMC-有界模型检查"><a href="#Bounded-Model-Checking-BMC-有界模型检查" class="headerlink" title="Bounded Model Checking(BMC) 有界模型检查"></a>Bounded Model Checking(BMC) 有界模型检查</h3><p>Basic idea: check negation of given property up to given depth</p><center><img loading="lazy" src="/posts/a3244b40/9.png" width="550"></center><ul><li><code>iff</code>: if and only if 当且仅当</li><li><code>Negation</code>: 逻辑非</li></ul><blockquote><p>有界模型检测的主要过程是:先把要验证的系统或模型构造为有限状态自动机(finite state machine,简称FSM),通过 FSM 状态间的转移来模拟系统或模型运行;要验证的规范说明用时序逻辑 LTL(linear-time temporal logic)进行说明(如 G(p),F(p));设定边界上界 K;FSM 状态间的转移关系和 LTL 逻辑规范否定的 NNF(negation normal form)公式通过逻辑与构成 BMC 转换公式;把 BMC 转换公式编码成 SAT 实例,通过 SAT 工具求解.若有解,则找到反例;反之,若不可满足,则表明要验证的系统或模型运行到 K 阶段时,是安全的、没有错误的</p></blockquote><h4 id="LTL-语法"><a href="#LTL-语法" class="headerlink" title="LTL 语法"></a>LTL 语法</h4><ul><li>设原子命题的集合为 A<ul><li>若ϕ∈A,则ϕ是 LTL 公式.</li><li>若ϕ和φ是 LTL 公式,则¬ϕ,ϕ∧φ,ϕ∨φ,ϕ→φ,Gϕ,Fϕ,Xϕ,ϕUφ,ϕRφ等是 LTL 公式.<ul><li>X,G,F,U,R 分别表示下一个(next),全部(global),最终(eventually),直到…全(until),直到…有(release)等模态词- ¬,∧,∨,→等符号称为连接词</li></ul></li></ul></li></ul><blockquote><p>因为主要是通过 BMC 找反例,因此 BMC 实际处理的是 LTL 规范的否定形式.LTL 规范的否定形式要表示为 NNF(negative normal form)形式的 LTL 公式(简称 NNF 公式).NNF 公式是不包含→连接词,且否定词只能出现在原子命题前的 LTL 公式</p><p>若 f 为 LTL 公式,则 depth(f)为 f 的深度,即 f 中模态词的嵌套层数.</p></blockquote><p><strong>Modal logic模态逻辑</strong></p><blockquote><p>Modal logic is a collection of formal systems developed to represent statements about necessity and possibility</p><p>模态逻辑是一个形式化系统的集合，用来表示关于必然性和可能性的声明</p></blockquote><h4 id="BMC的克里普克结构-Kripke-structure"><a href="#BMC的克里普克结构-Kripke-structure" class="headerlink" title="BMC的克里普克结构(Kripke structure)"></a>BMC的克里普克结构(Kripke structure)</h4><blockquote><p>BMC 的克里普克结构(Kripke structure)为一四元组 M＝(S,I,T,ℓ),其中,S 为 BMC 中 FSM 产生的所有状态集合;I⊆S,I 为初时状态的集合;T⊆S×S,T 为状态间转移关系的集合;ℓ:S→P(A),为标注状态的函数.</p></blockquote><h4 id="LTL-语义"><a href="#LTL-语义" class="headerlink" title="LTL 语义"></a>LTL 语义</h4><center><img loading="lazy" src="/posts/a3244b40/10.png" width="550"></center><h3 id="Satisfiability-Modulo-Theories-可满足性模数理论"><a href="#Satisfiability-Modulo-Theories-可满足性模数理论" class="headerlink" title="Satisfiability Modulo Theories 可满足性模数理论"></a>Satisfiability Modulo Theories 可满足性模数理论</h3><blockquote><p>SMT decides the satisfiability of first-order logic formulae using the combination of different background theories</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Main-Goal&quot;&gt;&lt;a href=&quot;#Main-Goal&quot; class=&quot;headerlink&quot; title=&quot;Main Goal&quot;&gt;&lt;/a&gt;Main Goal&lt;/h2&gt;&lt;p&gt;Verified trustworthy software systems 经过验证的值得信赖的软件系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reliability&lt;/li&gt;
&lt;li&gt;Availability&lt;/li&gt;
&lt;li&gt;Safty&lt;/li&gt;
&lt;li&gt;Resilience 复原能力&lt;ul&gt;
&lt;li&gt;in timely response to events&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Standard-Notions-of-Security-安全的标准概念&quot;&gt;&lt;a href=&quot;#Standard-Notions-of-Security-安全的标准概念&quot; class=&quot;headerlink&quot; title=&quot;Standard Notions of Security 安全的标准概念&quot;&gt;&lt;/a&gt;Standard Notions of Security 安全的标准概念&lt;/h2&gt;&lt;p&gt;Safety vs Security&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safety: &lt;code&gt;any input&lt;/code&gt; &amp;#x3D;&amp;gt; &lt;code&gt;desired output&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Secruity: &lt;code&gt;bad input&lt;/code&gt; &amp;#x3D;&amp;gt; &lt;code&gt;bad output&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;wrong input does not cause failure or crashes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;most sofeware system do not have precise准确 explict明确 security objectives&lt;/p&gt;
&lt;h2 id=&quot;Software-Security-Problems&quot;&gt;&lt;a href=&quot;#Software-Security-Problems&quot; class=&quot;headerlink&quot; title=&quot;Software Security Problems&quot;&gt;&lt;/a&gt;Software Security Problems&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3244b40/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;Why are there security vulnerabilities?&lt;/p&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Software Security" scheme="https://hejueyun.github.io/categories/Security/Software-Security/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>软件工程基础-软件质量与其他</title>
    <link href="https://hejueyun.github.io/posts/3ff63edb/"/>
    <id>https://hejueyun.github.io/posts/3ff63edb/</id>
    <published>2022-01-24T23:40:00.000Z</published>
    <updated>2022-01-26T12:04:43.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Software-Quality"><a href="#Software-Quality" class="headerlink" title="Software Quality"></a>Software Quality</h2><h3 id="Desirable-Software-Quality-理想的软件质量"><a href="#Desirable-Software-Quality-理想的软件质量" class="headerlink" title="Desirable Software Quality(理想的软件质量)"></a>Desirable Software Quality(理想的软件质量)</h3><ul><li>External characteristics： External characteristics are characteristics that a user of the software product is aware of</li><li>Internal : developer directly experience</li></ul><p><strong>联系</strong></p><blockquote><p>The difference between internal and external characteristics isn’t completely clear-cut because at some level internal characteristics affect external ones. Software that isn’t internally understandable or maintainable impairs your ability to correct defects, which in turn affects the external characteristics of correctness and reliability. Software that isn’t flexible can’t be enhanced in response to user requests, which in turn affects the external characteristic of usability.</p></blockquote><center><img loading="lazy" src="/posts/3ff63edb/2.png" width="450px"></center><p>External characteristics：</p><ul><li>Correctness<ul><li>一个系统在其规格、设计和实现中没有错误的程度</li></ul></li><li>Usability<ul><li>用户学习和使用一个系统的容易程度</li></ul></li><li>Efficiency<ul><li>对系统资源的最小化使用，包括<strong>内存和执行时间</strong></li></ul></li><li>Reliability<ul><li> 一个系统在规定的条件下，无论何时都能执行所需功能的能力–<strong>具有较长的平均故障间隔时间</strong>( a long mean time between failures)</li></ul></li><li>Integrity<ul><li>完整性的概念包括<strong>限制未经授权的用户访问</strong>，以及<strong>确保数据被正确访问</strong></li></ul></li><li>Adaptability<ul><li>一个系统在没有修改的情况下，可以在其专门设计之外的应用或环境中使用的程度</li></ul></li><li>Accuracy<ul><li>精确性与正确性不同；它决定了一个系统在多大程度上完成了它所构建的工作(而不是关注错误)</li></ul></li><li>Robustness<ul><li>一个系统在无效的输入或紧张的环境条件下继续运行的程度</li></ul></li></ul><p>internal quality characteristics：</p><ul><li>Maintainability<ul><li>你可以修改一个软件系统以改变或增加功能、提高性能或纠正缺陷的容易程度<blockquote><p><strong>The ease with</strong> which you can modify a software system to change or add capabilities, improve performance, or correct defects</p></blockquote></li></ul></li><li>Flexibility <ul><li>可以修改一个系统的用途或环境的程度，而不是它的专门设计</li></ul></li><li>Portability<ul><li>你可以修改一个系统以在不同于其专门设计的环境中运行的容易程度</li></ul></li><li>Reusability<ul><li>你可以在其他系统中使用一个系统的部分的程度和容易程度</li></ul></li><li>Readability<ul><li>你能够阅读和理解一个系统的源代码的难易程度</li></ul></li><li>Testability<ul><li>你可以对一个系统进行单元测试和系统测试的程度；你可以<strong>验证该系统满足其要求的程度</strong></li></ul></li><li>Understandability<ul><li>在系统-组织和详细陈述层面上，你能理解一个系统的难易程度。<strong>与可读性相比，可理解性与系统在更一般的层面上的一致性有关</strong></li><li><strong>Readability is part of understandability</strong>. But you can have readable methods or functions and an impossible to grasp architecture</li></ul></li></ul><hr><center><img loading="lazy" src="/posts/3ff63edb/1.png" width="400px"></center><ul><li><strong>最大化某些特征的尝试不可避免地与最大化其他特征的尝试相冲突。从一组相互竞争的目标中找到一个最佳解决方案，是使软件开发成为真正的工程学科的一项活动。</strong></li><li><strong>专注于一个特定的特征并不总是意味着要与另一个特征进行交换。有时一个会伤害另一个，有时会帮助另一个，有时既不伤害也不帮助另一个</strong> Focusing on one external characteristic of software quality can affect other characteristics positively, adversely, or not at all</li></ul><h3 id="Techniques-for-Improving-Software-Quality（提高软件质量的方法）"><a href="#Techniques-for-Improving-Software-Quality（提高软件质量的方法）" class="headerlink" title="Techniques for Improving Software Quality（提高软件质量的方法）"></a>Techniques for Improving Software Quality（提高软件质量的方法）</h3><h4 id="Setting-Objectives"><a href="#Setting-Objectives" class="headerlink" title="Setting Objectives"></a>Setting Objectives</h4><blockquote><p>One powerful technique for improving software quality is setting explicit quality objectives from among the <strong>external</strong> and <strong>internal</strong> characteristics described in the previous section</p><p>Explicit quality-assurance activity.</p><ul><li>Making the quality-assurance activity explicit makes the priority clear, and programmers will respond accordingly.</li></ul></blockquote><h4 id="Development-Process"><a href="#Development-Process" class="headerlink" title="Development Process"></a>Development Process</h4><ul><li><strong>Change-control procedures</strong><ul><li>One big obstacle to achieving software quality is uncontrolled changes. Uncontrolled requirements changes can result in disruption to design and coding. Uncontrolled changes in design can result in code that doesn’t agree with its requirements, inconsistencies in the code, or more time spent modifying code to meet the changing design than spent moving the project forward. 实现软件质量的一个大障碍就是不受控制的变更。不受控制的需求变更会导致设计和编码的中断。不受控制的设计变更会导致代码与需求不一致，代码中的不一致，或者花在修改代码以满足不断变化的设计上的时间比花在推进项目上的时间多</li></ul></li><li><strong>Measurement of results</strong><ul><li>除非对质量保证计划的结果进行测量，否则你将无法知道该计划是否有效</li></ul></li><li><strong>Prototyping</strong><ul><li>Prototyping is the development of realistic models of a system’s key functions. A developer can prototype parts of a user interface to determine usability, critical calculations to determine <strong>execution time</strong>, or typical data sets to determine <strong>memory requirements</strong>. 原型验证是对系统关键功能的现实模型的开发。开发者可以对用户界面的一部分进行原型开发以确定可用性，对关键计算进行原型开发以确定执行时间，或对典型数据集进行原型开发以确定内存需求。</li></ul></li></ul><h3 id="不同质量保证的方法的有效性"><a href="#不同质量保证的方法的有效性" class="headerlink" title="不同质量保证的方法的有效性"></a>不同质量保证的方法的有效性</h3><blockquote><p>这个数据所揭示的最有趣的事实是，任何一种技术的模态率都没有超过75%，各种技术平均约为40%。此外，对于最常见的缺陷检测–单元测试和集成测试–模式率只有30-35%。典型的组织使用重测试的缺陷清除方法，只能达到约85%的缺陷清除效率。领先的组织使用更广泛的技术，实现了95%或更高的缺陷清除效率。</p><p>如果项目开发人员要争取更高的缺陷发现率，他们需要使用多种技术组合（if project developers are striving for a higher defect detection rate, they need to use a combination of techniques）</p></blockquote><p>Cost of Finding Defects发现漏洞的成本</p><ul><li>Most studies have found that <strong>inspection</strong>s are cheaper than <strong>testing</strong>. A study at the Software Engineering Laboratory found that <strong>code reading</strong> detected about 80 percent more faults per hour than <strong>testing</strong><br>Cost of Fixing Defects</li><li>the longer a defect remains in the system, the more expensive it becomes to remove. A detection technique that finds the error earlier therefore results in a lower cost of fixing it</li></ul><p>Here’s a recommended combination for achieving higher-than-average quality:</p><ul><li>Formal inspections of all requirements, all architecture, and designs for critical parts of a system</li><li>Modeling or prototyping</li><li>Code reading or inspections</li><li>Execution testing</li></ul><h3 id="When-to-Do-Quality-Assurance"><a href="#When-to-Do-Quality-Assurance" class="headerlink" title="When to Do Quality Assurance"></a>When to Do Quality Assurance</h3><blockquote><p>the earlier an error is inserted into software, the more entangled it becomes in other parts of the software and the more expensive it becomes to remove. </p></blockquote><ul><li>一个错误越早插入软件，它在软件其他部分的纠缠就越多，消除它的代价就越大。需求中的错误会在设计中产生一个或多个相应的错误，而设计中的错误又会在代码中产生许多相应的错误。一个需求错误会导致额外的架构或错误的架构决策。额外的架构会导致额外的代码、测试用例和文档。或者一个需求错误会导致架构、代码和测试用例被丢弃</li><li><strong>Defects creep into software at all stages</strong><ul><li>质量保证工作应当在每一构建环节都介入 </li><li> It should be planned into the project as work begins; </li><li> it should be part of the technical fiber of the project as work continues; </li><li> and it should punctuate the end of the project, verifying the quality of the product as work ends.</li></ul></li></ul><h3 id="The-General-Principle-of-Software-Quality"><a href="#The-General-Principle-of-Software-Quality" class="headerlink" title="The General Principle of Software Quality"></a>The General Principle of Software Quality</h3><blockquote><p><strong>The General Principle of Software Quality is that improving quality reduces development costs.</strong></p></blockquote><ul><li>这个原则本质上也是个“悖论”paradox</li><li>提高生产力和质量的最好方法是减少代码返工的时间，无论返工是由于需求的变化、设计的变化还是调试的变化</li><li>Compared to the traditional <code>code-test-debug</code> cycle, an enlightened software-quality program saves money</li></ul><img loading="lazy" src="/posts/3ff63edb/11.png" width="550"><blockquote><p>the best way to improve productivity and quality is to reduce the time spent reworking code, whether the rework arises from changes in requirements, changes in design, or debugging. The industry-average productivity for a software product is about 10 to 50 of lines of delivered code per person per day (including all noncoding overhead). It takes only a matter of minutes to type in 10 to 50 lines of code</p></blockquote><img loading="lazy" src="/posts/3ff63edb/9.png" width="550"><ul><li>你是否考虑过一些特性可能与其他特性竞争或互补的方式？</li></ul><h3 id="key-points"><a href="#key-points" class="headerlink" title="key points"></a>key points</h3><ol><li>Quality is free, in the end, but it requires a reallocation of resources so that <strong>defects are prevented cheaply instead of fixed expensively</strong>.</li><li>Not all quality-assurance goals are simultaneously achievable. Explicitly decide which goals you want to achieve, and communicate the goals to other people on your team.</li><li>No single defect-detection technique is completely effective by itself. Testing by itself is not optimally effective at removing errors. Successful quality-assurance programs use several different techniques to detect different kinds of errors.</li><li>You can apply effective techniques during construction and many equally powerful techniques before construction. The earlier you find a defect, the less intertwined it will become with the rest of your code and the less damage it will cause.</li><li>Quality assurance in the software arena is process-oriented. Software development doesn’t have a repetitive phase that affects the final product like manufacturing does, so the quality of the result is controlled by the process used to develop the software.</li></ol><hr><h2 id="Intellectual-Property-知识产权"><a href="#Intellectual-Property-知识产权" class="headerlink" title="Intellectual Property 知识产权"></a>Intellectual Property 知识产权</h2><blockquote><p>Intellectual property is any articulable, tangible production of a mind whose physical realisations are restricted by law (e.g., in distribution)</p><p>知识产权是任何可阐明的、有形的思想成果，其物质实现受到法律的限制（例如，在分销方面）。</p><hr><p>Copyright is a licensable monopoly of the tangible expression of an idea with respect to reproduction, derivation, display，distribution, and the like.</p><p>版权是对思想的有形表达在复制、衍生、展示、传播等方面的一种可授权的垄断。</p></blockquote><h2 id="程序等价"><a href="#程序等价" class="headerlink" title="程序等价"></a>程序等价</h2><ul><li>如果我们无法区分两个程序（在某种程度上），那么这两个程序就是等价的（以这种方式）。</li><li>Two programs are functionally equivalent just in case they implement exactly the same <strong>functionality</strong>.</li><li>if two programs are <strong>behaviourly</strong> equivalent then they are functionally equivalent.</li><li>这里将等价性定义为“给定相同合法输入，有相同输出”</li></ul><h2 id="Managing-Construction"><a href="#Managing-Construction" class="headerlink" title="Managing Construction"></a>Managing Construction</h2><h3 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h3><ol><li>Good coding practices can be achieved either through enforced standards or through more light-handed approaches.<ol><li>Encouraging Good Coding</li></ol></li><li>Configuration management, when properly applied, makes programmers’ jobs easier. This especially includes change control.<ol><li><strong>Configuration management is the practice of identifying project artifacts and handling changes systematically so that a system can maintain its integrity over time. Another name for it is “change control.”</strong> It includes techniques for evaluating proposed changes, tracking changes, and keeping copies of the system as it existed at various points in time.</li><li>Software Code Changes、Tool Versions、Machine Configurations、Backup</li></ol></li><li>Good software estimation is a significant challenge. Keys to success are using multiple approaches, tightening down your estimates as you work your way into the project, and making use of data to create the estimates.<ol><li>Use estimating software、algorithmic approach、Have a walk-through meeting for estimates</li></ol></li><li>Measurement is a key to successful construction management. You can find ways to measure any aspect of a project that are better than not measuring it at all. Accurate measurement is a key to accurate scheduling, to quality control, and to improving your development process.</li><li>Programmers and managers are people, and they work best when treated as such</li></ol><h2 id="character"><a href="#character" class="headerlink" title="character"></a>character</h2><ol><li>our personal character directly affects your ability to write computer programs.</li><li>The characteristics that matter most are humility, curiosity, intellectual honesty, creativity and discipline, and enlightened laziness.</li><li>The characteristics of a superior programmer have almost nothing to do with talent and everything to do with a commitment to personal development.</li><li>Surprisingly, raw intelligence, experience, persistence, and guts hurt as much as they help.</li><li>Many programmers don’t actively seek new information and techniques and instead rely on accidental, on-the-job exposure to new information. If you devote a small percentage of your time to reading and learning about programming, after a few months or years you’ll dramatically distinguish yourself from the programming mainstream.</li><li>Good character is mainly a matter of having the right habits. To be a great programmer, develop the right habits and the rest will come naturally.</li></ol><h2 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h2><ul><li>The unit cost diminishes as the number of units increases<ul><li>So focus on lines of code or bits of functionality</li></ul></li><li><strong>Cost Ratios</strong><ul><li>Before deployment (aka submission)<ul><li>Small fixes are cheap</li></ul></li><li>After deployment (aka submission)<ul><li>Even “small” fixes are expensive (or impossible)</li></ul></li><li>Strategies<ul><li>Avoid late bugs</li><li>Make fixing late bugs cheaper</li></ul></li></ul></li><li>The General <strong>Principle</strong> of Software Quality is that improving quality reduces development costs</li></ul><center><img loading="lazy" src="/posts/3ff63edb/3.png" width="450px"></center><h3 id="Trade-Offs"><a href="#Trade-Offs" class="headerlink" title="Trade-Offs"></a>Trade-Offs</h3><ul><li> Time for Space (and the reverse)</li><li> Performance for Readability (and the reverse)</li></ul><h3 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h3><ul><li>Buy More and Faster Hardware</li><li>Use the Optimiser</li><li>Better compilers/frameworks/libraries</li></ul><h3 id="Technical-Debt"><a href="#Technical-Debt" class="headerlink" title="Technical Debt"></a>Technical Debt</h3><blockquote><p>In software development, technical debt (also known as design debt or code debt) is the implied** cost of additional rework** caused by <strong>choosing an easy(limited) solution</strong> now instead of using a <strong>better approach that would take longer</strong></p><p>技术负债（英语：Technical debt），又译技术债，也称为设计负债（design debt）、代码负债（code debt），是程序设计及软件工程中的一个比喻。指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。 </p></blockquote><ul><li>如果我们等待，就会产生利息<ul><li>我们写的测试越多，以后要改的测试就越多</li><li>可能会导致更对债务</li></ul></li></ul><p>Intentional Vs Unintentional Debt<br>无意的债务==意外的或偶然的</p><ul><li>我们可能不知道我们产生了它!</li><li>我们可能不知道有利息！<br>故意的债务 == 故意的，有意识地产生的</li><li>需要一个可识别的理由（identifiable rationale）</li><li>有一个范围</li></ul><p>为什么负债</p><ul><li><p>Short-Term Debt</p><ul><li>战术原因 Tactical reasons</li></ul></li><li><p>Long-Term Debt</p><ul><li>战略原因 Strategic reasons</li></ul></li><li><p><strong>重构是还债最常见的方式</strong></p></li><li><p>其余还包括增加测试用例等</p></li></ul><h2 id="Managing-Complexity"><a href="#Managing-Complexity" class="headerlink" title="Managing Complexity"></a>Managing Complexity</h2><h3 id="No-silver-bullet"><a href="#No-silver-bullet" class="headerlink" title="No silver bullet"></a>No silver bullet</h3><p>The complexities of software systems lead to difficulties in both accident and essence. According to Brooks, the accidental complexities are largely caused by artificial barriers, including poor programming skills, severe hardware constraints and lack of machine time. On the contrary, the essential complexities, inherent in the nature of the software, are reflected by the hardship of composing the abstract software entity, including specification, design and testing of the conceptual construct, rather than the labour of actual construction.</p><p>What is highlighted in Brooks’ essay is that no once-and-for-all solution to remove the complexity of the software, thus “no silver bullet”. From the aspect of accidental complexities, although problems can be considerably alleviated by the high-level language, time-sharing and unified programming environment, it is impossible to avoid “accidents”, particularly when products increase with size. From the aspect of accidental complexities, the inherent properties of modern software systems determine the difficulty of finding a solution, as technologies that are advanced as potential “silver bullet” yet mostly remain problem-specific. An artificial intelligence implement of computer images, for example, cannot easily transfer to different programming practices. </p><p>However, there are some promising attacks, raised by Brooks, on the conceptual essence. These contain the principles of buy rather than build, rapid prototyping of system and cautious design. </p><p>In general, considering the shrinking marginal benefit of reducing accidents, and the inherent complexity of software systems, finding “silver bullets” to minimize complexity remains challenging yet possible.</p><hr><p>Brooks observes that the major accidental difficulties in software were addressed long ago. For example, accidental difficulties related to clumsy language syntaxes were largely eliminated in the evolution from assembly language to third-generation languages and have declined in significance incrementally since then. Accidental difficulties related to noninteractive computers were resolved when time-share operating systems replaced batch-mode systems. Integrated programming environments further eliminated inefficiencies in programming work arising from tools that worked poorly together.</p><p>Brooks argues that progress on software’s remaining essential difficulties is bound to be slower. The reason is that, at its essence, software development consists of working out all the details of a highly intricate, interlocking set of concepts. The essential difficulties arise from the necessity of interfacing with the complex, disorderly real world; accurately and completely identifying the dependencies and exception cases; designing solutions that can’t be just approximately correct but that must be exactly correct; and so on. Even if we could invent a programming language that used the same terminology as the real-world problem we’re trying to solve, programming would still be difficult because of the challenge in determining precisely how the real world works. As software addresses ever-larger real-world problems, the interactions among the real-world entities become increasingly intricate, and that in turn increases the essential difficulty of the software solutions.</p><p><strong>The root of all these essential difficulties is complexity—both accidental and essential.</strong></p><h3 id="Importance-of-Managing-Complexity"><a href="#Importance-of-Managing-Complexity" class="headerlink" title="Importance of Managing Complexity"></a>Importance of Managing Complexity</h3><ul><li>Projects fail most often because of poor requirements, poor planning, or poor management. But when projects do fail for reasons that are primarily technical, the reason is often uncontrolled complexity. The software is allowed to grow so complex that no one really knows what it does. When a project reaches the point at which no one completely understands the impact that code changes in one area will have on other areas, progress grinds to a halt.</li><li>no one’s skull is really big enough to contain a modern computer program (Dijkstra 1972), which means that we as software developers shouldn’t try to cram whole programs into our skulls at once; we should try to organize our programs in such a way that we can safely focus on one part of it at a time.</li><li>Keeping routines short helps reduce your mental workload. Writing programs in terms of the problem domain, rather than in terms of low-level implementation details, and working at the highest level of abstraction reduce the load on your brain.</li></ul><h3 id="How-to-Attack-Complexity"><a href="#How-to-Attack-Complexity" class="headerlink" title="How to Attack Complexity"></a>How to Attack Complexity</h3><ul><li>Minimize the amount of essential complexity that anyone’s brain has to deal with at any one time<ul><li>尽量减少任何人的大脑在任何时候都必须处理的基本复杂性。</li></ul></li><li>Keep <strong>accidental complexity</strong> from needlessly proliferating<ul><li>防止意外的复杂性不必要地扩散</li></ul></li></ul><h2 id="Architecting-How-Much-and-When"><a href="#Architecting-How-Much-and-When" class="headerlink" title="Architecting: How Much and When?"></a>Architecting: How Much and When?</h2><h3 id="the-Cost-of-Fixing-Software"><a href="#the-Cost-of-Fixing-Software" class="headerlink" title="the Cost of Fixing Software"></a>the Cost of Fixing Software</h3><center><img loading="lazy" src="/posts/3ff63edb/10.png" width="450px"></center><h3 id="How-Much-Architecting-Is-Enough"><a href="#How-Much-Architecting-Is-Enough" class="headerlink" title="How Much Architecting Is Enough"></a>How Much Architecting Is Enough</h3><blockquote><p>The evidence provided across 40 years of data on the degree of increase in software cost-to-fix versus delay-of-fix is that for large projects, the increase from fixing requirements changes and defects during requirements definition to fixing them once the product is fielded continues to be around 100:1. However, this ratio can be significantly reduced by higher investments in early requirements and architecture verification and validation. As shown by the CCPDS-R project data in Figure 10-6, the ratio can approach 1:1 if the high-risk fixes are addressed early.<br>The evidence for small projects continues to show ratios around 5:1, but these can also be flattened by the use of outstanding personnel and by Agile methods, such as pair programming and continuous integration, that shorten the delay-of-fix time. Small, noncritical projects can also spread their architecting activity across the life cycle via refactoring, but need to watch out for making easiest-first architectural commitments that cannot be easily undone by refactoring, such as committing to unscalable COTS products or security-incompatible data and control structures.<br>The evidence provided more recently on the payoff of architecting and risk resolution efforts, such as those on CCPDS-R, is that the location of the highest-payoff “how much architecting is enough” sweet spot is a function of project size and criticality (larger, more critical projects require more architecting investment), but also a function of requirements volatility (more volatile projects would be slowed down by the need to revise extensive documentation). For detailed project planning and budgeting, the sweet-spot numbers need to be adjusted to reflect additional project, personnel, and product-related cost drivers. A recent COSYSMO model is now available to support such adjustments.<br>Very large projects are likely to have elements that are high in criticality and stability (e.g., safety and security-critical elements), as well as elements that are high in requirements volatility (e.g., user interfaces, external-system interfaces, device drivers, database schemas). In such cases, a hybrid approach using Agile methods for the rapidly changing parts and plandriven methods for the more stable and high-criticality parts will work, as long as the overall system is based on an architecture using the [Parnas 1979] information-hiding approach of encapsulating sources of change within modules.<br>Thus, there are no one-size-fits-all solutions for the increasingly rapid change that projects will experience in the future. Large projects or enterprises with a mix of critical and volatile elements are best served by risk-driven process generators, such as the Incremental Commitment Model and risk-driven versions of the Rational Unified Process. These model generators use the degree of developer-supplied evidence of project feasibility to determine project risk. Such evidence is critical to the success of many future projects facing the prospect of having to cope with increasing size, criticality, volatility, and complexity. In addition, the use of such evidence-based models will have the double benefit of reducing risk and adding to the knowledge base of evidence that can be analyzed for further sources of project and enterprise improvement.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Software-Quality&quot;&gt;&lt;a href=&quot;#Software-Quality&quot; class=&quot;headerlink&quot; title=&quot;Software Quality&quot;&gt;&lt;/a&gt;Software Quality&lt;/h2&gt;&lt;h3 id=&quot;Desirable-Software-Quality-理想的软件质量&quot;&gt;&lt;a href=&quot;#Desirable-Software-Quality-理想的软件质量&quot; class=&quot;headerlink&quot; title=&quot;Desirable Software Quality(理想的软件质量)&quot;&gt;&lt;/a&gt;Desirable Software Quality(理想的软件质量)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;External characteristics： External characteristics are characteristics that a user of the software product is aware of&lt;/li&gt;
&lt;li&gt;Internal : developer directly experience&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The difference between internal and external characteristics isn’t completely clear-cut because at some level internal characteristics affect external ones. Software that isn’t internally understandable or maintainable impairs your ability to correct defects, which in turn affects the external characteristics of correctness and reliability. Software that isn’t flexible can’t be enhanced in response to user requests, which in turn affects the external characteristic of usability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/3ff63edb/2.png&quot; width=&quot;450px&quot;&gt;&lt;/center&gt;

&lt;p&gt;External characteristics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Correctness&lt;ul&gt;
&lt;li&gt;一个系统在其规格、设计和实现中没有错误的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Usability&lt;ul&gt;
&lt;li&gt;用户学习和使用一个系统的容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Efficiency&lt;ul&gt;
&lt;li&gt;对系统资源的最小化使用，包括&lt;strong&gt;内存和执行时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reliability&lt;ul&gt;
&lt;li&gt; 一个系统在规定的条件下，无论何时都能执行所需功能的能力–&lt;strong&gt;具有较长的平均故障间隔时间&lt;/strong&gt;( a long mean time between failures)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Integrity&lt;ul&gt;
&lt;li&gt;完整性的概念包括&lt;strong&gt;限制未经授权的用户访问&lt;/strong&gt;，以及&lt;strong&gt;确保数据被正确访问&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Adaptability&lt;ul&gt;
&lt;li&gt;一个系统在没有修改的情况下，可以在其专门设计之外的应用或环境中使用的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Accuracy&lt;ul&gt;
&lt;li&gt;精确性与正确性不同；它决定了一个系统在多大程度上完成了它所构建的工作(而不是关注错误)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Robustness&lt;ul&gt;
&lt;li&gt;一个系统在无效的输入或紧张的环境条件下继续运行的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;internal quality characteristics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maintainability&lt;ul&gt;
&lt;li&gt;你可以修改一个软件系统以改变或增加功能、提高性能或纠正缺陷的容易程度&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The ease with&lt;/strong&gt; which you can modify a software system to change or add capabilities, improve performance, or correct defects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Flexibility &lt;ul&gt;
&lt;li&gt;可以修改一个系统的用途或环境的程度，而不是它的专门设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Portability&lt;ul&gt;
&lt;li&gt;你可以修改一个系统以在不同于其专门设计的环境中运行的容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reusability&lt;ul&gt;
&lt;li&gt;你可以在其他系统中使用一个系统的部分的程度和容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Readability&lt;ul&gt;
&lt;li&gt;你能够阅读和理解一个系统的源代码的难易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Testability&lt;ul&gt;
&lt;li&gt;你可以对一个系统进行单元测试和系统测试的程度；你可以&lt;strong&gt;验证该系统满足其要求的程度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Understandability&lt;ul&gt;
&lt;li&gt;在系统-组织和详细陈述层面上，你能理解一个系统的难易程度。&lt;strong&gt;与可读性相比，可理解性与系统在更一般的层面上的一致性有关&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Readability is part of understandability&lt;/strong&gt;. But you can have readable methods or functions and an impossible to grasp architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Software Engineering" scheme="https://hejueyun.github.io/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>论文笔记：使用基于SMT的上下文边界模型来验证多线程软件</title>
    <link href="https://hejueyun.github.io/posts/9277bdf3/"/>
    <id>https://hejueyun.github.io/posts/9277bdf3/</id>
    <published>2022-01-23T16:18:14.000Z</published>
    <updated>2022-01-25T00:54:59.973Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学备忘录-工作模式</title>
    <link href="https://hejueyun.github.io/posts/c82bbc9e/"/>
    <id>https://hejueyun.github.io/posts/c82bbc9e/</id>
    <published>2022-01-20T16:28:13.000Z</published>
    <updated>2022-01-20T17:28:50.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作模式Modes-of-Operation"><a href="#工作模式Modes-of-Operation" class="headerlink" title="工作模式Modes of Operation"></a>工作模式Modes of Operation</h2><ul><li><strong>解决如何将cipher加密算法运用到plaintext明文的问题</strong></li><li><strong>有block分组和stream流两种方式</strong></li></ul><img loading="lazy" src="/posts/c82bbc9e/2020-08-10-19-02-24.png" width height="200"><blockquote><p>ECB，CBC，OFB，CFB，CTR和XTS模式仅仅提供了<strong>机密性</strong>；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的消息验证码，例如CBC-<strong>MAC</strong></p></blockquote><h3 id="ECB-Electronic-codebook"><a href="#ECB-Electronic-codebook" class="headerlink" title="ECB Electronic codebook"></a>ECB Electronic codebook</h3><img loading="lazy" src="/posts/c82bbc9e/2020-08-10-19-05-10.png" width height="200"><ul><li>当明文分组重复时，密文也重复，易实现统计分析攻击</li><li>结构化数据，将产生大量重复的密文</li><li>ECB模式最严重的问题是使得对手选取部分分组进行重放攻击</li></ul><h3 id="CBC-Cipher-block-chaining"><a href="#CBC-Cipher-block-chaining" class="headerlink" title="CBC Cipher-block chaining"></a>CBC Cipher-block chaining</h3><img loading="lazy" src="/posts/c82bbc9e/2020-08-10-19-06-24.png" width height="200"><ul><li><p>保护IV的原因</p><ul><li>如果敌手能欺骗接收方使用不同的Iv值，敌手就能够在明文的第1个分组中插入自己选择的比特值</li></ul></li><li><p><strong>错误传播</strong></p><ul><li>明文错误传播<ul><li>加密前的明文中某个错误对解密后恢复的明文的影响</li><li><strong>CBC没有明文错误传播</strong></li></ul></li><li>密文错误传播<ul><li>密文组中某部分比特错误</li><li>某密文组丢失</li><li>被插入一个密文组</li><li><strong>CBC的密文错误传播很小</strong></li></ul></li></ul></li><li><p>padding oracle attack</p></li></ul><h4 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h4><blockquote><p> a technique for constructing a message authentication code from a block cipher. </p></blockquote><ul><li>CBC-MAC 仅适用于对相同长度的消息进行认证，在消息长度变化的情况下是不安全的</li><li>当取AES作为MAC加密的分组密码时，一般采用CBC模式，所以通常称为基于AES的CBC-MAC,若需要产生认证码的消息为x，加密的AES为k，则生成加解密的过程如下图所示</li></ul><img loading="lazy" src="/posts/c82bbc9e/3.jpg" width="500"><h3 id="CFB-密码反馈-Cipher-Feed-Back"><a href="#CFB-密码反馈-Cipher-Feed-Back" class="headerlink" title="CFB(密码反馈)Cipher Feed Back"></a>CFB(密码反馈)Cipher Feed Back</h3><ul><li>将分组密码作为流密码的密钥流发生器<ul><li>利用CFB(Cipher Feed Back)模式或输出反馈(OFB)模式，可将<strong>分组密码</strong>转换为<strong>流密码</strong></li></ul></li></ul><img loading="lazy" src="/posts/c82bbc9e/2020-08-10-19-18-52.png" width height="250"><img loading="lazy" src="/posts/c82bbc9e/2020-08-11-15-19-31.png" width height="250"><p>攻击</p><img loading="lazy" src="/posts/c82bbc9e/2020-08-11-15-08-16.png" width height="200"><h3 id="OFB-输出反馈-Output-feedback"><a href="#OFB-输出反馈-Output-feedback" class="headerlink" title="OFB(输出反馈) Output feedback"></a>OFB(输出反馈) Output feedback</h3><ul><li>OFB模式是将加密算法的输出反馈到移位寄存器</li><li>CFB模式中是将密文单元反馈到移位寄存器</li></ul><img loading="lazy" src="/posts/c82bbc9e/2020-08-11-15-12-27.png" width height="200"><ul><li>优点:传输过程中的密文比特错误不会被传播</li><li>缺点:它比CFB模式更易受到对消息流的篡改攻击</li></ul><img loading="lazy" src="/posts/c82bbc9e/2020-08-11-15-06-33.png" width height="200"><h3 id="CTR-Counter"><a href="#CTR-Counter" class="headerlink" title="CTR Counter"></a>CTR Counter</h3><blockquote><p>与OFB一样，计数器模式将一个块状密码变成了一个流密码。它通过对一个 “计数器 “的连续值进行加密来生成下一个密钥流块。计数器可以是任何能产生一个保证长时间不重复的序列的函数</p></blockquote><img loading="lazy" src="/posts/c82bbc9e/5.svg" width="500"><h3 id="XTS"><a href="#XTS" class="headerlink" title="XTS"></a>XTS</h3><img loading="lazy" src="/posts/c82bbc9e/2.svg" width="500"><ul><li>XEX-based tweaked-codebook mode with ciphertext stealing</li><li>基于XEX的调整密码本模式与密码文本窃取</li></ul><p>弱点</p><blockquote><p>XTS模式容易受到数据操纵和篡改的影响，如果操纵和篡改是一个问题，应用程序必须采用措施来检测数据的修改：”……由于没有认证标签，那么任何密码文本（原始或被攻击者修改）将被解密为一些明文，没有内置机制来检测修改。可以做的最好的事情是确保对密码文本的任何更改将完全随机化明文，并依靠使用这种转换的应用程序在其明文中包括足够的冗余，以检测和丢弃这种随机明文。” 这就需要为磁盘上的所有数据和元数据维护校验和，正如ZFS或Btrfs所做的那样。然而，在常用的文件系统中，如ext4和NTFS，只有元数据受到保护，不被篡改，而对数据篡改的检测是不存在的[16] 。</p><p>该模式容易受到流量分析、重放和对扇区和16字节块的随机化攻击。当一个给定的扇区被重写时，攻击者可以收集细粒度（16字节）的密码文本，这可用于分析或重放攻击（以16字节为粒度）。定义扇区范围内的块密码是可能的，不幸的是性能会下降（见下文）。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工作模式Modes-of-Operation&quot;&gt;&lt;a href=&quot;#工作模式Modes-of-Operation&quot; class=&quot;headerlink&quot; title=&quot;工作模式Modes of Operation&quot;&gt;&lt;/a&gt;工作模式Modes of Operation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解决如何将cipher加密算法运用到plaintext明文的问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有block分组和stream流两种方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c82bbc9e/2020-08-10-19-02-24.png&quot; width height=&quot;200&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;ECB，CBC，OFB，CFB，CTR和XTS模式仅仅提供了&lt;strong&gt;机密性&lt;/strong&gt;；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的消息验证码，例如CBC-&lt;strong&gt;MAC&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ECB-Electronic-codebook&quot;&gt;&lt;a href=&quot;#ECB-Electronic-codebook&quot; class=&quot;headerlink&quot; title=&quot;ECB Electronic codebook&quot;&gt;&lt;/a&gt;ECB Electronic codebook&lt;/h3&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c82bbc9e/2020-08-10-19-05-10.png&quot; width height=&quot;200&quot;&gt;

&lt;ul&gt;
&lt;li&gt;当明文分组重复时，密文也重复，易实现统计分析攻击&lt;/li&gt;
&lt;li&gt;结构化数据，将产生大量重复的密文&lt;/li&gt;
&lt;li&gt;ECB模式最严重的问题是使得对手选取部分分组进行重放攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CBC-Cipher-block-chaining&quot;&gt;&lt;a href=&quot;#CBC-Cipher-block-chaining&quot; class=&quot;headerlink&quot; title=&quot;CBC Cipher-block chaining&quot;&gt;&lt;/a&gt;CBC Cipher-block chaining&lt;/h3&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c82bbc9e/2020-08-10-19-06-24.png&quot; width height=&quot;200&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;保护IV的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果敌手能欺骗接收方使用不同的Iv值，敌手就能够在明文的第1个分组中插入自己选择的比特值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;错误传播&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明文错误传播&lt;ul&gt;
&lt;li&gt;加密前的明文中某个错误对解密后恢复的明文的影响&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CBC没有明文错误传播&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;密文错误传播&lt;ul&gt;
&lt;li&gt;密文组中某部分比特错误&lt;/li&gt;
&lt;li&gt;某密文组丢失&lt;/li&gt;
&lt;li&gt;被插入一个密文组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CBC的密文错误传播很小&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;padding oracle attack&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Cryptography" scheme="https://hejueyun.github.io/categories/Security/Cryptography/"/>
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>密码学备忘录-消息验证码MAC</title>
    <link href="https://hejueyun.github.io/posts/d83c07b3/"/>
    <id>https://hejueyun.github.io/posts/d83c07b3/</id>
    <published>2022-01-19T23:59:07.000Z</published>
    <updated>2022-01-20T22:58:06.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用途</p><ul><li>实现authentication</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>哈希<ul><li>其中一种实现方法称为HMAC</li></ul></li><li>分组密码</li></ul><img loading="lazy" src="/posts/d83c07b3/2020-08-13-15-27-33.png" width height="250"><ul><li>appended to message as a <strong><code>digest</code></strong></li><li>接收者进行相同计算，比较MAC前后是否一致</li></ul><h3 id="approach"><a href="#approach" class="headerlink" title="approach"></a>approach</h3><img loading="lazy" src="/posts/d83c07b3/9.png" width="500"><ul><li>不可逆</li><li>均匀分布</li><li>均匀依赖每一bit消息</li></ul><h3 id="requirement"><a href="#requirement" class="headerlink" title="requirement"></a>requirement</h3><img loading="lazy" src="/posts/d83c07b3/10.png" width="500"><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>MAC与加密算法的区别</p><ul><li>MAC算法不要求可逆，但加密算法则必须是可逆的;</li><li>MAC算法的输出MAC码是<strong>定</strong>长的，而加<strong>密算法输出的密文长度与明文长度有关</strong>。</li><li>MAC函数的设计比加密函数更为灵活</li></ul><h2 id="基于hash函数"><a href="#基于hash函数" class="headerlink" title="基于hash函数"></a>基于hash函数</h2><img loading="lazy" src="/posts/d83c07b3/2020-08-13-15-22-19.png" width height="250"><ul><li>散列函数的软件实现快于分组密码的软件实现</li><li>散列函数的库代码来源广泛</li><li>散列函数不使用密钥，因此不能直接用于MAC</li></ul><h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC是基于散列函数的消息认证算法，在IPSec和其他网络协议(如SSL)中得以应用。</p><img loading="lazy" src="/posts/d83c07b3/2020-08-13-20-48-57.png" width height="250"><ul><li>precomputation预运算</li></ul><img loading="lazy" src="/posts/d83c07b3/2020-08-13-20-49-12.png" width height="250"><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>依赖于底层的(underlying)哈希函数的安全性</p><ul><li>暴力破解</li><li>生日攻击</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>HMAC用于身份认证</p><ul><li>先由客户端向服务器发出一个验证请求。<br>服务器接到此请求后生成一个随机数并通过网络传输给客户端(挑战–Challenge)。</li><li>客户端将收到的随机数提供给U盾，U盾使用该随机数与存储在U盾中的密钥进行HMAC-MD5运算并得到一个结果作为认证证据传给服务器(响应–Response)。</li><li>服务器也使用该随机数与存储在服务器数据库中的该客户密钥进行HMAC-MD5运算，如果服务器的运算结果与客户端传回的响应结果相同，则认为客户端是一个合法<br>用户。</li></ul><h2 id="基于分组密码"><a href="#基于分组密码" class="headerlink" title="基于分组密码"></a>基于分组密码</h2><h3 id="DES-CBC"><a href="#DES-CBC" class="headerlink" title="DES-CBC"></a>DES-CBC</h3><ul><li>Data Authentication Algorithm (DAA)</li><li>but final MAC is now too small (64 bits) for security</li></ul><h4 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h4><ul><li>考虑CBC和CFB工作模式的特点:<ul><li>一个明文分组的改变，在加密时会引起相应的密文分组及其后的所有密文分组的改变。</li></ul></li><li>因此，可以利用分组密码的CBC和CFB工作模式来构造消息认证码。</li><li>也有AES实现</li></ul><img loading="lazy" src="/posts/d83c07b3/2020-08-13-16-18-15.png" width height="250">- IV：0<h4 id="CFB-MAC"><a href="#CFB-MAC" class="headerlink" title="CFB-MAC"></a>CFB-MAC</h4><p>基于DES的消息认证码:CFB-MAC</p><img loading="lazy" src="/posts/d83c07b3/2020-08-13-16-20-25.png" width height="250"><h3 id="OMAC"><a href="#OMAC" class="headerlink" title="OMAC"></a>OMAC</h3><ul><li>One-Key MAC </li><li>单钥MAC（OMAC）是一个由块状密码构建的消息认证码，很像CBC-MAC算法</li><li>CMAC是OMAC1</li></ul><h4 id="CMAC"><a href="#CMAC" class="headerlink" title="CMAC"></a>CMAC</h4><ul><li>daa改进</li><li>3des和aes都能用</li></ul><img loading="lazy" src="/posts/d83c07b3/11.png" width="500"><ul><li>MSBs(X)是取位串X最左边的s位</li><li>L = E(K , $0^n$)</li><li>K1 = L • x</li><li>K2 = L • $x^2$ = (L • x) • x</li><li>乘法（•）在域GF($2^n$)内进行</li></ul><h3 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h3><ul><li> counter with CBC-MAC</li></ul><img loading="lazy" src="/posts/d83c07b3/12.png" width="550"><h3 id="GCM"><a href="#GCM" class="headerlink" title="GCM"></a>GCM</h3><p>运用了两个函数<br>Galois/Counter Mode (GCM)</p><ul><li>GHASH – a keyed hash function</li><li>GCTR –  CTR mode with incremented counter</li></ul><img loading="lazy" src="/posts/d83c07b3/13.png" width="550"><img loading="lazy" src="/posts/d83c07b3/14.png" width="500"><img loading="lazy" src="/posts/d83c07b3/15.png" width="500"><h3 id="CCM-vs-GCM"><a href="#CCM-vs-GCM" class="headerlink" title="CCM vs GCM"></a>CCM vs GCM</h3><ul><li>CCM: Message authentication (via CBC-MAC) is done on the plaintext not the ciphertext. (This is generally not a desireable feature.) </li><li>GCM: Message authentication (via GMAC/GHASH) is done on the ciphertext.</li><li>对于大多数需要验证加密的应用来说，<strong>GCM应该被认为比CCM更有优势</strong>。由于发生了认证，GCM不容易受到比特翻转和其他攻击的影响，而这些攻击可以针对计数器模式或其他流模式</li></ul><h2 id="MAC-vs-HASH-VS-Digital-signature"><a href="#MAC-vs-HASH-VS-Digital-signature" class="headerlink" title="MAC vs HASH VS Digital signature"></a>MAC vs HASH VS Digital signature</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cryptographic primitive | Hash |    MAC    | Digital</span><br><span class="line">Security Goal           |      |           | signature</span><br><span class="line">------------------------+------+-----------+-------------</span><br><span class="line">Integrity               |  Yes |    Yes    |   Yes</span><br><span class="line">Authentication          |  No  |    Yes    |   Yes</span><br><span class="line">Non-repudiation         |  No  |    No     |   Yes</span><br><span class="line">------------------------+------+-----------+-------------</span><br><span class="line">Kind of keys            | none | symmetric | asymmetric</span><br><span class="line">                        |      |    keys   |    keys</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现authentication&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;哈希&lt;ul&gt;
&lt;li&gt;其中一种实现方法称为HMAC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分组密码&lt;/li&gt;
&lt;/ul&gt;
&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d83c07b3/2020-08-13-15-27-33.png&quot; width height=&quot;250&quot;&gt;

&lt;ul&gt;
&lt;li&gt;appended to message as a &lt;strong&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接收者进行相同计算，比较MAC前后是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;approach&quot;&gt;&lt;a href=&quot;#approach&quot; class=&quot;headerlink&quot; title=&quot;approach&quot;&gt;&lt;/a&gt;approach&lt;/h3&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d83c07b3/9.png&quot; width=&quot;500&quot;&gt;

&lt;ul&gt;
&lt;li&gt;不可逆&lt;/li&gt;
&lt;li&gt;均匀分布&lt;/li&gt;
&lt;li&gt;均匀依赖每一bit消息&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Cryptography" scheme="https://hejueyun.github.io/categories/Security/Cryptography/"/>
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>密码学备忘录-前置知识</title>
    <link href="https://hejueyun.github.io/posts/af185d1f/"/>
    <id>https://hejueyun.github.io/posts/af185d1f/</id>
    <published>2022-01-19T23:05:49.000Z</published>
    <updated>2022-01-21T00:01:05.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sec-cyber-vs-infovcs-net"><a href="#sec-cyber-vs-infovcs-net" class="headerlink" title="sec: cyber vs infovcs net"></a>sec: cyber vs infovcs net</h2><p>cyber &gt;= info + net</p><ul><li>info: info c.i.a<ul><li>confidentiality</li><li>Integrity<ul><li>Auth</li></ul></li><li>Availablity</li></ul></li></ul><h2 id="攻击的主要形式"><a href="#攻击的主要形式" class="headerlink" title="攻击的主要形式"></a>攻击的主要形式</h2><ul><li>拦截Interception<ul><li>中断(Interruption)</li></ul></li><li>传递大量”废纸”<ul><li>拒绝服务攻击Dos</li></ul></li><li>偷看<ul><li>窃听 Eavesdropping</li></ul></li><li>篡改/删节Tampering</li><li>伪装/冒充身份 Masquerade</li><li>复印后再次传递<ul><li>重放 Replay<ul><li>攻击信息实时性/真实性</li></ul></li></ul></li><li>否认发送/接收 deny</li><li>阻断访问式攻击denial-of-access attack<ul><li>勒索软件 ransomware (e.g. <strong>WannaCry</strong>)</li></ul></li></ul><hr><h3 id="Active-and-passive-attacks"><a href="#Active-and-passive-attacks" class="headerlink" title="Active and passive attacks"></a>Active and passive attacks</h3><table><thead><tr><th>Sr. No.</th><th>Key</th><th>Active Attack</th><th>Passive Attack</th></tr></thead><tbody><tr><td>1</td><td>Modification</td><td><strong>In Active Attack, information is modified.</strong></td><td><strong>In Passive Attack, information remain unchanged.</strong></td></tr><tr><td>2</td><td>Dangerous For</td><td>Active Attack is dangerous for Integrity as well as Availability.</td><td>Passive Attack is dangerous for Confidentiality.</td></tr><tr><td>3</td><td>Attention</td><td>Attention is to be paid on detection.</td><td>Attention is to be paid on prevention.</td></tr><tr><td>4</td><td>Impact on System</td><td>In Active Attack, system is damaged.</td><td>In Passive Attack, system has no impact.</td></tr><tr><td>5</td><td>Victim</td><td>Victim gets informed in active attack.</td><td>Victim does not get informed in passive attack.</td></tr><tr><td>6</td><td>System Resources</td><td>System Resources can be changed in active attack.</td><td>System Resources are not changed in passive attack.</td></tr><tr><td>7</td><td>Property</td><td>integrity &amp;&amp; availability</td><td>confidentiality</td></tr></tbody></table><ul><li>被动攻击<blockquote><p>在未经用户同意和认可的情况下，将信息或数据文件泄露给系统攻击者，<strong>但不对数据信息做任何修改</strong>。威胁信息<strong>机密性</strong>。</p></blockquote></li><li>主动攻击<blockquote><p>旨在篡改系统信息、改变系统状态等，威胁信息的<strong>可用性和真实性</strong>。</p></blockquote></li></ul><h3 id="Security-Services"><a href="#Security-Services" class="headerlink" title="Security Services"></a>Security Services</h3><ol><li>Authentication</li><li>Access Control</li><li>Data Confidentiality</li><li>Data Integrity</li><li>Nonrepudiation</li><li>Available Service</li></ol><h2 id="信安基本属性"><a href="#信安基本属性" class="headerlink" title="信安基本属性"></a>信安基本属性</h2><img loading="lazy" src="/posts/af185d1f/2020-08-06-15-54-55.png" width height="250"><ul><li>机密性(<strong>Confidentiality</strong>)<ul><li>通过<strong>访问控制</strong>阻止非授权用户获得机密信息</li><li>通过<strong>加密变换</strong>阻止非授权用户获知信息内容</li></ul></li><li>完整性(<strong>Integrity</strong>)<ul><li>完整性是指信息未经授权不能进行篡改的特征，维护信息的一致性</li><li>通过<strong>访问控制</strong>阻止篡改行为</li><li>通过<strong>消息摘要算法</strong>检验信息是否被篡改</li></ul></li><li>可用性(<strong>Availablity</strong>)</li><li>认证性(<strong>Authentication</strong>)<ul><li>确保一个消息的来源或消息本身被正确地标识，同时确保该标识没有被伪造</li><li>认证分为<strong>消息认证</strong>和<strong>实体认证</strong></li></ul></li><li>不可否认性(Non-Repudiation)<ul><li>不可否认性是指能保障用户无法在事后否认曾经对信息进行的生成、签发、接收等行为</li><li>通过<strong>数字签名</strong>提供抗否认服务</li></ul></li></ul><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">• plaintext - oriigiinall message</span><br><span class="line">• ciphertext - coded message</span><br><span class="line">• cipher 密码算法- allgoritthm for transfformiing pllaiinttextt tto ciipherttextt</span><br><span class="line">• key - inffo used in ciipher known onlly to sender//receiiver</span><br><span class="line">• encipher (encrypt) - converttiing pllaiinttextt tto ciipherttextt</span><br><span class="line">• decipher (decrypt) - recoveriing ciipherttextt ffrom pllaiinttextt</span><br><span class="line">• cryptography - study off encryption principles//methods</span><br><span class="line">• cryptanalysis (codebreaking) 密码分析(破译)- sttudy off priinciiplles//</span><br><span class="line">metthods off deciipheriing ciipherttextt wiithout knowiing key</span><br><span class="line">• cryptology - ffiielld off botth crypttography and crypttanallysiis</span><br></pre></td></tr></table></figure><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><img loading="lazy" src="/posts/af185d1f/2020-08-06-16-38-17.png" width height="250"><ul><li>图片有误</li></ul><h3 id="绝对安全-vs-相对安全"><a href="#绝对安全-vs-相对安全" class="headerlink" title="绝对安全 vs 相对安全"></a>绝对安全 vs 相对安全</h3><ul><li>unconditional security<ul><li>管有多少计算能力或时间可以使用都无法破解密码</li></ul></li><li>computational security<ul><li>考虑到有限的计算资源，一定时间内无法被破译</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;sec-cyber-vs-infovcs-net&quot;&gt;&lt;a href=&quot;#sec-cyber-vs-infovcs-net&quot; class=&quot;headerlink&quot; title=&quot;sec: cyber vs infovcs net&quot;&gt;&lt;/a&gt;sec: cyber vs infovcs net&lt;/h2&gt;&lt;p&gt;cyber &amp;gt;= info + net&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;info: info c.i.a&lt;ul&gt;
&lt;li&gt;confidentiality&lt;/li&gt;
&lt;li&gt;Integrity&lt;ul&gt;
&lt;li&gt;Auth&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Availablity&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;攻击的主要形式&quot;&gt;&lt;a href=&quot;#攻击的主要形式&quot; class=&quot;headerlink&quot; title=&quot;攻击的主要形式&quot;&gt;&lt;/a&gt;攻击的主要形式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;拦截Interception&lt;ul&gt;
&lt;li&gt;中断(Interruption)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传递大量”废纸”&lt;ul&gt;
&lt;li&gt;拒绝服务攻击Dos&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偷看&lt;ul&gt;
&lt;li&gt;窃听 Eavesdropping&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;篡改/删节Tampering&lt;/li&gt;
&lt;li&gt;伪装/冒充身份 Masquerade&lt;/li&gt;
&lt;li&gt;复印后再次传递&lt;ul&gt;
&lt;li&gt;重放 Replay&lt;ul&gt;
&lt;li&gt;攻击信息实时性/真实性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;否认发送/接收 deny&lt;/li&gt;
&lt;li&gt;阻断访问式攻击denial-of-access attack&lt;ul&gt;
&lt;li&gt;勒索软件 ransomware (e.g. &lt;strong&gt;WannaCry&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Active-and-passive-attacks&quot;&gt;&lt;a href=&quot;#Active-and-passive-attacks&quot; class=&quot;headerlink&quot; title=&quot;Active and passive attacks&quot;&gt;&lt;/a&gt;Active and passive attacks&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sr. No.&lt;/th&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Active Attack&lt;/th&gt;
&lt;th&gt;Passive Attack&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Modification&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;In Active Attack, information is modified.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;In Passive Attack, information remain unchanged.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Dangerous For&lt;/td&gt;
&lt;td&gt;Active Attack is dangerous for Integrity as well as Availability.&lt;/td&gt;
&lt;td&gt;Passive Attack is dangerous for Confidentiality.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Attention&lt;/td&gt;
&lt;td&gt;Attention is to be paid on detection.&lt;/td&gt;
&lt;td&gt;Attention is to be paid on prevention.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Impact on System&lt;/td&gt;
&lt;td&gt;In Active Attack, system is damaged.&lt;/td&gt;
&lt;td&gt;In Passive Attack, system has no impact.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Victim&lt;/td&gt;
&lt;td&gt;Victim gets informed in active attack.&lt;/td&gt;
&lt;td&gt;Victim does not get informed in passive attack.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;System Resources&lt;/td&gt;
&lt;td&gt;System Resources can be changed in active attack.&lt;/td&gt;
&lt;td&gt;System Resources are not changed in passive attack.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;integrity &amp;amp;&amp;amp; availability&lt;/td&gt;
&lt;td&gt;confidentiality&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;被动攻击&lt;blockquote&gt;
&lt;p&gt;在未经用户同意和认可的情况下，将信息或数据文件泄露给系统攻击者，&lt;strong&gt;但不对数据信息做任何修改&lt;/strong&gt;。威胁信息&lt;strong&gt;机密性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;主动攻击&lt;blockquote&gt;
&lt;p&gt;旨在篡改系统信息、改变系统状态等，威胁信息的&lt;strong&gt;可用性和真实性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Security-Services&quot;&gt;&lt;a href=&quot;#Security-Services&quot; class=&quot;headerlink&quot; title=&quot;Security Services&quot;&gt;&lt;/a&gt;Security Services&lt;/h3&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Cryptography" scheme="https://hejueyun.github.io/categories/Security/Cryptography/"/>
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>密码学备忘录-伪随机数</title>
    <link href="https://hejueyun.github.io/posts/f6b1e424/"/>
    <id>https://hejueyun.github.io/posts/f6b1e424/</id>
    <published>2022-01-19T19:13:56.000Z</published>
    <updated>2022-01-21T08:48:27.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pseudorandom-number-generation"><a href="#pseudorandom-number-generation" class="headerlink" title="pseudorandom number generation"></a>pseudorandom number generation</h2><h3 id="随机数的作用"><a href="#随机数的作用" class="headerlink" title="随机数的作用"></a>随机数的作用</h3><ul><li>防止重放攻击</li><li>keystream for a one-time pad（一次性密码的密钥流）</li><li>public key generation 生成公钥</li></ul><h3 id="伪随机数和随机数区别"><a href="#伪随机数和随机数区别" class="headerlink" title="伪随机数和随机数区别"></a>伪随机数和随机数区别</h3><ul><li>deterministic algorithm</li><li>seed</li></ul><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><h4 id="1-Linear-Congruential-Generator-线性同余生成器"><a href="#1-Linear-Congruential-Generator-线性同余生成器" class="headerlink" title="1. Linear Congruential Generator 线性同余生成器"></a>1. Linear Congruential Generator 线性同余生成器</h4><ul><li>$x_{n+1}=(aX_n+c)\bmod{m}$</li></ul><p>特点</p><ul><li>存在周期</li><li>32bit计算</li></ul><h4 id="2-Blum-Blum-Shub-B-B-S-算法"><a href="#2-Blum-Blum-Shub-B-B-S-算法" class="headerlink" title="2. Blum Blum Shub (B.B.S.) 算法"></a>2. Blum Blum Shub (B.B.S.) 算法</h4><ul><li>$x_0=seed^2\bmod{n}$</li><li>$LOOP x_i == x_{i-i}^2\bmod{n}$</li><li>$b_i=x_i\bmod{2}$<ul><li>p,q is prime</li><li>p,q mod 3 == 4</li></ul></li></ul><p>特点</p><ul><li>based on public key algorithms</li><li>安全性基于分解n的困难性(同rsa)</li></ul><h4 id="3-Using-Block-Ciphers-as-PRNG-运用分组（对称）加密算法作为生成器"><a href="#3-Using-Block-Ciphers-as-PRNG-运用分组（对称）加密算法作为生成器" class="headerlink" title="3. Using Block Ciphers as PRNG 运用分组（对称）加密算法作为生成器"></a>3. Using Block Ciphers as PRNG 运用分组（对称）加密算法作为生成器</h4><ul><li>CRT</li><li>OFB</li><li>CBC-MAC</li></ul><p><strong>e.g. ANSI X9.17 PRGN</strong></p><ul><li>date and time(DTi)</li><li>uses 2-key (K1,K2) triple DES</li><li>feeds back between rounds (Vi)</li></ul><img loading="lazy" src="/posts/f6b1e424/1.png" width="500"><h4 id="4-运用非对称加密算法作为生成器"><a href="#4-运用非对称加密算法作为生成器" class="headerlink" title="4. 运用非对称加密算法作为生成器"></a>4. 运用非对称加密算法作为生成器</h4><ul><li>总体上慢，因此只应用于生成短伪随机数</li><li>PRNG based on RSA</li></ul><img loading="lazy" src="/posts/f6b1e424/5.png" width="500"><ul><li>PRNG based on ECC</li></ul><h4 id="5-运用哈希和MAC"><a href="#5-运用哈希和MAC" class="headerlink" title="5. 运用哈希和MAC"></a>5. 运用哈希和MAC</h4><ul><li>PRNG using a Hash Function</li></ul><img loading="lazy" src="/posts/f6b1e424/6.png" width="500"><ul><li>PRNG using a MAC</li></ul><img loading="lazy" src="/posts/f6b1e424/7.png" width="500"><h2 id="Stream-Ciphers"><a href="#Stream-Ciphers" class="headerlink" title="Stream Ciphers"></a>Stream Ciphers</h2><ul><li>是一种对称加密算法<ul><li>加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥</li></ul></li><li>该算法解决了对称加密完善保密性（<strong>perfect secrecy</strong>）的实际操作困难<ul><li>具有该性质的密文不应该透露任何明文的信息</li><li><strong>完善保密性要求密钥长度不短于明文长度</strong>，故而实际操作存在困难，改由较短数据流通过特定算法得到密钥流</li></ul></li></ul><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>一种严重的错误即反复使用同一密码本对不同明文进行加密。攻击者可利用这种方式对密文进行解密。用p表示明文，C表示密文，k表示种子，PRG表示密钥流生成算法，则：</p><ul><li>C1 = p1 xor PRG (k)</li><li>C2 = p2 xor PRG (k)<br>攻击者监听到此段消息（包含两段相同密钥流加密的密文）后，即可利用：</li><li>C1 xor C2得到p1 xor p2<br>足量的冗余（此处表示p1，p2）则可破解明文。 </li></ul><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><img loading="lazy" src="/posts/f6b1e424/2.jpg" width="550"><ul><li>Key-scheduling algorithm (KSA)<ul><li>临时向量 T</li><li>状态向量 S</li><li>初始密钥 K<ul><li>注意和最终生成的密钥流t区别开</li></ul></li></ul></li></ul><img loading="lazy" src="/posts/f6b1e424/3.png" width="450"><ul><li>RC4 Encryption </li></ul><img loading="lazy" src="/posts/f6b1e424/4.png" width="450"><ul><li>注意直到最后一步$C_i$之前，都只是在生成伪随机序列(<strong>密钥流</strong>)<ul><li>S的每个元素每256次迭代至少与另一个元素互换一次</li><li>PRGA(Pseudo-random generation algorithm)</li></ul></li><li>最后一步异或才算是C=M+K</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>result is very non-linear</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>these days, RC4 is known to be biased (unequal numbers of 0s and 1s in the keystream)</li><li>永远不应该重复使用密码本</li></ul><h2 id="true-random-numbers"><a href="#true-random-numbers" class="headerlink" title="true random numbers"></a>true random numbers</h2><ul><li>best source is natural randomness in real world 最好的来源是现实世界中的自然随机性</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pseudorandom-number-generation&quot;&gt;&lt;a href=&quot;#pseudorandom-number-generation&quot; class=&quot;headerlink&quot; title=&quot;pseudorandom number generation&quot;&gt;&lt;/a&gt;pseudorandom number generation&lt;/h2&gt;&lt;h3 id=&quot;随机数的作用&quot;&gt;&lt;a href=&quot;#随机数的作用&quot; class=&quot;headerlink&quot; title=&quot;随机数的作用&quot;&gt;&lt;/a&gt;随机数的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;防止重放攻击&lt;/li&gt;
&lt;li&gt;keystream for a one-time pad（一次性密码的密钥流）&lt;/li&gt;
&lt;li&gt;public key generation 生成公钥&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;伪随机数和随机数区别&quot;&gt;&lt;a href=&quot;#伪随机数和随机数区别&quot; class=&quot;headerlink&quot; title=&quot;伪随机数和随机数区别&quot;&gt;&lt;/a&gt;伪随机数和随机数区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;deterministic algorithm&lt;/li&gt;
&lt;li&gt;seed&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;种类&quot;&gt;&lt;a href=&quot;#种类&quot; class=&quot;headerlink&quot; title=&quot;种类&quot;&gt;&lt;/a&gt;种类&lt;/h3&gt;&lt;h4 id=&quot;1-Linear-Congruential-Generator-线性同余生成器&quot;&gt;&lt;a href=&quot;#1-Linear-Congruential-Generator-线性同余生成器&quot; class=&quot;headerlink&quot; title=&quot;1. Linear Congruential Generator 线性同余生成器&quot;&gt;&lt;/a&gt;1. Linear Congruential Generator 线性同余生成器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;$x_{n+1}=(aX_n+c)\bmod{m}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在周期&lt;/li&gt;
&lt;li&gt;32bit计算&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Cryptography" scheme="https://hejueyun.github.io/categories/Security/Cryptography/"/>
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>密码学备忘录-复习总纲</title>
    <link href="https://hejueyun.github.io/posts/8b9f706b/"/>
    <id>https://hejueyun.github.io/posts/8b9f706b/</id>
    <published>2022-01-12T19:00:15.000Z</published>
    <updated>2022-01-21T12:23:33.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mode-of-operation"><a href="#mode-of-operation" class="headerlink" title="mode of operation"></a>mode of operation</h2><table><thead><tr><th></th><th></th><th></th><th>Workflow</th><th>Advantages</th><th>Limitations</th></tr></thead><tbody><tr><td>ECB</td><td>Electronic Codebook</td><td>电码本</td><td>$C_i=E_k(M_i)$</td><td>简单、主要用于少量分组的传输。<strong>没有明密文错误传播</strong></td><td>当明文分组重复时，密文也重复，易实现<strong>统计分析</strong>攻击</td></tr><tr><td>CBC</td><td>Cipher block chaining</td><td>密文分组链接</td><td>$C_i=E_k(M_i \bigoplus{C_{i-1}})$<br> $C_0=IV$</td><td>CBC没有明文错误传播，密文错误传播小</td><td>需要初始化和保护IV（原因），前面的分组会对后面的产生影响</td></tr><tr><td>CFB</td><td>Ciphertext feedback</td><td>密文反馈</td><td>$C_i=M_i \bigoplus{E_k(C_{i-1}})$<br> $C_0=IV$</td><td>可作为随机数生成器</td><td>在错误发生后，错误会在几个区块内传播（但不是无限期地传播）。</td></tr><tr><td>OFB</td><td>Output feedback</td><td>输出反馈</td><td>$O_i=E_k(O_{i-1})$<br> $C_i=M_i\bigoplus O_{i-1}$<br> $O_0=IV$</td><td>可作为随机数生成器，密文1bit错误只会导致对应的1bit出错</td><td>接收者和发送者必须保持同步</td></tr><tr><td>CTR</td><td>Galois/Counter</td><td>计数器</td><td>$O_i=E_k(i)$<br> $C_i=M_i\bigoplus O_{i-1}$</td><td>速度快</td><td>对每一分组必须用不同的$K$和计数$i$</td></tr><tr><td>AES-XTS</td><td>-</td><td>-</td><td>$T$ is tweak, $H$ is a hash function<br> $C=H(T)\bigoplus{E(K,H(T)\bigoplus{M})}$</td><td>高效</td><td></td></tr></tbody></table><h2 id="Symmetric-Algorithm"><a href="#Symmetric-Algorithm" class="headerlink" title="Symmetric Algorithm"></a>Symmetric Algorithm</h2><table><thead><tr><th></th><th>DES</th><th>AES</th><th>3DES</th><th>RC4</th></tr></thead><tbody><tr><td>Basic</td><td>In DES the data block is divided into <strong>two halves</strong>.</td><td>In AES the entire data block is processed <strong>as a single matrix</strong>.</td><td>EEE/EDE</td><td>RC4生成一个伪随机的比特流（一个密钥流）。这些比特流可以通过与明文比特<strong>异或</strong>来进行加密</td></tr><tr><td>Principle</td><td>DES work on <strong>Feistel</strong> Cipher structure.</td><td>AES works on <strong>Substitution and Permutation</strong> Principle.</td><td>-</td><td>PRNG</td></tr><tr><td>Plaintext</td><td>明文按64位进行分组，以<strong>比特</strong>为单位</td><td>Plaintext can be of 128,192, or 256，以<strong>字节</strong>为单位 bits</td><td>-</td><td>以<strong>字节</strong>为单位</td></tr><tr><td>Key size</td><td>密钥长64位，有效密钥长度56（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1</td><td>密钥长度则可以是128，192或256比特</td><td>EEE的有效密钥长度为<strong>168</strong>位（56x3），但由于中途相遇攻击，它的有效安全性仅为112位</td><td>40–2048 bits</td></tr><tr><td>Rounds</td><td>16 rounds</td><td>10 rounds for 128-bit algo<br><br>12 rounds for 192-bit algo<br><br>14 rounds for 256-bit algo</td><td>-</td><td>1</td></tr><tr><td>Rounds Names</td><td>Expansion Permutation, Xor, S-box, P-box, Xor and Swap.</td><td>Subbytes, Shiftrows, Mix columns, Addroundkeys.</td><td>-</td><td>KSA(s-box)/Encryption(PRNG)</td></tr><tr><td>Security</td><td><strong><code>1.</code></strong> S盒提供了DES的核心安全性—如果没有S盒，密码会是线性的，很容易破解 <strong><code>2.</code></strong> S盒，P置换和E扩张各自满足了混淆扩散原则 <code>3.</code> Avalanche Effect <code>4.</code> Timing Attacks &amp;&amp; Cryptanalysis</td><td><code>1.</code> SubBytes提供了非线性代换保证安全性</td><td>-</td><td>RC4安全性主要取决于于初始密钥的保密性</td></tr><tr><td>Speed</td><td>DES is comparatively slower.</td><td>AES is faster.</td><td>慢中慢</td><td>7 cycles per byte on original Pentium</td></tr></tbody></table><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><table><thead><tr><th></th><th>Steps</th><th>Changes</th></tr></thead><tbody><tr><td>Expansion Permutation</td><td>$R_i$ is expanded by using the expansion permutation,</td><td>32-&gt;48</td></tr><tr><td>Key mixing</td><td>$R_i=R_i\bigoplus{Subkey_i}$</td><td>48</td></tr><tr><td>S-box Substitution</td><td><code>1.</code>$R_i$is divided into eight <strong>6-bit pieces</strong> before processing by the S-boxes <code>2.</code>8个S-boxes中的每一个都根据一个非线性转换，<strong>以查找表的形式</strong>，将其6个输入位替换为4个输出位</td><td>48-&gt;32</td></tr><tr><td>P-box Permutation</td><td>根据<strong>映射规则表</strong>，把输入的每位映射到新的输出位</td><td>32</td></tr><tr><td>XOR and Swap</td><td>$R_{i+1}=L_i\bigoplus{R_{i}}$</td><td>32</td></tr><tr><td>Key schedule</td><td>PC1\PC2（permutation chosen）</td><td>64-&gt;56-&gt;48</td></tr></tbody></table><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><table><thead><tr><th></th><th>Steps</th><th>length</th></tr></thead><tbody><tr><td><strong>SubBytes</strong></td><td>矩阵中各字节被固定的8位查找表中对应的特定字节所替换，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标，$S(b_{i,j})=S(a_{i,j})$</td><td>128</td></tr><tr><td><strong>ShiftRows</strong></td><td>矩阵中每一列的各个字节循环向左方位移，且位移量则随着列数递增而递增（第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特）</td><td>128</td></tr><tr><td><strong>MixColumns</strong></td><td>linear transformation 矩阵乘法</td><td>128</td></tr><tr><td><strong>AddRoundKey</strong></td><td>$b_{i,j}=K_{i,j}\bigoplus{a_{i,j}}$</td><td>128</td></tr><tr><td>Key expansion</td><td>若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]</td><td>128</td></tr></tbody></table><h2 id="Assymetric-Algorithm"><a href="#Assymetric-Algorithm" class="headerlink" title="Assymetric Algorithm"></a>Assymetric Algorithm</h2><img loading="lazy" src="/posts/8b9f706b/3.png" width="600"><table><thead><tr><th></th><th>Difficulty</th><th>Pre-share</th><th>Pub Key</th><th>Pri Key</th><th>Encrypt</th><th>Decrypt</th></tr></thead><tbody><tr><td>RSA</td><td>elies on the practical difficulty of factoring the product of two large prime numbers</td><td>-</td><td>{n,e}</td><td>{n,d}</td><td>$C=M^e\bmod{n}$</td><td>$M=C^d\bmod{n}$</td></tr><tr><td>Diffie-Hellman</td><td>the difficulty of a certain problem in G related to computing discrete logarithms(<strong>DLP</strong>).</td><td>公共原根p/公共质数q in GF(p)</td><td>-</td><td>A,B</td><td>y=q^A mod p<br>传递$y_a$/$y_b$</td><td>k=$q^{AB}\bmod{p}$为会话密钥</td></tr><tr><td>ElGamal</td><td>the difficulty of a certain problem in G related to computing discrete logarithms(<strong>DLP</strong>).</td><td>公共原根p/公共质数q in GF(p)</td><td>p,q,$y_a$/$y_b$</td><td>A,B</td><td>$R=q^r$<br>$S=u*Y_b^r$<br>传递(R,S)</td><td>${S}/{R^B}={u*Y_b^r}/{q^{rB}}<br>=u=x$</td></tr><tr><td>ECC</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>ECDH</td><td>-finding the discrete logarithm of a random elliptic curve element with respect to a publicly known base point is infeasible <br> <strong>“elliptic curve discrete logarithm problem” (ECDLP)</strong>,比一般的DLP难</td><td>椭圆的公共参数（Common parameters of the ellipse）</td><td>公钥是点 H，H = dG.<br>$H_A$,$H_B$</td><td>私钥是一个范围在 {1,…,n−1} 中的随机整数 d，其中 n 是子群的阶<br>$d_A$,$d_B$</td><td>传递$H_A$,$H_B$</td><td>$S=d_AH_B$<br>$=d_B(d_AG)$<br>$=d_BH_A$</td></tr><tr><td>EC ElGamal</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="Key-Exchange-and-Distribution"><a href="#Key-Exchange-and-Distribution" class="headerlink" title="Key Exchange and Distribution"></a>Key Exchange and Distribution</h2><h3 id="Exchange-Asymmetric"><a href="#Exchange-Asymmetric" class="headerlink" title="Exchange(Asymmetric)"></a>Exchange(Asymmetric)</h3><ul><li>dh</li><li>ecdh</li></ul><h3 id="Distribution-Quantum"><a href="#Distribution-Quantum" class="headerlink" title="Distribution(Quantum)"></a>Distribution(Quantum)</h3><ul><li>BB84</li><li>B92</li><li>E91</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><img loading="lazy" src="/posts/8b9f706b/1.png" width="600"><hr><img loading="lazy" src="/posts/8b9f706b/2.png" width="650"><h3 id="MAC-vs-HASH-VS-Digital-signature"><a href="#MAC-vs-HASH-VS-Digital-signature" class="headerlink" title="MAC vs HASH VS Digital signature"></a>MAC vs HASH VS Digital signature</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cryptographic primitive | Hash |    MAC    | Digital</span><br><span class="line">Security Goal           |      |           | signature</span><br><span class="line">------------------------+------+-----------+-------------</span><br><span class="line">Integrity               |  Yes |    Yes    |   Yes</span><br><span class="line">Authentication          |  No  |    Yes    |   Yes</span><br><span class="line">Non-repudiation         |  No  |    No     |   Yes</span><br><span class="line">------------------------+------+-----------+-------------</span><br><span class="line">Kind of keys            | none | symmetric | asymmetric</span><br><span class="line">                        |      |    keys   |    keys</span><br></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="group-vs-ring-vs-field"><a href="#group-vs-ring-vs-field" class="headerlink" title="group vs ring vs field"></a>group vs ring vs field</h3><img loading="lazy" src="/posts/8b9f706b/4.PNG" width="700">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;mode-of-operation&quot;&gt;&lt;a href=&quot;#mode-of-operation&quot; class=&quot;headerlink&quot; title=&quot;mode of operation&quot;&gt;&lt;/a&gt;mode of operation&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Workflow&lt;/th&gt;
&lt;th&gt;Advantages&lt;/th&gt;
&lt;th&gt;Limitations&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;ECB&lt;/td&gt;
&lt;td&gt;Electronic Codebook&lt;/td&gt;
&lt;td&gt;电码本&lt;/td&gt;
&lt;td&gt;$C_i=E_k(M_i)$&lt;/td&gt;
&lt;td&gt;简单、主要用于少量分组的传输。&lt;strong&gt;没有明密文错误传播&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;当明文分组重复时，密文也重复，易实现&lt;strong&gt;统计分析&lt;/strong&gt;攻击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CBC&lt;/td&gt;
&lt;td&gt;Cipher block chaining&lt;/td&gt;
&lt;td&gt;密文分组链接&lt;/td&gt;
&lt;td&gt;$C_i=E_k(M_i \bigoplus{C_{i-1}})$&lt;br&gt; $C_0=IV$&lt;/td&gt;
&lt;td&gt;CBC没有明文错误传播，密文错误传播小&lt;/td&gt;
&lt;td&gt;需要初始化和保护IV（原因），前面的分组会对后面的产生影响&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CFB&lt;/td&gt;
&lt;td&gt;Ciphertext feedback&lt;/td&gt;
&lt;td&gt;密文反馈&lt;/td&gt;
&lt;td&gt;$C_i=M_i \bigoplus{E_k(C_{i-1}})$&lt;br&gt; $C_0=IV$&lt;/td&gt;
&lt;td&gt;可作为随机数生成器&lt;/td&gt;
&lt;td&gt;在错误发生后，错误会在几个区块内传播（但不是无限期地传播）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OFB&lt;/td&gt;
&lt;td&gt;Output feedback&lt;/td&gt;
&lt;td&gt;输出反馈&lt;/td&gt;
&lt;td&gt;$O_i=E_k(O_{i-1})$&lt;br&gt; $C_i=M_i\bigoplus O_{i-1}$&lt;br&gt; $O_0=IV$&lt;/td&gt;
&lt;td&gt;可作为随机数生成器，密文1bit错误只会导致对应的1bit出错&lt;/td&gt;
&lt;td&gt;接收者和发送者必须保持同步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CTR&lt;/td&gt;
&lt;td&gt;Galois/Counter&lt;/td&gt;
&lt;td&gt;计数器&lt;/td&gt;
&lt;td&gt;$O_i=E_k(i)$&lt;br&gt; $C_i=M_i\bigoplus O_{i-1}$&lt;/td&gt;
&lt;td&gt;速度快&lt;/td&gt;
&lt;td&gt;对每一分组必须用不同的$K$和计数$i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AES-XTS&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;$T$ is tweak, $H$ is a hash function&lt;br&gt; $C=H(T)\bigoplus{E(K,H(T)\bigoplus{M})}$&lt;/td&gt;
&lt;td&gt;高效&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Symmetric-Algorithm&quot;&gt;&lt;a href=&quot;#Symmetric-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Symmetric Algorithm&quot;&gt;&lt;/a&gt;Symmetric Algorithm&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;DES&lt;/th&gt;
&lt;th&gt;AES&lt;/th&gt;
&lt;th&gt;3DES&lt;/th&gt;
&lt;th&gt;RC4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Basic&lt;/td&gt;
&lt;td&gt;In DES the data block is divided into &lt;strong&gt;two halves&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;In AES the entire data block is processed &lt;strong&gt;as a single matrix&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;EEE/EDE&lt;/td&gt;
&lt;td&gt;RC4生成一个伪随机的比特流（一个密钥流）。这些比特流可以通过与明文比特&lt;strong&gt;异或&lt;/strong&gt;来进行加密&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Principle&lt;/td&gt;
&lt;td&gt;DES work on &lt;strong&gt;Feistel&lt;/strong&gt; Cipher structure.&lt;/td&gt;
&lt;td&gt;AES works on &lt;strong&gt;Substitution and Permutation&lt;/strong&gt; Principle.&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;PRNG&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Plaintext&lt;/td&gt;
&lt;td&gt;明文按64位进行分组，以&lt;strong&gt;比特&lt;/strong&gt;为单位&lt;/td&gt;
&lt;td&gt;Plaintext can be of 128,192, or 256，以&lt;strong&gt;字节&lt;/strong&gt;为单位 bits&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;字节&lt;/strong&gt;为单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Key size&lt;/td&gt;
&lt;td&gt;密钥长64位，有效密钥长度56（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1&lt;/td&gt;
&lt;td&gt;密钥长度则可以是128，192或256比特&lt;/td&gt;
&lt;td&gt;EEE的有效密钥长度为&lt;strong&gt;168&lt;/strong&gt;位（56x3），但由于中途相遇攻击，它的有效安全性仅为112位&lt;/td&gt;
&lt;td&gt;40–2048 bits&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rounds&lt;/td&gt;
&lt;td&gt;16 rounds&lt;/td&gt;
&lt;td&gt;10 rounds for 128-bit algo&lt;br&gt;&lt;br&gt;12 rounds for 192-bit algo&lt;br&gt;&lt;br&gt;14 rounds for 256-bit algo&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rounds Names&lt;/td&gt;
&lt;td&gt;Expansion Permutation, Xor, S-box, P-box, Xor and Swap.&lt;/td&gt;
&lt;td&gt;Subbytes, Shiftrows, Mix columns, Addroundkeys.&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;KSA(s-box)/Encryption(PRNG)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Security&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;1.&lt;/code&gt;&lt;/strong&gt; S盒提供了DES的核心安全性—如果没有S盒，密码会是线性的，很容易破解 &lt;strong&gt;&lt;code&gt;2.&lt;/code&gt;&lt;/strong&gt; S盒，P置换和E扩张各自满足了混淆扩散原则 &lt;code&gt;3.&lt;/code&gt; Avalanche Effect &lt;code&gt;4.&lt;/code&gt; Timing Attacks &amp;amp;&amp;amp; Cryptanalysis&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.&lt;/code&gt; SubBytes提供了非线性代换保证安全性&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;RC4安全性主要取决于于初始密钥的保密性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Speed&lt;/td&gt;
&lt;td&gt;DES is comparatively slower.&lt;/td&gt;
&lt;td&gt;AES is faster.&lt;/td&gt;
&lt;td&gt;慢中慢&lt;/td&gt;
&lt;td&gt;7 cycles per byte on original Pentium&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;DES&quot;&gt;&lt;a href=&quot;#DES&quot; class=&quot;headerlink&quot; title=&quot;DES&quot;&gt;&lt;/a&gt;DES&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Steps&lt;/th&gt;
&lt;th&gt;Changes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Expansion Permutation&lt;/td&gt;
&lt;td&gt;$R_i$ is expanded by using the expansion permutation,&lt;/td&gt;
&lt;td&gt;32-&amp;gt;48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Key mixing&lt;/td&gt;
&lt;td&gt;$R_i=R_i\bigoplus{Subkey_i}$&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S-box Substitution&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.&lt;/code&gt;$R_i$is divided into eight &lt;strong&gt;6-bit pieces&lt;/strong&gt; before processing by the S-boxes &lt;code&gt;2.&lt;/code&gt;8个S-boxes中的每一个都根据一个非线性转换，&lt;strong&gt;以查找表的形式&lt;/strong&gt;，将其6个输入位替换为4个输出位&lt;/td&gt;
&lt;td&gt;48-&amp;gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P-box Permutation&lt;/td&gt;
&lt;td&gt;根据&lt;strong&gt;映射规则表&lt;/strong&gt;，把输入的每位映射到新的输出位&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XOR and Swap&lt;/td&gt;
&lt;td&gt;$R_{i+1}=L_i\bigoplus{R_{i}}$&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Key schedule&lt;/td&gt;
&lt;td&gt;PC1\PC2（permutation chosen）&lt;/td&gt;
&lt;td&gt;64-&amp;gt;56-&amp;gt;48&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;AES&quot;&gt;&lt;a href=&quot;#AES&quot; class=&quot;headerlink&quot; title=&quot;AES&quot;&gt;&lt;/a&gt;AES&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Steps&lt;/th&gt;
&lt;th&gt;length&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SubBytes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;矩阵中各字节被固定的8位查找表中对应的特定字节所替换，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标，$S(b_{i,j})=S(a_{i,j})$&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ShiftRows&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;矩阵中每一列的各个字节循环向左方位移，且位移量则随着列数递增而递增（第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特）&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;MixColumns&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;linear transformation 矩阵乘法&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;AddRoundKey&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$b_{i,j}=K_{i,j}\bigoplus{a_{i,j}}$&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Key expansion&lt;/td&gt;
&lt;td&gt;若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Assymetric-Algorithm&quot;&gt;&lt;a href=&quot;#Assymetric-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Assymetric Algorithm&quot;&gt;&lt;/a&gt;Assymetric Algorithm&lt;/h2&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/8b9f706b/3.png&quot; width=&quot;600&quot;&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Cryptography" scheme="https://hejueyun.github.io/categories/Security/Cryptography/"/>
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>实验：靶场渗透测试</title>
    <link href="https://hejueyun.github.io/posts/d8c3738e/"/>
    <id>https://hejueyun.github.io/posts/d8c3738e/</id>
    <published>2022-01-02T14:06:17.000Z</published>
    <updated>2022-01-06T22:01:36.560Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Authenticaiton Failed." data-whm="Authentication Error.">  <script id="hbeData" type="hbeData" data-hmacdigest="b837fca8ba0f65d891514e5dd70693f3332395bf01b17d1ed0a5d4608600339a">7ab9a17ca32127080b77e873e4f9e808b190e7efa246dd5556933ba5299c5831ff9ec39b24ba3046fb8d8c62d6f77dec24e1405ec968f479531ffea387ce2e659a05899186dcb1466c87ebb8b9b10a78aa418f4cf82caf75e9edabdde52947637d958aa58caeeddbb9c19e14477b74ceb258dd5782bbe2bb5bf7a261d5517aa85c6df7f046d67542cab52643320ab4bb656a22ae83e09aff863aa429edc91faf5f1c72474b9240d8342a47f549eaa99dcade286ac81479348b2d239ca1899ffdff22f247369294454da9d5d384639bab6f60182adc5dc9b0a5e93ecfe28997da4c9e38e96b76d7a6553db32fe002510e691740561d7e35bbd8a71693f50817771607e9c5b9c9e391bbf0427b0b5d69913a30adb0a40f80394f193024231fa5f14703ca38a35f987f9c9fbaa88a0dbf5f3720bd148bb8885c01eccc2a8364e6718f26de08ff43d6abda1a0f57242099045e062bddc24dc3381f39e66b1a1cf27701ee89820665a28699f4d60c9f1d10c7f71c3186f6969a3fc1215cc09c1a46f8afeaeba61f54a995c92453720782fa9a6e5ff5e4be70d34e293fca33780b6aa51936ecad358a4a11333c1a1bde23d936671839d831eeb57ef6fc5485adcd80e1e60813d19f8a9581b174c3ed6a939a81c34cfa9c145694a41c28981c879bf4ef3712d58a6fab9055316ee609a80afa0829f71e0e1035e137b4cf4a3ef1b22861098c341e288478b5cb56d7f8a882449fa889b8bd52b48ae7cea3f7753e9a1946ae008c583cc580f052e8a32efa544659539c375ead50235553445e5200434de01b78f9158807a5dee8e76688aff0eb8842c701fc42fa9f201af5ffb9e5951844157c6cc687053056b378b59230fe3d09ab575c0b15abf2e3e4be0710b9fa559248df78d43c287d95c190ddf1386af45842d1e5da422b29410fb00d55919bb81b5cfd053c80e2b9863c14424684928244c36973e2734ca489b7459bf991c44ab22106af46f92ababd759e6afaa481089af1148ee007bc9884859aa1bbba5a42d56fa41f94af25ed649681d05e487f2ff0370e3ef5e357c6482a2fc0caa54ba9e000a9cb700a9353e01363681f8287583aa59d710ab3c4c6f7ff471bfbea9e90da1ff41fb590320e6722bb49ea470e2f22a357221b554544f7ff68644847ffe4b94c9422cc7abeadd4ad53e816c44cf315a6691c5944262d3b5f14e41f0c4b0b3be603d557ef5853d5531006c624fd8aa77047560c3133e24b7aef99d872532dc1aeb09d5bdee85e59f2ddc0c983394be2e3266134d314bd330fef3d2152a783719a9a9f5966d42883a9172d715e97e5e76f77fae3ad3a5e0b8d58af3fa8b1b778fa99fba704a867ed4c1c0e3ef31ea9a87e313fee76706b0cc6f2ea1d4a680fa09aeac19270c67b949afa9bb5944835534b16ebedfd955433ba06a922a38c2a78b5acda685bb3116b624d98c7432e836fc83588e65f70add2af8832c678e156c96e0bf38aba9ad816e75f65cb962a34796a294517b364391a6bc8f6ffbf9ff057b69741654b9ff636c761409977dcbcd1be4c504fcb71a51ea8dc0174036c7f40aa22bc756e2f8b556c99fd5c019c063a3baa54a7aa2236c40c1e9c3fc88cfac8f460af6b1e8aa09edb9572fb65d95647213c20de73ddaaa1ae59b8a38e344c721105e710bac3fb1b08e191209b344edff9b397dff4cfbdef24f03c35676d85df1af6a2b3e345a37164df59102afc8113a2be8e7c58528d21c39289e2b74f6272fdc2c153c78026da52e39a60cd76c0f0ebf1cc09572cf3406c73ee458e76570ebb958b0fc9baaa4f5abdf0d0351546efb98c6410214d71dfd2fb83591ebb82631cad1329917f3f8be295eb35cbff5b90774e9987181041144f0edf106264d61d9f75bf23a6f60714ba78c72dead80f3abd84ed6d14bdba5895d69ae92be37ef86212e40f7ebf8f4bc799a39a35c98a10953a597326436c46f1f6c02e626ae45ff48d94f5e19c35c37ee11faf9664176a9a91cf23bcb5ff0a300facd9b27f20cc5c1d8623746385416c545814ee33a0f120652293be64757caa9be99570f0d4e1116ad87cc526cd77ea49b4145661134b9058937171d629df25255e21f2b9119ce2ed6a3a4037e9d7b1f221d9d6d698616c34032453e1bf904ac2999fa11d164b3da916598e6ce219dcde6e7750b4a4cfcf21c4617a54dbfdab677660f4f81503c048241d82c89fff5405eb1c68828170536a948f75c112351c509c56fe82d0fa86dbbc2dbb947456b311b5b4b1abca9f9ccef482929b4f16bec4c819f84539e52aef2af66c9363683074ffdf5501a3dd8ec0f69c7d5507beb8e97778dab444f2d31516e09624a2f7043a01177938f607a9e952d526349e0faf7105b08bab1108081d08ee8c54dc784d8c3af6eab68867a9aa3ccf948ba5c0260aa763ece94abf0afe9643c19561ac2873257ba0b846588ded5e454d0d1a5eb76ab7070b6c9641744ba00b416c91d96ebb22dc4bc7ff5c1d2bd0222a92905d291e9b165d8405046c2233d540296e8601d9239091cc739d9724f4f3516ee3937bd3ad01e05e8c1fafea7d9fe360f35708ee347ade27cd0e1d0b21d4ddb6bb9df7a49e2072e5201dfc756c227ac1053771cc90a9a870155b4dc31177e925242bc1b9949fcf355d0bfb892c3bb10a753365d1b5df78e42dfc45d10d42d1965f73c7fedf2511f204f5b3462aaf183b4e05e2dd1fc7ec8410391cf424c21853676ac6184f25889ad2f8317fe6244405866f75c4117f1902eda22abdfd262b5310b8239ea0d7b9e373a66a498bc2eb1a88859b7cb8aa06331b53e0c35a67ba54812fc298bf19cff67cc859fb9ba0f7315b64259b6eb9f37165b36a134d4165dbaaaeb5c2e474ae82f67052330903d0375114ccbcf1d3415fe22c44ba0abeae2844e7803f8a7c8d30c017a21892b5d38451703254b5d68dbb473a7aec37039e96028b2fc817070a72af5c80a83588416972ac5b3c69bfe50b567b9deb8feb7b519d435d3a49d1dc65231a7094d046079aaa2427292e82e665724ce4469f098c62ba3d37f02afdd768088d136231e51cc6193dd560d878335e5caa06f7781226984da2ef7f408adeff17aaeb0e35c8ccaa4da55e20153511a3bcc38e6cbb37f13182d7a855020205180a65f8018f3f434381e8b074b45bb0b95aa79952028c55283074ffdf9b0562bca4d9b051db638dac406c91cab83202c1a0110e75473f9336d9241d4631ba455639e31b6e972fba01a252f86d800dba7d8321c98d8609bb919f029d6c8bb1eb8d8f4e092e968826b53c681f3a8cc19c7d04af11e3136a766ed00f0ed86b2ac410d4a8a3b6d98636bb0ab29b3980606884d20512d4105db7071906c3d4bf12a1f6107fc6d8ff8976470ebf4bf4873b9a16b6e3f821c7adf048a9b2a1137e9d86105b8c9d14d58608d32b2045ee90eebc81ecaf801d644420dd0ccd4ae943c9cd29ba2fc2d9e065c523ce6632d491b85db0c811bea0ec72bf82e1c4c960189fbecd42663986104b50e713c34247164c742dc05e49875181c8957babfc9835a217de0321686370d86b2343b0f9caf6c7a4bb8dd54c87222281903a0ecca889a16cf36ef9550c1182cd530ac2f7e925f65448c8781cb328d01f9ac9209a2a7895c0fe63f4dd7028bfeb17222601c0460d7dedf31cb9f3de5eb926d5be417ffa4f0cae2ac6ed04d7f65db6c9f6e9960e62b1e529543dff88c6066aeb09eb7122dfc72b423ffcf8e9a8fcad28cde3c0a3ca32b88cdbf16512f93cb1618e674fb3f23dae69e8edb06263b86463f7c515a84ab2a229ad93fe08800a6ce2527486a05039b357cd14e8ab694bdf1771323179ebda2c7e63beb763bd0f925fbb8668afa30d1251b1d4782f7d2a2dfd56b2322270bb9bce865e9ad7e01fbaa1294d29052b9284c0bb9787d6585d1d7f24a400b03728f39a7276e7527571770596c80be9238c6746155a0599621579985824f0d6914eb1ce23ad4fd8bc767d7962cb666262c87c8a961b9d1006882d6bff391ce9cf99738b59d67e32a6602eab92b1cb732f11848d577fe2b9247ff63d012ca7708a09dc17a2155846973ef3be263659d030498ac42e09e4a2717ac96559f1e8da0e06c5cdea8bef97951ddb6babb2b7f264afc9b253fd6ace12b7f32760607acdedacc6e2be859ca024281383b53edc769dbea00c1859a739cae741a1f1f447ae439301f3bcd33ae0afbca33ad812ad13bcc7e7be1d0a12e07e1c4e1ed69108ca159fc8afad3a4d544a3187b392fdd82af67fd0880404ad127da761b0f04be9f46f9810343a281c45a3b4277cf8cca719606f295c8cac4dab1bbc0c26da0b14d5f9b94013ce213f6d9b871fff02d05a22afbaeb9974d47452cad0999d6a673ee14029d057d7ce665e47fa787af5a8106916aa83ccf85e4fabdbef31a6627547d5e7402fcbbf225a690c7908e589324b87814a8cd32681681ceff20e29287a6ba70c66af870abc5efa64afba708db2addffe11687615ce7572b4f2de5d378a2c647a14cb922af2040c974b4eff63ac1cdeef7cca8891b2f35074eba79928538219ec64bc2d669f2e4c617fb94c9ff1ef90a31805385a3a247cbbf46d02d1c97dbac0864d117ebdf622666cf45aa9b35d171ea807749445ce4b3545b43690f90bbd67e6305ae23255dde1d123858878804d820a8a76014837ae944f01f46140e6a854287a9c1a9436283a6c96d3e1a0ba67887ee9ddfb0259a0180072bdf23af6f24bf7b6b47c5e74030d036f874d508e5c8a132fafee90985177020347087cb2383d7f4b019f6f9933c6b46693a7741eac1176e731ec6ad6b9cea75d2370d60d3b692fa2ef479320415c17252f9f41897493ae72052fe27f7e64b889912423f82a6d22232b430c9a5043b571117ced67de9c2f4b4fd221cd31c7173c04231315efbe33f4bf458c2ae73e43ddd2d1a5073f3e570d216a9bacd4cc6126e50c0171ee669429fdcb3d71fb62bac3dca0995b6b741cdfb82e9deeeb7b200ac3d35c496f8fd932694dc3923b8d0d03610b9604964463a905aea5c46803cd82217a6afc51a7cd42ad274851a16afa9f60c7227d52df52d981544c243a86b6e3b37cafd6f233dec8b8b2c3e333a18bc18eb8fcd94b1ffc08f0684c14327e92c727ade4ae3f3e2d1425cb2c7a39c1a2bd3b777187451c43ba41306dccc867d1dcb7794b31bef86332e7bbba511a26eea69341a3c437a7eed63a2854bdff5916df915d7063cd21f1dfd827aeec3ce84ff44b650166b51e2b631820b50b73f60aac910458b7bcf7262e2fc8833fe08c66af5af37b846ade36bfdbbb7515f5c2c932295c687053da145e07d73b1c8f2438bd82a025e44b4b2112b0aef0604441d5b877dcc63d1bfc64f4ef0523265fa94a97b2fc6ce20048a298701099577fe03ac93cd08df1cff9d2be939ce14637d6425e31f43a41ce48c76389847653f5b5d851ed0b0d9fe66a478df4cf899a7ecab8f19f9378426bde500106b3586064023ef00f645aaf53ff481a2701bcf6cb0496f02bbbad12f9989446abadb05a3a9f70209200099c700d162b95e8d8250c881433046638f50019e4edb3684aacc9e1e885940ab133d039d9c16139b6d1221185219ef753ce1072ab00d6290604d8f7ffcf92b162955957936b8e799aa47c2c1c628758249a2f500ce6d9351170e4dc11a173a686d6c1b6145c4d79a30d9193903d89c912d058d795327a201a21b3eec076e0e695b8d366bf68512d7110ccaac0802c0ede90a1fccbe4cd2e115019cba9c6ac025142f715ca55169d5ac8aac9589549e0cec2f10d51d69b7796d92e3254ec96ae9c3ea991b39c8b48ead89bedb4f630fce212736ea97c3384530b230e09f09afd8424cced83afdbf64e6d956b2c82b7a5a054a9ad77f900baeae94978fbc2519d131cfeb752f1c5392263ef051263517b2e86108a5109b5f6480449c478f436eac5c2f2fedf669db9c3d6eb95cd9d1ddb22ee57413c533bc674419580f211d3e91c4a9f7e6146f8050f77a60af946cabd71baea4e7af3f94a1c5cb26e303ecdd3eef36777d219646392e116ed62fdbab6ce7bc3847dbc53f19ccdd5936076a9f18bdec9153c388ed94742419e58b403b55227319b255efb57af107452f06f6ca5edd6161b5d6fc44d20a6272c09adb2d96afd536e80739e903e71ac098f836863ec05cd96de50009aec5b857de73c0e5cab55c5c267da9a168d81659ed9ec8b5c484b3fd06142ab42ddd5366cd7bca237c12dec710b7f6a5e66533bd59a28c34e58aa2a9d95de7803c50f69a4943fe5be1db84a9b0ba0d559a8167b02c754810a67924f3f794702ef5c642255ef3d96e53774b20c29e8acd217437cdd1e4ecdf7a263c96a1de4d67b2849143b229ddfdb39c57587fb311d07af6ba7b028807ab3d7bc0e08368b0c2d3332c7f6a68c6566b0631b175c4d8082423e020964a37894d7644247f4f5b677d687d946601c930feb8ef0c909731f07f4ccbd5954c49012caffd092ec3be4a43a0ab186bb16ac3f6e4a7754b0493457396a0786a0055690cca0d08fba7a3ebf305b1f70621aa6c24d3155e17f1776f7d53719d6817ddbb36b8c0130c5cd1135786111c77d39b486e7964d552e8760b740d2de099718c0c97266f5bab87602db2bddd52121c2e2f408b5fcc31110eaab2b0de9f0dda372bb1e5b7e5f40262cc7c2ad388d17b7252ff187404fabb06413f9f998a9cf1711e3bc317f0a22b1727836125986e8a72620ebe745763c231648dea8177398d24f2d2c2ed1cff80e742568fe8ae720bbdfe81546909418bca9bf23eae62be3beab992b4cd129f1f699989d197e4c12a635bd4da999d89efda3ad9e6c22f9c20cc107789f128a7a9b3fe295c5e5d012acbca91f4ae1631db739cc12f2f7180d421be9508942c4a24f9941ff6ef8c522f518806685eb2fae13819a5a3fc06b4bcedecdfbb43a0aa1f163e9dd91097b36577a5183a20ded54e4fc77f7c7f45b190689bec6138809222484b7cbbc7f2170ac3b250f8e69e2ccc85199316a11e872458870e1fe5353ddbd87fd1bee87101d64f007b684a7c454e90e72626f0b9a0984ba8df867e427ecc6599d8e554905c8f1464d9c7d151247f6fc25df9a92b8279f7e9c14bd929a24449665f3ed4f22a08426ffdcb1b94eaf86adc6d875150a838d2d7cbc3d53c96bf9954041fbfbad3587d72784224d88a547aa5858854169b1b6c5276a06423813e745f4e63348ab15dfd840bb968f2856bed322e2053e69b7f106282e5ad3bd884968cf78e74a1d92a305f5558ca2e2b3bc5c55bee1b8d20e861d18c6336038b2031cdb40325f44f86e2f48a4c45ec04f543f09f3ed28aea61eb14bca905e71764349bde2b65bac028478d6b1fae846d203fe1548fa8982d1eb1c5f49a4fb7f6bfd2bf4e58121b7f5c6125dbba784dd1da75f2c08894c1ba3555bf82ef0cb3e3d59137b06bcbae3f10f4bd9e60c2e4ede7ba47bc58a5b99ec7f3c1f650380c6d73d4b75201a1739ba4c7c40bd08729cd67f70db35f496efd449b25e0776e7f8f5dc3fea9030547c76bfe97935ab1cbbcf6e99c35d903484023fffe57f7716f7a4322eb5bd1ac86a6734c0778a342a40dd1a4661c0b6aba5e9b1493490cae4929c8c459d93ff5a53eadf4f310f2e9561b38aeb2cabb5683733f3763cb6d712252c63ed5e1f1308a44529368ba0624e1980ef2c56aacdbbfc8c626d659444a648f9c46e868f56c7d969cc9beab5c977cfa6367d9eec09cf330a7f78c9e7cd24c8c7eb56e9a93a3d7721cf908019839b1511816e629f7930784a6df6279ca328ee7ba33f9ce9524919f7d1aef7b87c3ea6d3ddb8b5c4a0f2db35683914b6111a2288a6090572a59b9c815dc84265cb827abaacbcb4d18a0db70c1e52d90b844ba899caddf2f1762b60b5c23eba7d1cb3ad0ce8a45ee83c8e781e67bdd2b367d97c4aac35c5a2a92b039b05b63b563322e53c053b620000b0dd5c93141e67ae556872ab14921d8aff3313b406547bc5b6459027e5a09839eb0b745824ef2e5da9184eb232bd78928dfa9caf8ee314afdf3fbbe9b6dcd1af93faf11680d378cdb49cde92412a4fe0ad4cbff5eef85f0e771f675b1359c1969416ede416851b80a323a30f32a979e6657be32b321e6381e1e5d5f912ccb6036bd31efe5dec749b0763648cb879c3acb8a94eeb0a6f42ced8be5ad653edb3c786fa5a9e2139625274eac639e9e51a12824bdfb9d8c5984a2687f4522c43e6ee1ed3235aea172b4a8c08ef28b5bde62c43fe6cbadd16be713930e2d7175c82b1f57cb886385f40ad3ee52baad410edde642bc6b0ff4b489feb4121adbedd310ec24e627cc56d41ed955fae9fe19b5ce1365b5b194cc9c68aed8b14b06aa30cff744e1f7d6424267557585599162b4dd2c0e83e14ba52b800212f0a906f99aa32fe02356165ea16f5ae9453c4b0985d29abab663eee9aa2beb761635eb6cdf35902052a3fdd0d2881acd1f466b39826bb3f382def1b99faf6ce5fce128e32f560b06b2090e57073d784cecdba6db341ef31a8f8bf146bb4ff89156d45fcd2bf33e99fff0e8a5b8f821b0bb384fba64a7e95935c51a467d93bc81c430954e7dd6f1c3d70df0fa764364919f969074b760c39e842d1d557e6a36ccc874b35ee5400a154ac012e0c6d367a446211ba34ef4e2b4316526f4a9a77dc6fea1ba8389a9d3d717088bc513fa968e5722e50c4317d35abf411ae1bb7ed81f60082b490a2b67e27e2b4cc5b39f7e8ed9a1c0e24bf548a8e84cf0a32604391d274219d98862342790d88791ebfcb00ad564bdf130fe116d82c74066a7b89e6939e8f87138fb57be066be8a11c89c09dcd00fbdbb85a5693c8f26f4096d9a984eba52fb0db3f2c3906b47740600e2a36e946a95babe1a2972b733d85fe5bdc8d2c2d68ea44a770afa53ccca71a2e3457f580cc2a445c237cf5a9c143c4a503d88317f04e6fd49ebc5af5841156c78e423b9cf8496cb1021103ba54a1b0f5df6e913bfb8f310c35cc4b0c2f87b04a81e07ddb664e1fb688ee18c20c7184f2f2087cf9a37f06b7e8b53d8338cb6667ce160e04d24bbd8276c8447e954b25a7c4ec2ff02bc48e1ee094e65ece344aea897d5b35a491e063e6cc6f61ef930e162e795d892f27cda9068416119d8b9a9809eb03c67fee73aba1c264ab55691796ee9d95075d90529d302243d98b765b13329ce9b7a83ac04326b122fda9cf336a1ba7f0f3fc56dadaf5fad8bcd06ab66a402d40471d0fb1f8da9c032709014ca6e6147b94d2e65c9835855c30b01e534434713742f3ed7bdddcda17156152ac4ccb66cabf35c4545303359c683e4bee2852ece1cdc92b75830ce8eaed7dde733f4bfe1e45b254fb8b596f6cfc272145cef577c6545292c920136bc58ba3b12be160229dcca2951ee194fadd504fd78118abcc7f801deb18fd8faee6fe28dfdb269318138962f9eb523621c00b3d712aea26b1ae73ae6681e8e5ea98cc0fac6c787c46994dae5ed8717e153cf2f4f646ae2268986be45665e7ee407b60f44a78336998528d84ac8fd88a61f12ea25398f4424e961030126996130bbb1fd3421bf3171f787e2424f94fb254b9336128d59e21f9a2bb38de18bf60c11c1074c39f1f978f0fe3786d6481815afef7a5bfe8d9b3e1d88915803e96b4578a2c80442b67910fe3d7ac4b3b459ea278002185dc8ef44f359069ccda870c8a5390171e8b94347941e10040290a0d7923b8229dd65fa90fec206005a78be784f2df9c4f6b790c14367f7a584a1952cd51f26a6ef6e35ab6cbf16159564d8432af645c271b4e8cbbc6739e5a4ad43e4e497d77b4adcc0e06dd95f3093c7464c0d838196590f7e0ccec629a146ff3170b920259f41077475f30a56db965d4102d74d7fb7771218d8930b618e5d3103b8df0b556ef7cea1e34918db969f1f91372a661d344b0e42db46cb0c40b64fc044586c86d8f07c49d8f04d3ffa968d271286794558ff9bae8d8330fa515a50c0b48e1c55dc6db2516e0de043f380dce7d59da9194391e664dd9e7308be3e9f94b3c5d34c1bffeed129d7a3a8d997c21fdcf8c09786293067abf3988c36abf5a22d351dd5d67f30bdf05c84499069345fc6c4263b3eaf8bd77419d214907ad3b518db9239f5735e0cdbea403eb14e1d55de73a148b147dc1ba1f1cfb68ce4daefd2e56192928d945c5988bbe91190a2b61f0ad74ce9b716b4b4d41608bd01d6b5713b95f716961410f93eba1b1201db675aec396afd75f0beaab57b0d89b92d67971d6f553c6cb9098ae5460259535793f6e5f9add0c52b804eb7257f24eac53de0625c1854943237efd030a84124eeab13d1e4aa3b55016175d1ed3c67fa4448eee25b86a8207808165e8f6a4d9223889b27e4eefe2c2f57f72afaa5afaeba0e2d28d5ec4314a5c1d37d4a00624df34be86aa8c5d06c3616587c19af26123a5ee0e83b526958dfa035df9edc9c5cce8065be31d86b997224ef6c810b466c7453ee5470830d4750dca6b45c881b2a1484af3d9bdf1138dbc117b921faa5ac91e4163b687d037d6db67de83c790ecd5a9bcbda2ca7d8a8a658004bc12a4799855d3f97ba72bfc5a855152783fe557211da65e83b4f7dfcc2b38cbc5b864139e50545b64096dab8d588ea7e5c2b8fe0fa2efe985c30065b07f54819fa2d512d400c52dd3abcf4e515c5fa6e938f01b53edc43b5df961001f4f726a08d5b782930e0a2908ab1932ca70a2c787ad5130c414b300b5be782e560b48c75ad299626190040759563b25ddfc367994e177bea2e696995165538e5dfcc399b57f76422045fd7aaefe7d76e09b88ca42122b3d13ef3d875fe3e343f7bcf660b6b862b8d95c838aa0cc728d8e21be3881b08d4499da5559d639a418710dcdb097f7f7dc6a837f4f4d96ee763484424d34eeea158021e5c8a70c1925d14dd657101190c8d89e5365eb3c43fb772794df19b7788e232c4c9b24eacf93847fe3b3300e42aab8c890e8ed13a7cfdb842d0d926250e253151d8187c940a63f8081b9fa141e048df30e31916c78c90d1d9e7546bc100992ba39860735c37b8507d1dc710610ba84c9f9a8f24b7a81fd47ab564b7c2ab88293fca9407314668d6b2b58b59996b016c27f6ee96b8fa5a932fb1aac010b6c1087002de8999b8604fda5c2108d6f78abff9009d13c69e767959e38fa8e71019739e8cac91cdd268123fc4eb8de13697bb450b6dea3973edfb54e0c70be1b385aecb5e16851273eddab8c8f47c8490eb0e90622ef479c0a9f90558702233faf46d0a120323eb69f41ac403339f52dfab0ab6064a6f6d1632bc04a2adcc11dba721ee5ffa4246993d39cb48679e49f855b3d9aea3f2151d25cb1a03c0699e1f10a6174ad6e1c01b1d41a348ccdc1dcd79ed7f62aa352b692219f73e20ecdc25e49b328da97e7bdcea12123106d2201ae8e8fd7f8d90a9283eb236ef7a431a9beb55a1498539a2d8fa3a55e619ce271fd727689da959ef6bda0e2e0549ea87b086cdf70c95c8977eb8b9705161fcc8d4e7b0044ab0bc9b68c649db3ff351bac09388cbcdf601f54fd7a9f174eefaceac35a935d38c9f1a2e54f4e3fd99f3f0904d55e184ad3f0ba88a7be18a2851e61950f1990fff46c4c4395d5cfb750d45dc7c9ab00dc758c73addad74d554a6c274819a04ac866a19d782992273742abd978a807052f4ba2005a7535e841abd7fc98d7e8f933b479296a52a2fd87c7e6b69828f0f3cc67dbdfa2bbec59850421e528b2b99c50e4593bd6be00641b5e8cf709b2059ba7118dad3bf6a7912dd7360d0446b95009535ee5ac8c3bf2df2c0f03965137cbba39f5e3d7d3d649b3fd026750627bcc33182918b2f2bb41fcc1a0d6ad6bb354b00269eb448c2c8c4eebce10a08af2e94dcef9d0ab2e87caec57b6f1945ef2534c8000a21fd870e6d5a49ff9118857bf7bb9838482102c8a4651bc9ac157a225caafa3b4cf00bfe7ed8fa3d7429dd0ee7b441cbf0ed7881aea49908dc66632fc284c13abc70ab6e42c0289850a60521cd3781deff2c1ed1f1347ae7733d5b2ea7471b094f6ae5e5cff5ce9729b676cee54b513d42e458fba3d0c4ee4e81ce5b61605c932a0df97474a28dfeda7e1aa2f2207396c042bcc6a6103175e1010703b1e0583b3f8ff3cccef385eff0e80349f3f8968cad71eb3ecee7e6a26db08b43012fc034d39c8295c8ebedbf93eca532a66dbda014d4602c482f2e9b2b92442ceb74587abf247e500803ca5e17ce053f127a37d7f3dac394ab7e4606f85abe91963ec0d4cd241ed5d0bc50b1d6da7cb6b795de0b1307b1db92c7c3372d64350459de19b821102b3603866a461b209981c1452b14a6939b7d3e2ca071a78c52c28a0519b87dbee91bc2783438be60f04bfc996c977b9783e5fb502726237d1dade5d5bf3266f656c7a4b584ef26eb8ea34219b7d7321b770f343ba68824e8b2dc5ca857ebc7e232b96111795d90e6e2e3becaec2076782b852c0346dee66e82a24fe6db473d1baa7bd4300b4c78083ff9d3da6bad3cc3dd7bd152f487d44baaa087c25bdb67a59f3c549942c9dde5fa3de02b722ef05bffc33da6eaa7bbc6ed0f96ce95836d83aa46684203f010089c61bc6e4bb4be0308e35b788e12f5ade433a48c16f5c6b67cbd037105c02ace832758f272659de5d83b432628222a3b48d8ba4e3fa5e1fb5746e19a275d06c21b3d7761780da897c2bfa5f737c39d891094eb5d761a3bd23e6cab8e2f4c64546c917796b4878c1361f6ea5f69e1aeb4d8cffe4f3f9771d37ec9b64e312755b01435784af6100a7ac4ad0ea7bb3d250c227f3516ba20c7e32374d4e8b51a4fd26420866bb5ef219f20009787766c8d8990727cb0e82409e39890ed27a794147ca168b76ec54fb0ba9a6953a91927cdba73818929f383fe8457feea4a217898abf9d71c1d379076ac840be5455c51f24e8a0489d45a6bf98de330c4ea3469a3e49bbede4605eef08e747b4a4be7d580d86baf36c5c44367d8b8cf1225ed1475564726214a7ccf1dda1112313ff3e49ba8c8fde5e54b29e28490811c753ecd56c02871358f236b890e15ff9e26aed439558c470fa7b0e07e58773f469e00a64f70d3747202f0cf18b30b49c8263c95e0c004ac8b8819bef0150bac33668f389c79aea4f4b7414a0daf0ca409c507dc1b0262824d179e4c1e143dcc7940f57654228d2be40cf4f0af1ec08de1593b213ee007b33390040d2993f62403485aefe200fc21be2a543de2065019de843d9b4dea3f500b36badc1fe869ac590692a22c772d2798a38d43b77f3a9027813dc624ec11275f7c66ba463e07f4d0b5b1ecccd4a3d256451b8f4dbd5d89de871b2ce5536a5c657ef3aed910921520c361c12453f12bec21ab53f32f03f24d28fe56e09b66a17ddbbad0aa133b75fa6586f9c0edcdeca86670dededf9411f5e9c49f9b93e86bb1f627be4752dcd4937a79ab8ff2c48b54fe2441f46b641b348fca8b32dcc6205dcfde36e3978f0ef091fa8dfc9fdff3576785a1888286d1474361c862971c4aa9d5d496dbf4609a6efcfe8d35a9f8e37efc0d88aab8530473f7cf43ffedded8e4cbeabd100efcb05e21ad2295c85f29a31a9aafb2834925b6aed63d0637338893050656a32e43864c4ebdde3a18a1312d680fd25b25d964a636bfc6254ac371bae5102c7940e099f0ac3522d564331428e2e64aaf64c3b7fbde7e56d3d5636645286ba028c6cc34cd9a2119faf5849ca739ce31f4300f17d7ee3b9850f9bbd6f0c5e9869ae76b4c3f6dc1c435b238d3bdb1854346375410a1128acc0c4ae1ebd8e8dd753e79173d66873d80aaf44f104c2ff543ea16237dd7186cb5a4e18ce0b2c1e5bbafe230cba367d50a0cf19a8f9bb57c3622d0a4922011127a6af437cb3914c86286de2e0a072973182727c4a15648925f6910478df03aa9e0e3e4c9b8b34c756a5882896e0dd65029891642c738e673d55a35c7e428730b453fe017d0e4aeeb00afa0162f60a5b97c5c1168baa08f9a9f8d6ee5157cea96efd2ac9fdf7a1bc3acc15329614ea022464801aee8eb0b711a3991f61951794dddc52f8c5b86e953a01e14f379ffc4cc8b42ec92137f8577ba7917545449ce492f8951cca0851c6895bba10922d57d0607cd9ff70e67ac901e91c794297a31a804f3ec00fe0c94735718ff1991d966b76cd68d286689960991b55e69f0cfc17bd77c02c437a7b98a1e8a08ff86ce4c491588d7f8a0bffd6e44fa1c79778bad3c83d087cde909c56592a5716d9db88c34d922551729a93a602a69ba497d709e4397a7fed128eb89a356f7a1f561beabb047916ac0c2ca1fed3d8d5330f6d1b485a161fc5dc22bc4050497964c77eedfb66fc827de930d5ee50559a6aa99bfdb46deebb8dacff2c6789c3180aaaa0db1ebe3ecc4a544eeb9a2c053253537402634319d7d17a4b4e4d193052374b95aac03b4689278f7ca86373e8ec32832bfc1bf00fbd1b225bb3d388f26e1310d49e973af87e4ecb5a0573faee2cd366514a2fb9303c459be09d5c7894808db5555368007227b097cdf2eb42693013aee4ca2345ae20b9cbcdd615bfbb0d3dc2323c14cb59d529bcb80b9c9b621fa9d517e80dd2a5e74be7131fec94eee511dee8a043bcfcb9b2e9262efed89155f3a90eb9869450c07e5bffbf0ae6504935a6d078499cc1be7f11241d5fad90326ace20c94c93089c1416e623b301c981d3867f01f2cc8208c1f29f1abcfd977e9d9c34a20d403473e89cc74e81691d15b2790fb4a96e1a4b698c211a7ed388240e176bc8fd4ff95bafa42538277c206b6b64c6200409b6a391fc31f428f250e94c953d57b4126676af5a82b939b662c0ebfa853a3f9653f2d08bca080e4e3f35d34ffd240d5c12d2943aeb7003074dab1995027177a8f5b1042328fb2831e94722c4d2e7f05e9e0b97c35cf2bcd7044425c8f6f082865b69b65fe905f848faf2296a2351247ad9a372cacb326a0714f40649a5c93b3be4354eb33869021a4b17bf64b782699ef80b489a1925bc09b0511ed88736e996def82745788b671cf4086744f497df40abd95436fc5007be0f64d7cabecb6a648b36c8f7c8d0aedb9327c658cdb881d6254a39c3c743c23063bd5742bb5d0ce59d59c0a2be9241fa50acdb4f2751f05c54b2622cedfaaf1ceeb5efc874f18d96eadfb1a22c16f93bc7138c9a385a8dd11af9243d294b34b4cadfbfc5fb7c3221f86989445ae36ced3c3de6c485a9d6e7f17d64b60324f43257cabc4ed2f3eb2e047a14ee57de0d3c03d1a644c21ebf1ae06971b8806903d5b9338f50ffdf7a32839558b2f2306da669d2d9cad78642243dd1c3f1a2492e50831a03e47e972443e1064f76e88f322775ec5b7bfe074ce5778949ca380891b0e8d47ebc96ee9eb030b53d0a7926f19572330e2a9f0613653bb6aacd7f448d02dd80bd1e1104e71e6fbbf822d53f76225bf3fbe3b3d723e92ea3da0e14d36530d7e52c79ba861393eb667d11b4a931c706304f4b2522dd4b2df36d78be8363b3082ff4fc3b00a502694ad4b264e9c2895fc8dd935e60f69962bed134ab3a8285151bac60b79712e9977236d7be915b45899503a6b7706d4cc254d82ecb1147b3091ddd6d955aa1102cf485e43e0042449954df50b1cc547d39d9e0a087afbab37cec38734034391631f84e529fb1107e3ab50bcdd3f144041dd51b27cb348db6c6b2276f8f86bb540e7735f7c76ee4119c29cd69aee79a8b20ad8694c641b3d8db74531ab81d7f1e8304bbd92f89105552c88f54af2ce50f57253b449efbd6509bffff048d3f06d70cfd6fb333c0be3badd232cf79d87b2cb921a05046e4843a24f9de797136fd9cc01942f5b528d0ad488e7774c8ab158ab7747dc4864fb4d43ccde8b2180fc8e429269ea4cf57b4f8f84cfd470b875bcdbc41611ed8050c208f54bc67b502f0e68279fb766a4a7c439415309b1aaede53acbc76ca20721bd12caefdf34b7ac959d55fa1a688abd121ef49eeee9c263cefc9ba6fe23ca21c0bddb3aedbb8d35ee295622b538287a0d1305114f8fe05cb8fc0bc2bb1710a5cfa8ebd500188b4bcfe5a65ab6619c3cd49d812c8d015bfc13184ed3917ccae1ea39a278cecc65748989f641f04a7a9ed2ede85a53683eadc09a788befb666650ba896187ba7ab4c18e197b43d93258a57632b9d917bc78c05c08f797ec95c80c6401f7b1a4721b24dfa9edebf14a2ab0049d4fdec4f6ad1405f86cbd3e4aeaa89db73ab092e35fb8c1bd292a896279d5fe9ca3b536f241d75357c5584acb64db5be92447900fc8b30a3af3aa4d62af1105a8e7a7f032ed32e2c112251810336e716dd16d24fd476dbc9682a6eb74ba355ffa3489d59a975d4c218ad201d56a3fbf4855410c9b78a024c7855601fe1cc2c4d20cdf18319e12e4b012b2668cfacefed3e2a673340b9583d0d877f12ee7b00e8eb92217dc823018dc971f618d570d113877db6f1f28b771c8f2413b168701d94a12125f7bca2e259e404fa55839acf745bd0351b6d69654903d0ee4e465c87bda9dcf380c2271d238373e7f4ff3e6059e87ef148669153329fca</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password Required.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Authenticaiton Failed.&quot; data-whm=&quot;Authentication Error.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;b837fca8ba0f65d891514e5dd70693f3332395bf01b17d1ed0a5d4608600339a&quot;&gt;7ab9a17ca32127080b77e873e4f9e808b190e7efa246dd5556933ba5299c5831ff9ec39b24ba3046fb8d8c62d6f77dec24e1405ec968f479531ffea387ce2e659a05899186dcb1466c87ebb8b9b10a78aa418f4cf82caf75e9edabdde52947637d958aa58caeeddbb9c19e14477b74ceb258dd5782bbe2bb5bf7a261d5517aa85c6df7f046d67542cab52643320ab4bb656a22ae83e09aff863aa429edc91faf5f1c72474b9240d8342a47f549eaa99dcade286ac81479348b2d239ca1899ffdff22f247369294454da9d5d384639bab6f60182adc5dc9b0a5e93ecfe28997da4c9e38e96b76d7a6553db32fe002510e691740561d7e35bbd8a71693f50817771607e9c5b9c9e391bbf0427b0b5d69913a30adb0a40f80394f193024231fa5f14703ca38a35f987f9c9fbaa88a0dbf5f3720bd148bb8885c01eccc2a8364e6718f26de08ff43d6abda1a0f57242099045e062bddc24dc3381f39e66b1a1cf27701ee89820665a28699f4d60c9f1d10c7f71c3186f6969a3fc1215cc09c1a46f8afeaeba61f54a995c92453720782fa9a6e5ff5e4be70d34e293fca33780b6aa51936ecad358a4a11333c1a1bde23d936671839d831eeb57ef6fc5485adcd80e1e60813d19f8a9581b174c3ed6a939a81c34cfa9c145694a41c28981c879bf4ef3712d58a6fab9055316ee609a80afa0829f71e0e1035e137b4cf4a3ef1b22861098c341e288478b5cb56d7f8a882449fa889b8bd52b48ae7cea3f7753e9a1946ae008c583cc580f052e8a32efa544659539c375ead50235553445e5200434de01b78f9158807a5dee8e76688aff0eb8842c701fc42fa9f201af5ffb9e5951844157c6cc687053056b378b59230fe3d09ab575c0b15abf2e3e4be0710b9fa559248df78d43c287d95c190ddf1386af45842d1e5da422b29410fb00d55919bb81b5cfd053c80e2b9863c14424684928244c36973e2734ca489b7459bf991c44ab22106af46f92ababd759e6afaa481089af1148ee007bc9884859aa1bbba5a42d56fa41f94af25ed649681d05e487f2ff0370e3ef5e357c6482a2fc0caa54ba9e000a9cb700a9353e01363681f8287583aa59d710ab3c4c6f7ff471bfbea9e90da1ff41fb590320e6722bb49ea470e2f22a357221b554544f7ff68644847ffe4b94c9422cc7abeadd4ad53e816c44cf315a6691c5944262d3b5f14e41f0c4b0b3be603d557ef5853d5531006c624fd8aa77047560c3133e24b7aef99d872532dc1aeb09d5bdee85e59f2ddc0c983394be2e3266134d314bd330fef3d2152a783719a9a9f5966d42883a9172d715e97e5e76f77fae3ad3a5e0b8d58af3fa8b1b778fa99fba704a867ed4c1c0e3ef31ea9a87e313fee76706b0cc6f2ea1d4a680fa09aeac19270c67b949afa9bb5944835534b16ebedfd955433ba06a922a38c2a78b5acda685bb3116b624d98c7432e836fc83588e65f70add2af8832c678e156c96e0bf38aba9ad816e75f65cb962a34796a294517b364391a6bc8f6ffbf9ff057b69741654b9ff636c761409977dcbcd1be4c504fcb71a51ea8dc0174036c7f40aa22bc756e2f8b556c99fd5c019c063a3baa54a7aa2236c40c1e9c3fc88cfac8f460af6b1e8aa09edb9572fb65d95647213c20de73ddaaa1ae59b8a38e344c721105e710bac3fb1b08e191209b344edff9b397dff4cfbdef24f03c35676d85df1af6a2b3e345a37164df59102afc8113a2be8e7c58528d21c39289e2b74f6272fdc2c153c78026da52e39a60cd76c0f0ebf1cc09572cf3406c73ee458e76570ebb958b0fc9baaa4f5abdf0d0351546efb98c6410214d71dfd2fb83591ebb82631cad1329917f3f8be295eb35cbff5b90774e9987181041144f0edf106264d61d9f75bf23a6f60714ba78c72dead80f3abd84ed6d14bdba5895d69ae92be37ef86212e40f7ebf8f4bc799a39a35c98a10953a597326436c46f1f6c02e626ae45ff48d94f5e19c35c37ee11faf9664176a9a91cf23bcb5ff0a300facd9b27f20cc5c1d8623746385416c545814ee33a0f120652293be64757caa9be99570f0d4e1116ad87cc526cd77ea49b4145661134b9058937171d629df25255e21f2b9119ce2ed6a3a4037e9d7b1f221d9d6d698616c34032453e1bf904ac2999fa11d164b3da916598e6ce219dcde6e7750b4a4cfcf21c4617a54dbfdab677660f4f81503c048241d82c89fff5405eb1c68828170536a948f75c112351c509c56fe82d0fa86dbbc2dbb947456b311b5b4b1abca9f9ccef482929b4f16bec4c819f84539e52aef2af66c9363683074ffdf5501a3dd8ec0f69c7d5507beb8e97778dab444f2d31516e09624a2f7043a01177938f607a9e952d526349e0faf7105b08bab1108081d08ee8c54dc784d8c3af6eab68867a9aa3ccf948ba5c0260aa763ece94abf0afe9643c19561ac2873257ba0b846588ded5e454d0d1a5eb76ab7070b6c9641744ba00b416c91d96ebb22dc4bc7ff5c1d2bd0222a92905d291e9b165d8405046c2233d540296e8601d9239091cc739d9724f4f3516ee3937bd3ad01e05e8c1fafea7d9fe360f35708ee347ade27cd0e1d0b21d4ddb6bb9df7a49e2072e5201dfc756c227ac1053771cc90a9a870155b4dc31177e925242bc1b9949fcf355d0bfb892c3bb10a753365d1b5df78e42dfc45d10d42d1965f73c7fedf2511f204f5b3462aaf183b4e05e2dd1fc7ec8410391cf424c21853676ac6184f25889ad2f8317fe6244405866f75c4117f1902eda22abdfd262b5310b8239ea0d7b9e373a66a498bc2eb1a88859b7cb8aa06331b53e0c35a67ba54812fc298bf19cff67cc859fb9ba0f7315b64259b6eb9f37165b36a134d4165dbaaaeb5c2e474ae82f67052330903d0375114ccbcf1d3415fe22c44ba0abeae2844e7803f8a7c8d30c017a21892b5d38451703254b5d68dbb473a7aec37039e96028b2fc817070a72af5c80a83588416972ac5b3c69bfe50b567b9deb8feb7b519d435d3a49d1dc65231a7094d046079aaa2427292e82e665724ce4469f098c62ba3d37f02afdd768088d136231e51cc6193dd560d878335e5caa06f7781226984da2ef7f408adeff17aaeb0e35c8ccaa4da55e20153511a3bcc38e6cbb37f13182d7a855020205180a65f8018f3f434381e8b074b45bb0b95aa79952028c55283074ffdf9b0562bca4d9b051db638dac406c91cab83202c1a0110e75473f9336d9241d4631ba455639e31b6e972fba01a252f86d800dba7d8321c98d8609bb919f029d6c8bb1eb8d8f4e092e968826b53c681f3a8cc19c7d04af11e3136a766ed00f0ed86b2ac410d4a8a3b6d98636bb0ab29b3980606884d20512d4105db7071906c3d4bf12a1f6107fc6d8ff8976470ebf4bf4873b9a16b6e3f821c7adf048a9b2a1137e9d86105b8c9d14d58608d32b2045ee90eebc81ecaf801d644420dd0ccd4ae943c9cd29ba2fc2d9e065c523ce6632d491b85db0c811bea0ec72bf82e1c4c960189fbecd42663986104b50e713c34247164c742dc05e49875181c8957babfc9835a217de0321686370d86b2343b0f9caf6c7a4bb8dd54c87222281903a0ecca889a16cf36ef9550c1182cd530ac2f7e925f65448c8781cb328d01f9ac9209a2a7895c0fe63f4dd7028bfeb17222601c0460d7dedf31cb9f3de5eb926d5be417ffa4f0cae2ac6ed04d7f65db6c9f6e9960e62b1e529543dff88c6066aeb09eb7122dfc72b423ffcf8e9a8fcad28cde3c0a3ca32b88cdbf16512f93cb1618e674fb3f23dae69e8edb06263b86463f7c515a84ab2a229ad93fe08800a6ce2527486a05039b357cd14e8ab694bdf1771323179ebda2c7e63beb763bd0f925fbb8668afa30d1251b1d4782f7d2a2dfd56b2322270bb9bce865e9ad7e01fbaa1294d29052b9284c0bb9787d6585d1d7f24a400b03728f39a7276e7527571770596c80be9238c6746155a0599621579985824f0d6914eb1ce23ad4fd8bc767d7962cb666262c87c8a961b9d1006882d6bff391ce9cf99738b59d67e32a6602eab92b1cb732f11848d577fe2b9247ff63d012ca7708a09dc17a2155846973ef3be263659d030498ac42e09e4a2717ac96559f1e8da0e06c5cdea8bef97951ddb6babb2b7f264afc9b253fd6ace12b7f32760607acdedacc6e2be859ca024281383b53edc769dbea00c1859a739cae741a1f1f447ae439301f3bcd33ae0afbca33ad812ad13bcc7e7be1d0a12e07e1c4e1ed69108ca159fc8afad3a4d544a3187b392fdd82af67fd0880404ad127da761b0f04be9f46f9810343a281c45a3b4277cf8cca719606f295c8cac4dab1bbc0c26da0b14d5f9b94013ce213f6d9b871fff02d05a22afbaeb9974d47452cad0999d6a673ee14029d057d7ce665e47fa787af5a8106916aa83ccf85e4fabdbef31a6627547d5e7402fcbbf225a690c7908e589324b87814a8cd32681681ceff20e29287a6ba70c66af870abc5efa64afba708db2addffe11687615ce7572b4f2de5d378a2c647a14cb922af2040c974b4eff63ac1cdeef7cca8891b2f35074eba79928538219ec64bc2d669f2e4c617fb94c9ff1ef90a31805385a3a247cbbf46d02d1c97dbac0864d117ebdf622666cf45aa9b35d171ea807749445ce4b3545b43690f90bbd67e6305ae23255dde1d123858878804d820a8a76014837ae944f01f46140e6a854287a9c1a9436283a6c96d3e1a0ba67887ee9ddfb0259a0180072bdf23af6f24bf7b6b47c5e74030d036f874d508e5c8a132fafee90985177020347087cb2383d7f4b019f6f9933c6b46693a7741eac1176e731ec6ad6b9cea75d2370d60d3b692fa2ef479320415c17252f9f41897493ae72052fe27f7e64b889912423f82a6d22232b430c9a5043b571117ced67de9c2f4b4fd221cd31c7173c04231315efbe33f4bf458c2ae73e43ddd2d1a5073f3e570d216a9bacd4cc6126e50c0171ee669429fdcb3d71fb62bac3dca0995b6b741cdfb82e9deeeb7b200ac3d35c496f8fd932694dc3923b8d0d03610b9604964463a905aea5c46803cd82217a6afc51a7cd42ad274851a16afa9f60c7227d52df52d981544c243a86b6e3b37cafd6f233dec8b8b2c3e333a18bc18eb8fcd94b1ffc08f0684c14327e92c727ade4ae3f3e2d1425cb2c7a39c1a2bd3b777187451c43ba41306dccc867d1dcb7794b31bef86332e7bbba511a26eea69341a3c437a7eed63a2854bdff5916df915d7063cd21f1dfd827aeec3ce84ff44b650166b51e2b631820b50b73f60aac910458b7bcf7262e2fc8833fe08c66af5af37b846ade36bfdbbb7515f5c2c932295c687053da145e07d73b1c8f2438bd82a025e44b4b2112b0aef0604441d5b877dcc63d1bfc64f4ef0523265fa94a97b2fc6ce20048a298701099577fe03ac93cd08df1cff9d2be939ce14637d6425e31f43a41ce48c76389847653f5b5d851ed0b0d9fe66a478df4cf899a7ecab8f19f9378426bde500106b3586064023ef00f645aaf53ff481a2701bcf6cb0496f02bbbad12f9989446abadb05a3a9f70209200099c700d162b95e8d8250c881433046638f50019e4edb3684aacc9e1e885940ab133d039d9c16139b6d1221185219ef753ce1072ab00d6290604d8f7ffcf92b162955957936b8e799aa47c2c1c628758249a2f500ce6d9351170e4dc11a173a686d6c1b6145c4d79a30d9193903d89c912d058d795327a201a21b3eec076e0e695b8d366bf68512d7110ccaac0802c0ede90a1fccbe4cd2e115019cba9c6ac025142f715ca55169d5ac8aac9589549e0cec2f10d51d69b7796d92e3254ec96ae9c3ea991b39c8b48ead89bedb4f630fce212736ea97c3384530b230e09f09afd8424cced83afdbf64e6d956b2c82b7a5a054a9ad77f900baeae94978fbc2519d131cfeb752f1c5392263ef051263517b2e86108a5109b5f6480449c478f436eac5c2f2fedf669db9c3d6eb95cd9d1ddb22ee57413c533bc674419580f211d3e91c4a9f7e6146f8050f77a60af946cabd71baea4e7af3f94a1c5cb26e303ecdd3eef36777d219646392e116ed62fdbab6ce7bc3847dbc53f19ccdd5936076a9f18bdec9153c388ed94742419e58b403b55227319b255efb57af107452f06f6ca5edd6161b5d6fc44d20a6272c09adb2d96afd536e80739e903e71ac098f836863ec05cd96de50009aec5b857de73c0e5cab55c5c267da9a168d81659ed9ec8b5c484b3fd06142ab42ddd5366cd7bca237c12dec710b7f6a5e66533bd59a28c34e58aa2a9d95de7803c50f69a4943fe5be1db84a9b0ba0d559a8167b02c754810a67924f3f794702ef5c642255ef3d96e53774b20c29e8acd217437cdd1e4ecdf7a263c96a1de4d67b2849143b229ddfdb39c57587fb311d07af6ba7b028807ab3d7bc0e08368b0c2d3332c7f6a68c6566b0631b175c4d8082423e020964a37894d7644247f4f5b677d687d946601c930feb8ef0c909731f07f4ccbd5954c49012caffd092ec3be4a43a0ab186bb16ac3f6e4a7754b0493457396a0786a0055690cca0d08fba7a3ebf305b1f70621aa6c24d3155e17f1776f7d53719d6817ddbb36b8c0130c5cd1135786111c77d39b486e7964d552e8760b740d2de099718c0c97266f5bab87602db2bddd52121c2e2f408b5fcc31110eaab2b0de9f0dda372bb1e5b7e5f40262cc7c2ad388d17b7252ff187404fabb06413f9f998a9cf1711e3bc317f0a22b1727836125986e8a72620ebe745763c231648dea8177398d24f2d2c2ed1cff80e742568fe8ae720bbdfe81546909418bca9bf23eae62be3beab992b4cd129f1f699989d197e4c12a635bd4da999d89efda3ad9e6c22f9c20cc107789f128a7a9b3fe295c5e5d012acbca91f4ae1631db739cc12f2f7180d421be9508942c4a24f9941ff6ef8c522f518806685eb2fae13819a5a3fc06b4bcedecdfbb43a0aa1f163e9dd91097b36577a5183a20ded54e4fc77f7c7f45b190689bec6138809222484b7cbbc7f2170ac3b250f8e69e2ccc85199316a11e872458870e1fe5353ddbd87fd1bee87101d64f007b684a7c454e90e72626f0b9a0984ba8df867e427ecc6599d8e554905c8f1464d9c7d151247f6fc25df9a92b8279f7e9c14bd929a24449665f3ed4f22a08426ffdcb1b94eaf86adc6d875150a838d2d7cbc3d53c96bf9954041fbfbad3587d72784224d88a547aa5858854169b1b6c5276a06423813e745f4e63348ab15dfd840bb968f2856bed322e2053e69b7f106282e5ad3bd884968cf78e74a1d92a305f5558ca2e2b3bc5c55bee1b8d20e861d18c6336038b2031cdb40325f44f86e2f48a4c45ec04f543f09f3ed28aea61eb14bca905e71764349bde2b65bac028478d6b1fae846d203fe1548fa8982d1eb1c5f49a4fb7f6bfd2bf4e58121b7f5c6125dbba784dd1da75f2c08894c1ba3555bf82ef0cb3e3d59137b06bcbae3f10f4bd9e60c2e4ede7ba47bc58a5b99ec7f3c1f650380c6d73d4b75201a1739ba4c7c40bd08729cd67f70db35f496efd449b25e0776e7f8f5dc3fea9030547c76bfe97935ab1cbbcf6e99c35d903484023fffe57f7716f7a4322eb5bd1ac86a6734c0778a342a40dd1a4661c0b6aba5e9b1493490cae4929c8c459d93ff5a53eadf4f310f2e9561b38aeb2cabb5683733f3763cb6d712252c63ed5e1f1308a44529368ba0624e1980ef2c56aacdbbfc8c626d659444a648f9c46e868f56c7d969cc9beab5c977cfa6367d9eec09cf330a7f78c9e7cd24c8c7eb56e9a93a3d7721cf908019839b1511816e629f7930784a6df6279ca328ee7ba33f9ce9524919f7d1aef7b87c3ea6d3ddb8b5c4a0f2db35683914b6111a2288a6090572a59b9c815dc84265cb827abaacbcb4d18a0db70c1e52d90b844ba899caddf2f1762b60b5c23eba7d1cb3ad0ce8a45ee83c8e781e67bdd2b367d97c4aac35c5a2a92b039b05b63b563322e53c053b620000b0dd5c93141e67ae556872ab14921d8aff3313b406547bc5b6459027e5a09839eb0b745824ef2e5da9184eb232bd78928dfa9caf8ee314afdf3fbbe9b6dcd1af93faf11680d378cdb49cde92412a4fe0ad4cbff5eef85f0e771f675b1359c1969416ede416851b80a323a30f32a979e6657be32b321e6381e1e5d5f912ccb6036bd31efe5dec749b0763648cb879c3acb8a94eeb0a6f42ced8be5ad653edb3c786fa5a9e2139625274eac639e9e51a12824bdfb9d8c5984a2687f4522c43e6ee1ed3235aea172b4a8c08ef28b5bde62c43fe6cbadd16be713930e2d7175c82b1f57cb886385f40ad3ee52baad410edde642bc6b0ff4b489feb4121adbedd310ec24e627cc56d41ed955fae9fe19b5ce1365b5b194cc9c68aed8b14b06aa30cff744e1f7d6424267557585599162b4dd2c0e83e14ba52b800212f0a906f99aa32fe02356165ea16f5ae9453c4b0985d29abab663eee9aa2beb761635eb6cdf35902052a3fdd0d2881acd1f466b39826bb3f382def1b99faf6ce5fce128e32f560b06b2090e57073d784cecdba6db341ef31a8f8bf146bb4ff89156d45fcd2bf33e99fff0e8a5b8f821b0bb384fba64a7e95935c51a467d93bc81c430954e7dd6f1c3d70df0fa764364919f969074b760c39e842d1d557e6a36ccc874b35ee5400a154ac012e0c6d367a446211ba34ef4e2b4316526f4a9a77dc6fea1ba8389a9d3d717088bc513fa968e5722e50c4317d35abf411ae1bb7ed81f60082b490a2b67e27e2b4cc5b39f7e8ed9a1c0e24bf548a8e84cf0a32604391d274219d98862342790d88791ebfcb00ad564bdf130fe116d82c74066a7b89e6939e8f87138fb57be066be8a11c89c09dcd00fbdbb85a5693c8f26f4096d9a984eba52fb0db3f2c3906b47740600e2a36e946a95babe1a2972b733d85fe5bdc8d2c2d68ea44a770afa53ccca71a2e3457f580cc2a445c237cf5a9c143c4a503d88317f04e6fd49ebc5af5841156c78e423b9cf8496cb1021103ba54a1b0f5df6e913bfb8f310c35cc4b0c2f87b04a81e07ddb664e1fb688ee18c20c7184f2f2087cf9a37f06b7e8b53d8338cb6667ce160e04d24bbd8276c8447e954b25a7c4ec2ff02bc48e1ee094e65ece344aea897d5b35a491e063e6cc6f61ef930e162e795d892f27cda9068416119d8b9a9809eb03c67fee73aba1c264ab55691796ee9d95075d90529d302243d98b765b13329ce9b7a83ac04326b122fda9cf336a1ba7f0f3fc56dadaf5fad8bcd06ab66a402d40471d0fb1f8da9c032709014ca6e6147b94d2e65c9835855c30b01e534434713742f3ed7bdddcda17156152ac4ccb66cabf35c4545303359c683e4bee2852ece1cdc92b75830ce8eaed7dde733f4bfe1e45b254fb8b596f6cfc272145cef577c6545292c920136bc58ba3b12be160229dcca2951ee194fadd504fd78118abcc7f801deb18fd8faee6fe28dfdb269318138962f9eb523621c00b3d712aea26b1ae73ae6681e8e5ea98cc0fac6c787c46994dae5ed8717e153cf2f4f646ae2268986be45665e7ee407b60f44a78336998528d84ac8fd88a61f12ea25398f4424e961030126996130bbb1fd3421bf3171f787e2424f94fb254b9336128d59e21f9a2bb38de18bf60c11c1074c39f1f978f0fe3786d6481815afef7a5bfe8d9b3e1d88915803e96b4578a2c80442b67910fe3d7ac4b3b459ea278002185dc8ef44f359069ccda870c8a5390171e8b94347941e10040290a0d7923b8229dd65fa90fec206005a78be784f2df9c4f6b790c14367f7a584a1952cd51f26a6ef6e35ab6cbf16159564d8432af645c271b4e8cbbc6739e5a4ad43e4e497d77b4adcc0e06dd95f3093c7464c0d838196590f7e0ccec629a146ff3170b920259f41077475f30a56db965d4102d74d7fb7771218d8930b618e5d3103b8df0b556ef7cea1e34918db969f1f91372a661d344b0e42db46cb0c40b64fc044586c86d8f07c49d8f04d3ffa968d271286794558ff9bae8d8330fa515a50c0b48e1c55dc6db2516e0de043f380dce7d59da9194391e664dd9e7308be3e9f94b3c5d34c1bffeed129d7a3a8d997c21fdcf8c09786293067abf3988c36abf5a22d351dd5d67f30bdf05c84499069345fc6c4263b3eaf8bd77419d214907ad3b518db9239f5735e0cdbea403eb14e1d55de73a148b147dc1ba1f1cfb68ce4daefd2e56192928d945c5988bbe91190a2b61f0ad74ce9b716b4b4d41608bd01d6b5713b95f716961410f93eba1b1201db675aec396afd75f0beaab57b0d89b92d67971d6f553c6cb9098ae5460259535793f6e5f9add0c52b804eb7257f24eac53de0625c1854943237efd030a84124eeab13d1e4aa3b55016175d1ed3c67fa4448eee25b86a8207808165e8f6a4d9223889b27e4eefe2c2f57f72afaa5afaeba0e2d28d5ec4314a5c1d37d4a00624df34be86aa8c5d06c3616587c19af26123a5ee0e83b526958dfa035df9edc9c5cce8065be31d86b997224ef6c810b466c7453ee5470830d4750dca6b45c881b2a1484af3d9bdf1138dbc117b921faa5ac91e4163b687d037d6db67de83c790ecd5a9bcbda2ca7d8a8a658004bc12a4799855d3f97ba72bfc5a855152783fe557211da65e83b4f7dfcc2b38cbc5b864139e50545b64096dab8d588ea7e5c2b8fe0fa2efe985c30065b07f54819fa2d512d400c52dd3abcf4e515c5fa6e938f01b53edc43b5df961001f4f726a08d5b782930e0a2908ab1932ca70a2c787ad5130c414b300b5be782e560b48c75ad299626190040759563b25ddfc367994e177bea2e696995165538e5dfcc399b57f76422045fd7aaefe7d76e09b88ca42122b3d13ef3d875fe3e343f7bcf660b6b862b8d95c838aa0cc728d8e21be3881b08d4499da5559d639a418710dcdb097f7f7dc6a837f4f4d96ee763484424d34eeea158021e5c8a70c1925d14dd657101190c8d89e5365eb3c43fb772794df19b7788e232c4c9b24eacf93847fe3b3300e42aab8c890e8ed13a7cfdb842d0d926250e253151d8187c940a63f8081b9fa141e048df30e31916c78c90d1d9e7546bc100992ba39860735c37b8507d1dc710610ba84c9f9a8f24b7a81fd47ab564b7c2ab88293fca9407314668d6b2b58b59996b016c27f6ee96b8fa5a932fb1aac010b6c1087002de8999b8604fda5c2108d6f78abff9009d13c69e767959e38fa8e71019739e8cac91cdd268123fc4eb8de13697bb450b6dea3973edfb54e0c70be1b385aecb5e16851273eddab8c8f47c8490eb0e90622ef479c0a9f90558702233faf46d0a120323eb69f41ac403339f52dfab0ab6064a6f6d1632bc04a2adcc11dba721ee5ffa4246993d39cb48679e49f855b3d9aea3f2151d25cb1a03c0699e1f10a6174ad6e1c01b1d41a348ccdc1dcd79ed7f62aa352b692219f73e20ecdc25e49b328da97e7bdcea12123106d2201ae8e8fd7f8d90a9283eb236ef7a431a9beb55a1498539a2d8fa3a55e619ce271fd727689da959ef6bda0e2e0549ea87b086cdf70c95c8977eb8b9705161fcc8d4e7b0044ab0bc9b68c649db3ff351bac09388cbcdf601f54fd7a9f174eefaceac35a935d38c9f1a2e54f4e3fd99f3f0904d55e184ad3f0ba88a7be18a2851e61950f1990fff46c4c4395d5cfb750d45dc7c9ab00dc758c73addad74d554a6c274819a04ac866a19d782992273742abd978a807052f4ba2005a7535e841abd7fc98d7e8f933b479296a52a2fd87c7e6b69828f0f3cc67dbdfa2bbec59850421e528b2b99c50e4593bd6be00641b5e8cf709b2059ba7118dad3bf6a7912dd7360d0446b95009535ee5ac8c3bf2df2c0f03965137cbba39f5e3d7d3d649b3fd026750627bcc33182918b2f2bb41fcc1a0d6ad6bb354b00269eb448c2c8c4eebce10a08af2e94dcef9d0ab2e87caec57b6f1945ef2534c8000a21fd870e6d5a49ff9118857bf7bb9838482102c8a4651bc9ac157a225caafa3b4cf00bfe7ed8fa3d7429dd0ee7b441cbf0ed7881aea49908dc66632fc284c13abc70ab6e42c0289850a60521cd3781deff2c1ed1f1347ae7733d5b2ea7471b094f6ae5e5cff5ce9729b676cee54b513d42e458fba3d0c4ee4e81ce5b61605c932a0df97474a28dfeda7e1aa2f2207396c042bcc6a6103175e1010703b1e0583b3f8ff3cccef385eff0e80349f3f8968cad71eb3ecee7e6a26db08b43012fc034d39c8295c8ebedbf93eca532a66dbda014d4602c482f2e9b2b92442ceb74587abf247e500803ca5e17ce053f127a37d7f3dac394ab7e4606f85abe91963ec0d4cd241ed5d0bc50b1d6da7cb6b795de0b1307b1db92c7c3372d64350459de19b821102b3603866a461b209981c1452b14a6939b7d3e2ca071a78c52c28a0519b87dbee91bc2783438be60f04bfc996c977b9783e5fb502726237d1dade5d5bf3266f656c7a4b584ef26eb8ea34219b7d7321b770f343ba68824e8b2dc5ca857ebc7e232b96111795d90e6e2e3becaec2076782b852c0346dee66e82a24fe6db473d1baa7bd4300b4c78083ff9d3da6bad3cc3dd7bd152f487d44baaa087c25bdb67a59f3c549942c9dde5fa3de02b722ef05bffc33da6eaa7bbc6ed0f96ce95836d83aa46684203f010089c61bc6e4bb4be0308e35b788e12f5ade433a48c16f5c6b67cbd037105c02ace832758f272659de5d83b432628222a3b48d8ba4e3fa5e1fb5746e19a275d06c21b3d7761780da897c2bfa5f737c39d891094eb5d761a3bd23e6cab8e2f4c64546c917796b4878c1361f6ea5f69e1aeb4d8cffe4f3f9771d37ec9b64e312755b01435784af6100a7ac4ad0ea7bb3d250c227f3516ba20c7e32374d4e8b51a4fd26420866bb5ef219f20009787766c8d8990727cb0e82409e39890ed27a794147ca168b76ec54fb0ba9a6953a91927cdba73818929f383fe8457feea4a217898abf9d71c1d379076ac840be5455c51f24e8a0489d45a6bf98de330c4ea3469a3e49bbede4605eef08e747b4a4be7d580d86baf36c5c44367d8b8cf1225ed1475564726214a7ccf1dda1112313ff3e49ba8c8fde5e54b29e28490811c753ecd56c02871358f236b890e15ff9e26aed439558c470fa7b0e07e58773f469e00a64f70d3747202f0cf18b30b49c8263c95e0c004ac8b8819bef0150bac33668f389c79aea4f4b7414a0daf0ca409c507dc1b0262824d179e4c1e143dcc7940f57654228d2be40cf4f0af1ec08de1593b213ee007b33390040d2993f62403485aefe200fc21be2a543de2065019de843d9b4dea3f500b36badc1fe869ac590692a22c772d2798a38d43b77f3a9027813dc624ec11275f7c66ba463e07f4d0b5b1ecccd4a3d256451b8f4dbd5d89de871b2ce5536a5c657ef3aed910921520c361c12453f12bec21ab53f32f03f24d28fe56e09b66a17ddbbad0aa133b75fa6586f9c0edcdeca86670dededf9411f5e9c49f9b93e86bb1f627be4752dcd4937a79ab8ff2c48b54fe2441f46b641b348fca8b32dcc6205dcfde36e3978f0ef091fa8dfc9fdff3576785a1888286d1474361c862971c4aa9d5d496dbf4609a6efcfe8d35a9f8e37efc0d88aab8530473f7cf43ffedded8e4cbeabd100efcb05e21ad2295c85f29a31a9aafb2834925b6aed63d0637338893050656a32e43864c4ebdde3a18a1312d680fd25b25d964a636bfc6254ac371bae5102c7940e099f0ac3522d564331428e2e64aaf64c3b7fbde7e56d3d5636645286ba028c6cc34cd9a2119faf5849ca739ce31f4300f17d7ee3b9850f9bbd6f0c5e9869ae76b4c3f6dc1c435b238d3bdb1854346375410a1128acc0c4ae1ebd8e8dd753e79173d66873d80aaf44f104c2ff543ea16237dd7186cb5a4e18ce0b2c1e5bbafe230cba367d50a0cf19a8f9bb57c3622d0a4922011127a6af437cb3914c86286de2e0a072973182727c4a15648925f6910478df03aa9e0e3e4c9b8b34c756a5882896e0dd65029891642c738e673d55a35c7e428730b453fe017d0e4aeeb00afa0162f60a5b97c5c1168baa08f9a9f8d6ee5157cea96efd2ac9fdf7a1bc3acc15329614ea022464801aee8eb0b711a3991f61951794dddc52f8c5b86e953a01e14f379ffc4cc8b42ec92137f8577ba7917545449ce492f8951cca0851c6895bba10922d57d0607cd9ff70e67ac901e91c794297a31a804f3ec00fe0c94735718ff1991d966b76cd68d286689960991b55e69f0cfc17bd77c02c437a7b98a1e8a08ff86ce4c491588d7f8a0bffd6e44fa1c79778bad3c83d087cde909c56592a5716d9db88c34d922551729a93a602a69ba497d709e4397a7fed128eb89a356f7a1f561beabb047916ac0c2ca1fed3d8d5330f6d1b485a161fc5dc22bc4050497964c77eedfb66fc827de930d5ee50559a6aa99bfdb46deebb8dacff2c6789c3180aaaa0db1ebe3ecc4a544eeb9a2c053253537402634319d7d17a4b4e4d193052374b95aac03b4689278f7ca86373e8ec32832bfc1bf00fbd1b225bb3d388f26e1310d49e973af87e4ecb5a0573faee2cd366514a2fb9303c459be09d5c7894808db5555368007227b097cdf2eb42693013aee4ca2345ae20b9cbcdd615bfbb0d3dc2323c14cb59d529bcb80b9c9b621fa9d517e80dd2a5e74be7131fec94eee511dee8a043bcfcb9b2e9262efed89155f3a90eb9869450c07e5bffbf0ae6504935a6d078499cc1be7f11241d5fad90326ace20c94c93089c1416e623b301c981d3867f01f2cc8208c1f29f1abcfd977e9d9c34a20d403473e89cc74e81691d15b2790fb4a96e1a4b698c211a7ed388240e176bc8fd4ff95bafa42538277c206b6b64c6200409b6a391fc31f428f250e94c953d57b4126676af5a82b939b662c0ebfa853a3f9653f2d08bca080e4e3f35d34ffd240d5c12d2943aeb7003074dab1995027177a8f5b1042328fb2831e94722c4d2e7f05e9e0b97c35cf2bcd7044425c8f6f082865b69b65fe905f848faf2296a2351247ad9a372cacb326a0714f40649a5c93b3be4354eb33869021a4b17bf64b782699ef80b489a1925bc09b0511ed88736e996def82745788b671cf4086744f497df40abd95436fc5007be0f64d7cabecb6a648b36c8f7c8d0aedb9327c658cdb881d6254a39c3c743c23063bd5742bb5d0ce59d59c0a2be9241fa50acdb4f2751f05c54b2622cedfaaf1ceeb5efc874f18d96eadfb1a22c16f93bc7138c9a385a8dd11af9243d294b34b4cadfbfc5fb7c3221f86989445ae36ced3c3de6c485a9d6e7f17d64b60324f43257cabc4ed2f3eb2e047a14ee57de0d3c03d1a644c21ebf1ae06971b8806903d5b9338f50ffdf7a32839558b2f2306da669d2d9cad78642243dd1c3f1a2492e50831a03e47e972443e1064f76e88f322775ec5b7bfe074ce5778949ca380891b0e8d47ebc96ee9eb030b53d0a7926f19572330e2a9f0613653bb6aacd7f448d02dd80bd1e1104e71e6fbbf822d53f76225bf3fbe3b3d723e92ea3da0e14d36530d7e52c79ba861393eb667d11b4a931c706304f4b2522dd4b2df36d78be8363b3082ff4fc3b00a502694ad4b264e9c2895fc8dd935e60f69962bed134ab3a8285151bac60b79712e9977236d7be915b45899503a6b7706d4cc254d82ecb1147b3091ddd6d955aa1102cf485e43e0042449954df50b1cc547d39d9e0a087afbab37cec38734034391631f84e529fb1107e3ab50bcdd3f144041dd51b27cb348db6c6b2276f8f86bb540e7735f7c76ee4119c29cd69aee79a8b20ad8694c641b3d8db74531ab81d7f1e8304bbd92f89105552c88f54af2ce50f57253b449efbd6509bffff048d3f06d70cfd6fb333c0be3badd232cf79d87b2cb921a05046e4843a24f9de797136fd9cc01942f5b528d0ad488e7774c8ab158ab7747dc4864fb4d43ccde8b2180fc8e429269ea4cf57b4f8f84cfd470b875bcdbc41611ed8050c208f54bc67b502f0e68279fb766a4a7c439415309b1aaede53acbc76ca20721bd12caefdf34b7ac959d55fa1a688abd121ef49eeee9c263cefc9ba6fe23ca21c0bddb3aedbb8d35ee295622b538287a0d1305114f8fe05cb8fc0bc2bb1710a5cfa8ebd500188b4bcfe5a65ab6619c3cd49d812c8d015bfc13184ed3917ccae1ea39a278cecc65748989f641f04a7a9ed2ede85a53683eadc09a788befb666650ba896187ba7ab4c18e197b43d93258a57632b9d917bc78c05c08f797ec95c80c6401f7b1a4721b24dfa9edebf14a2ab0049d4fdec4f6ad1405f86cbd3e4aeaa89db73ab092e35fb8c1bd292a896279d5fe9ca3b536f241d75357c5584acb64db5be92447900fc8b30a3af3aa4d62af1105a8e7a7f032ed32e2c112251810336e716dd16d24fd476dbc9682a6eb74ba355ffa3489d59a975d4c218ad201d56a3fbf4855410c9b78a024c7855601fe1cc2c4d20cdf18319e12e4b012b2668cfacefed3e2a673340b9583d0d877f12ee7b00e8eb92217dc823018dc971f618d570d113877db6f1f28b771c8f2413b168701d94a12125f7bca2e259e404fa55839acf745bd0351b6d69654903d0ee4e465c87bda9dcf380c2271d238373e7f4ff3e6059e87ef148669153329fca&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-default&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-default&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-default&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-default&quot;&gt;Password Required.&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script data-pjax src=&quot;/lib/hbe.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/hbe.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Network Security" scheme="https://hejueyun.github.io/categories/Security/Network-Security/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS-PKI笔记</title>
    <link href="https://hejueyun.github.io/posts/d4e10e6c/"/>
    <id>https://hejueyun.github.io/posts/d4e10e6c/</id>
    <published>2021-12-29T16:43:09.000Z</published>
    <updated>2021-12-29T16:47:08.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>机密性：对称加密</li><li>完整型：消息验证码（MAC）</li><li>可用性：数字签名（DSA）</li></ul><h3 id="DH密钥协商算法"><a href="#DH密钥协商算法" class="headerlink" title="DH密钥协商算法"></a>DH密钥协商算法</h3><blockquote><p>通讯双方任何一方无法独自计算出一个会话密钥，通讯双方各自保留一部分关键信息，再讲另外一部分信息告诉对方，双方有了全部信息才能计算出相同的会话秘钥</p><hr><p>ECC算法和DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥</p><p>由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。</p><p>为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。有两种方法可以实现此目的：</p><ul><li>用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。</li><li>使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。</li></ul></blockquote><span id="more"></span><h3 id="PKI-Public-Key-Infrastructure，公钥基础设施"><a href="#PKI-Public-Key-Infrastructure，公钥基础设施" class="headerlink" title="PKI(Public Key Infrastructure，公钥基础设施)"></a>PKI(Public Key Infrastructure，公钥基础设施)</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><blockquote><p>To enable the validation of, and to give legal meaning to digital signatures.</p><ul><li>To allows mutual authentication using public-key technology.</li><li>Does not dictate the use of a specific public-key cryptographic algorithm, nor does it define a specific hash algorithm</li></ul><p><strong>实现数字签名的验证，并赋予数字签名以法律意义</strong>。</p><ul><li>允许使用公钥技术进行相互认证。</li><li>不规定使用特定的公钥加密算法，也不定义特定的哈希算法。</li></ul></blockquote><p>安全性来源</p><ul><li>法律</li><li>自身私钥安全</li></ul><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><img loading="lazy" src="/posts/d4e10e6c/2.png" width="500"><ul><li>证书标准规范X.509<ul><li>版本号(Version Number）</li><li>序列号（Serial Number）：由CA维护的为它所发的每个证书分配的一的列号，用来追踪和撤销证书。</li><li>签名算法（Signature Algorithm）</li><li>颁发者（Issuer）</li><li>主体(Subject) : 证书拥有者的标识信息（Distinguished Name），如：<code>&quot;C=CN，ST=Beijing, L=Beijing, CN=person.org.example.com”</code>；<ul><li>域名</li><li>公司信息</li></ul></li><li>主体的公钥信息(SubJect Public Key Info）<ul><li>Issuer Unique Identifier</li><li>主体公钥（Subject Unique Identifier）：公钥的内容</li><li>Ext:<ul><li>公钥算法 (Public Key Algorithm) …</li></ul></li></ul></li><li>CA’s Signature</li></ul></li><li>X.509 <strong>BASE64编码</strong>(PEM格式)，后缀为：.pem .cer .crt<ul><li>PEM：Privacy Enhanced Mail</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">asdasdasdasd</span><br><span class="line">...</span><br><span class="line">asdasdasd</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><ul><li>SSL证书通用名（CN）通配符<blockquote><p>SSL通配符证书是在一个单一的证书中，在通用名（域名）中包含一个“<code>*</code>”通配符字段。这使得该证书可以保护无限数量的多个子域名（主机）。例如，一个通配符证书<code>*</code>. <code>domain.com ，可用于www.domain.com ， mail.domain.com ，pay.domain.com …</code></p></blockquote></li></ul><h4 id="CA-Certificate-Of-Authority-认证中心"><a href="#CA-Certificate-Of-Authority-认证中心" class="headerlink" title="CA(Certificate Of Authority,认证中心)"></a>CA(Certificate Of Authority,认证中心)</h4><blockquote><p>所谓的CA，通俗来说就是担保人，互联网上所有身份的担保人。 <strong>trusted party</strong>.</p><p>比如说Google需要向用户证明自己是Google，那么Google就需要找到一家靠谱的CA，请工作人员核对各项手续和身份证明，然后为Google签发一张数字证书（Certificate）。<strong>在证书上,记载着Google的所有身份信息，和一个CA签下的数字签名（Signature）</strong>。</p><p>而CA的私钥（Private Key），是用来签名的一段二进制数据，通俗来说就是CA手里的那根签字笔。一旦这根签字笔外泄出去，那么攻击者就能够随心所欲地签发任何证书，伪装成Google、微软、中国银行等任何一家公司/机构，直接颠覆整个互联网的信用体系。用户将无法分辨网线对面到底是银行还是黑客，只能任人宰割，这可以说是不亚于“互联网崩溃”级别的大地震。</p></blockquote><p>工作内容：</p><ul><li>CA’s signature provides secure binding of the public key with its rightful owner’s identity.</li></ul><img loading="lazy" src="/posts/d4e10e6c/1.png" width="500"><h4 id="RA"><a href="#RA" class="headerlink" title="RA"></a>RA</h4><blockquote><p>RA扮演的角色相当于是一个防火墙或者说签证官，所有的申请都要先交给RA。审核通过之后，申请才会被上呈到CA手里等待确认。在CA和RA之间，存在一条双向认证的保密信道。只有手握RA私钥的人，才会被当做RA来对待，才有资格向上提交申请。这就保证了CA的通信接口不会直接对外暴露，减少了防守方的工作压力</p></blockquote><h3 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h3><blockquote><p>如果不面对公众服务，仅面对小部分的内网服务，那是没问题的，没必要去买证书</p><p>在客户机上安装用于签发证书的CA到可信区域即可</p></blockquote><ul><li>通过openssl生成证书</li></ul><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>根证书</p><blockquote><p>根证书是CA认证中心给自己颁发的证书,是信任链的起始点。安装根证书意味着对这个CA认证中心的信任</p></blockquote><p>中间证书</p><blockquote><p>证书颁发机构（CA）不会直接从根目录颁发服务器证书（即SSL证书），因为这种行为是存在不安全因素，因为一旦发生错误颁发或者需要撤销root,则使用root签名的每个证书都会被撤销信任。</p><p>因此，为了避免这种风险发生，CA机构一般会引用<strong>中间根</strong>。<strong>CA机构使用其私钥对中间根进行签名，使浏览器信任中间根。然后CA机构使用中间根证书的私钥来签署用户申请的SSL证书</strong>。这种中间根的形式可以重复多次，即使用中间根签署另一个中间件，然后CA机构通过中间件签署SSL证书</p></blockquote><p>证书链(Certificate Chain)</p><blockquote><p>信任锚证书CA 环节可以对中间证书签名；中间证书的所有者可以用自己的私钥对另一个证书签名</p><p>Web 浏览器已预先配置了一组浏览器自动信任的根 CA 证书。来自其他证书授权机构的所有证书都必须附带证书链，以检验这些证书的有效性</p><hr><p>Starting from the top: Root CA issues certificates to sub CAs, which issues certificates to sub-sub CAs, and …., finally down to the end users. This sequence of certificates forms a Chain of Trust or Certificate Chain. 本质上就是不停的发证书</p></blockquote><ul><li>Alice’s Certificate Chain</li></ul><img loading="lazy" src="/posts/d4e10e6c/1.png" width="500"><p>查看浏览器受“信任的根证书颁发机构”列表</p><img loading="lazy" src="/posts/d4e10e6c/2020-09-13-16-15-59.png" width="500"><h3 id="撤销（Revocation）"><a href="#撤销（Revocation）" class="headerlink" title="撤销（Revocation）"></a>撤销（Revocation）</h3><p>原因</p><ul><li>The user’s private key is believed to have been compromised（泄露）.</li><li>The CA’s private key is believed to have been compromised.</li><li>The user should no longer be certified by this CA.</li><li>The user no longer needs this certificate.</li><li>etc</li></ul><p>防止抵赖和否认（protection against repudiation, or false denial）</p><p>证书吊销列表(CRL)</p><blockquote><p>证书吊销列表 (Certificate Revocation List ，简称： CRL) 是 PKI 系统中的一个结构化数据文件，该文件包含了证书颁发机构 (CA) 已经吊销的证书的序列号及其吊销日期。</p><p>CA系统生成CRL以后，<strong>放到LDAP服务器中或Web服务器的合适位置</strong>，供用户查询或下载</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><img loading="lazy" src="/posts/d4e10e6c/2020-09-13-17-29-48.png" width="500"><ul><li>LDPA：Lightweight Directory Access Protocol（轻量目录访问协议）</li></ul><h4 id="证书申请过程"><a href="#证书申请过程" class="headerlink" title="证书申请过程"></a>证书申请过程</h4><ul><li>用户申请<ul><li>公钥和自己的身份信息 =&gt; 安全服务器</li><li>安全服务器 =&gt; RA</li></ul></li><li>RA审核<ul><li>如果RA同意用户申请证书的请求，则<strong>对证书申请信息做数字签名</strong>；否则拒绝用户的申请</li></ul></li><li>CA发行证书<ul><li>用户申请和RA签名 =&gt; CA</li><li><strong>CA对RA数字签名做认证，如果验证通过，则同意用户请求，颁发证书</strong>，然后将证书输出。如果验证不通过，则拒绝证书申请</li></ul></li><li>RA转发证书<ul><li>首先将证书输出到LDAP服务器以提供目录浏览</li><li>知用户证书发行成功，告知证书序列号，到指定的网址去下载证书</li></ul></li><li>用户证书获取<ul><li>用户使用证书序列号去指定网址下载自己的数字证书，<strong>只有持有与申请时提交的公钥配对的私钥才能下载成功</strong></li></ul></li></ul><h4 id="证书验证过程"><a href="#证书验证过程" class="headerlink" title="证书验证过程"></a>证书验证过程</h4><blockquote><p>接收方收到消息证书后，使用CA公钥对数字签名解密生成消息摘要，对<strong>证书内容</strong>进行hash生成摘要，两份摘要进行比对可证明证书内容的完整性与真实性（具体还要看日期、找LDAP服务器验证CRl等等等）</p><ul><li>使用CA私钥进行签名和公钥解密，可以证明证书确实是由CA发布的（CA的公钥一般来说由浏览器开发商内置在浏览器的内部）</li><li>两份摘要的对比结果，可以证明证书内容是否在传输过程中被改动</li></ul></blockquote><p>X.509 - Authentication</p><h4 id="证书撤销过程"><a href="#证书撤销过程" class="headerlink" title="证书撤销过程"></a>证书撤销过程</h4><ul><li>用户申请：用户向RA发送一封签名加密邮件，申请撤销证书。</li><li>RA审核：注册机构同意证书撤销，并对申请签名。</li><li>CA更新CRL：CA验证证书撤销请求的RA签名，如果正确，则同意申请，并更新CRL，并输出。</li><li>RA转发CRL：注册中心收到CRL，以<strong>多种方式将CRL公布（包括LDAP服务器）</strong>。</li><li>用户告知：<strong>用户访问LDAP服务器，下载或浏览CRL</strong>。</li></ul><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span><span class="tag">&lt;<span class="name">request-URL</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">entity-body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h4 id="证书验证阶段"><a href="#证书验证阶段" class="headerlink" title="证书验证阶段"></a>证书验证阶段</h4><ul><li>浏览器发起 HTTPS 请求<ul><li>支持的加密以及版本</li></ul></li><li>服务端返回 HTTPS 证书</li><li>客户端验证证书是否合法（根ca），如果不合法则提示告警</li></ul><h4 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h4><ul><li><p>当证书验证合法后，在本地生成随机数</p></li><li><p>通过证书公钥加密随机数，并把加密后的随机数传输到服务端</p></li><li><p>服务端通过私钥对随机数进行解密</p></li><li><p><strong>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</strong></p><ul><li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</li></ul></li><li><p><strong>四次握手后；用”会话密钥”加密内容</strong></p></li></ul><img loading="lazy" src="/posts/d4e10e6c/2020-09-16-18-26-16.png" width="500"><h2 id="哪些没加密"><a href="#哪些没加密" class="headerlink" title="哪些没加密"></a>哪些没加密</h2><ul><li>只有<strong>ip</strong>和<strong>端口</strong>不加密，其他的都加密了<ul><li>domain（域）暴露，path（目录）不暴露</li></ul></li></ul><blockquote><p>While HTTPS encrypts the entire HTTP request and response, the DNS resolution and connection setup can reveal other information, such as the full domain or subdomain and the originating IP address, as shown above.</p><p>Additionally, attackers can still analyze encrypted HTTPS traffic for “side channel” information. This can include the time spent on site, or the relative size of user input.</p><p>IP地址和目标域名在通信过程中未加密。 甚至加密的流量也可以间接显示某些信息，例如在网站上花费的时间，所请求的资源或提交的信息的大小</p></blockquote><img loading="lazy" src="/posts/d4e10e6c/2020-09-15-09-53-39.png" width="500"><h3 id="http攻击"><a href="#http攻击" class="headerlink" title="http攻击"></a>http攻击</h3><h3 id="HTTPS中间人攻击"><a href="#HTTPS中间人攻击" class="headerlink" title="HTTPS中间人攻击"></a>HTTPS中间人攻击</h3><ul><li>没有对证书校验<ul><li>身份伪造</li></ul></li><li>没有对主机名验证<ul><li>身份伪造</li></ul></li><li>CA被攻击导致私钥泄露<ul><li>中间人攻击（也就是身份伪造）</li></ul></li></ul><blockquote><p>证书的作用不只是HTTPS加密。可以用于伪造VPN认证、文档、邮件、数字签名，借此实现潜入公司内网等目的。</p><p>为了获得SSL加密通信的内容，中间人需要获得加密所使用的会话密钥。中间人采用的方法是，装成目标网站，向客户端出示一个伪造的同名服务器数字证书。为了这个伪造的证书通过客户端的检验，中间人必须让签发这个伪证书的CA的根证书进入客户端的受信任列表</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/cheidou123/article/details/94776328">【深入浅出HTTPS】_屎蛋的铲屎官-CSDN博客</a></li><li><a href="https://www.zhihu.com/question/22260090/answer/648910720">CA 机构是如何保护自己私钥的？ - Gh0u1L5的回答 - 知乎</a></li><li><a href="https://www.jianshu.com/p/c65fa3af1c01">PKI/CA工作原理及架构 - 简书</a></li><li><a href="https://blog.csdn.net/lk2684753/article/details/100160856">数字证书及CA详解_lk2684753的博客-CSDN博客</a></li><li><a href="https://https.cio.gov/">The HTTPS-Only Standard - The HTTPS-Only Standard</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;机密性：对称加密&lt;/li&gt;
&lt;li&gt;完整型：消息验证码（MAC）&lt;/li&gt;
&lt;li&gt;可用性：数字签名（DSA）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;DH密钥协商算法&quot;&gt;&lt;a href=&quot;#DH密钥协商算法&quot; class=&quot;headerlink&quot; title=&quot;DH密钥协商算法&quot;&gt;&lt;/a&gt;DH密钥协商算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通讯双方任何一方无法独自计算出一个会话密钥，通讯双方各自保留一部分关键信息，再讲另外一部分信息告诉对方，双方有了全部信息才能计算出相同的会话秘钥&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ECC算法和DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥&lt;/p&gt;
&lt;p&gt;由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。&lt;/p&gt;
&lt;p&gt;为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。有两种方法可以实现此目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。&lt;/li&gt;
&lt;li&gt;使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Computer Network" scheme="https://hejueyun.github.io/categories/Computer-Network/"/>
    
    <category term="Notes" scheme="https://hejueyun.github.io/categories/Computer-Network/Notes/"/>
    
    
  </entry>
  
</feed>
